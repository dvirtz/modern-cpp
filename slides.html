<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/atom-one-dark.css" />
    <link rel="stylesheet" href="./_assets/node_modules/github-fork-ribbon-css/gh-fork-ribbon.css" />
    <link rel="stylesheet" href="./_assets/css/custom.css" />
    <link rel="stylesheet" href="./_assets/css/animations.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section ><section data-markdown><script type="text/template"># C++11 and Beyond! <!-- .element: id="title" -->

<img id="logo" src="00_title/cpp_logo.png" alt="logo">

<table id="versions">
  <tr>
    <td><h1 id="v11">11</h1></td>
    <td><h1 id="v14">14</h1></td>
    <td><h1 id="v17">17</h1></td>
    <td><h1 id="v20">20</h1></td>
  </tr>
</table>

[Dvir Yitzchaki](https://github.com/dvirtz)

<aside class="notes"><ul>
<li>The first C++ standard was published on 1998 with a small bug fix update on 2003.</li>
<li>After being stale for over a decade, starting from 2011, the standard switched to a train model where a new standard is being released every 3 years.</li>
<li>In this series we&#39;re going to discuss the new language and library features added to the C++ standard in the new revisions released since.</li>
<li>On each session we will have one main topic and smaller features will be introduced as needed.</li>
<li>Let&#39;s start.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<div class="split">

## Chapters

1. [`auto`](#/1)
2. [Move Semantics](#/2)
3. [List Initialization](#/3)
4. [Variadic Templates](#/4)
5. [Lambda Expressions](#/5)
6. [Smart Pointers](#/6)
7. [`chrono`](#/7)
8. [Error Handling](#/8)
9. [Concurrency](#/9)

## Index

- [C++11](#/cpp11)
- [C++14](#/cpp14)
- [C++17](#/cpp17)
- [C++20](#/cpp20)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="cpp11" -->

## C++11

<div class="split index">

### Language

- [x] [`auto`](#/auto) and [`decltype`](#/decltype)
- [x] [defaulted](#/defaulted) and [deleted](#/deleted) functions
- [x] [`final`](#/final) and [`override`](#/override)
- [x] [trailing return type](#/trailing_return)
- [x] [rvalue references](#/rvalue_references)
- [x] [move constructors](#/move_constructors) and [move assignment operators](#/move_constructors)
- [x] [scoped enums](#/scoped_enums)
- [ ] `constexpr` and literal types
- [x] [list initialization](#/list_initialization)
- [x] [delegating](#/delegating_constructors) and inherited constructors
- [ ] brace-or-equal initializers
- [x] [`nullptr`](#/nullptr)
- [ ] `long long`
- [x] [`char16_t` and `char32_t`](#/utf_chars)
- [ ] type aliases
- [x] [variadic templates](#/variadic_templates)
- [ ] generalized (non-trivial) unions
- [ ] generalized PODs (trivial types and standard-layout types)
- [x] [Unicode string literals](#/utf_chars)
- [x] [user-defined literals](#/UDL)
- [x] [attributes](#/attributes)
- [x] [lambda expressions](#/lambda_expressions)
- [x] [`noexcept` specifier](#/noexcept_specifier) and [`noexcept` operator](#/noexcept_operator)
- [ ] `alignof` and `alignas`
- [ ] multithreaded memory model
- [x] [thread-local](#/thread_local) storage
- [ ] GC interface
- [x] [range based for loop](#/range_for)
- [x] [`static_assert`](#/static_assert)

### Library

- [x] [atomic](#/atomic) operations library
- [x] [`emplace()`](#/emplace)
- [x] [`std::unique_ptr`](#/unique_ptr), [`std::shared_ptr`](#/shared_ptr), [`std::weak_ptr`](#/weak_ptr)
- [ ] `std::move_iterator`
- [x] [`std::initializer_list`](#/initializer_list)
- [ ] stateful and scoped allocators
- [ ] `std::forward_list`
- [x] [`chrono`](#/chrono) library
- [x] [`ratio`](#/ratio) library
- [ ] new algorithms
- [ ] Unicode conversion facets
- [x] [`thread`](#/concurrency) library
- [x] [`std::exception_ptr`](#/exception_ptr)
- [x] [`std::error_code`](#/error_code) and [`std::error_condition`](#/error_condition)
- [x] iterator improvements
  - [x] [`std::begin`/`end`](#/begin_end)
  - [x] [`std::next`/`prev`](#/next_prev)
- [ ] Unicode conversion functions
- [ ] `std::array`
- [x] [`std::tuple`](#/tuple)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="cpp14" -->

## C++14

<div class="split index">

### Language

- [ ] variable templates
- [x] [generic lambdas](#/generic_lambdas)
- [x] [lambda init-capture](#/lambda_init_capture)
- [ ] `new`/`delete` elision
- [ ] relaxed restrictions on `constexpr` functions
- [ ] binary literals
- [ ] digit separators
- [x] [return type deduction](#/auto_return) for functions
- [ ] aggregate classes with default non-static member initializers.

### Library

- [x] [`std::make_unique`](#/make_unique)
- [x] `std::shared_timed_mutex` and [`std::shared_lock`](#/shared_lock)
- [ ] `std::integer_sequence`
- [ ] `std::exchange`
- [ ] `std::quoted`
- [ ] two-range overloads for some algorithms
- [ ] type alias versions of type traits
- [x] user-defined literals for [`basic_string`](#/string_literals), [`duration`](#/duration_literals) and [`complex`](#/complex_literals)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="cpp17" -->

## C++17

<div class="split index">

### Language

- [ ] fold-expressions
- [ ] class template argument deduction
- [ ] non-type template parameters declared with auto
- [ ] compile-time `if constexpr`
- [ ] inline variables
- [ ] structured bindings
- [ ] initializers for if and switch
- [ ] u8 character literal
- [ ] simplified nested namespaces
- [ ] using-declaration declaring multiple names
- [ ] made `noexcept` part of type system
- [ ] new order of evaluation rules
- [ ] guaranteed copy elision
- [ ] lambda capture of `*this`
- [ ] `constexpr` lambda
- [ ] attribute namespaces don't have to repeat
- [ ] new attributes:
  - [ ] `[[fallthrough]]`
  - [ ] `[[nodiscard]]`
  - [ ] `[[maybe_unused]]`
- [ ] __has_include

</div>

</script></section><section data-markdown><script type="text/template">
## C++17

<div class="split index">

### Library

- [ ] `tuple`:
  - [ ] `apply`
  - [ ] deduction guides
  - [ ] `make_from_tuple`
- [ ] `variant`
- [ ] `launder`
- [ ] `to_chars`/`from_chars`
- [ ] `as_const`
- [ ] searchers
- [ ] `optional`
- [ ] `any`
- [ ] `not_fn`
- [ ] uninitialized memory
  - [ ] `destroy_at`
  - [ ] `destroy`
  - [ ] `destroy_n`
  - [ ] `uninitialized_move`
  - [ ] `uninitialized_value_construct`
- [ ] `weak_from_this`
- [ ] polymorphic allocators
- [ ] `aligned_alloc`
- [ ] transparent `owner_less`
- [ ] array support for `shared_ptr`
- [ ] allocation functions with explicit alignment
- [ ] `byte`
- [ ] [`conjunction`](#/conjunction)/`disjunction`/`negation`
- [ ] type trait variable templates (xxx_v)
- [ ] `is_swappable`
- [ ] `is_invocable`
- [ ] `is_aggregate`
- [ ] `has_unique_object_representations`
- [ ] `clamp`
- [ ] execution policies
- [ ] `reduce`
- [ ] `inclusive_scan`
- [ ] `exclusive_scan`
- [ ] `map`/`set` extract and merge
- [ ] `map`/`unordered_map` `try_emplace` and `insert_or_assign`
- [ ] contiguous iterators
- [ ] non-member `size`/`empty`/`data`
- [ ] mathematical special functions
- [ ] `gcd`
- [ ] `lcm`
- [ ] 3D `hypot`
- [x] [`is_always_lock_free`](#/is_always_lock_free)
- [x] variadic [`lock_guard`](#/scoped_lock)
- [ ] cache line interface
- [ ] `uncaught_exceptions`
- [ ] `timespec_get`
- [x] [rounding functions](#/chrono_rounding) for `duration` and `time_point`

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="cpp20" -->

## C++20

<div class="split index">

### Language

- [ ] Feature test macros
- [ ] 3-way comparison `operator<=>` and `operator==() = default`
- [ ] designated initializers
- [ ] init-statements and initializers in range-for
- [x] [char8_t](#/utf_chars)
- [ ] new attributes
  - [ ] `[[no_unique_address]]`
  - [ ] `[[likely]]`
  - [ ] `[[unlikely]]`
- [ ] pack-expansions in lambda captures
- [ ] removed the requirement to use typename to disambiguate types in many contexts
- [ ] `consteval`, `constinit`
- [ ] further relaxed `constexpr`
- [ ] signed integers are 2's complement
- [ ] aggregate initialization using parentheses
- [ ] Coroutines
- [ ] Modules
- [ ] Constraints and concepts
- [ ] Abbreviated function templates
- [ ] DR: array new can deduce array size

</div>

</script></section><section data-markdown><script type="text/template">
## C++20

<div class="split index">

### Library

- [ ] Formatting library
- [ ] Calendar and Time Zone library
- [ ] `std::source_location`
- [ ] `std::span`
- [ ] `std::endian`
- [ ] array support for `std::make_shared`
- [ ] `std::remove_cvref`
- [ ] `std::to_address`
- [ ] floating point and `shared_ptr` atomics
- [ ] `std::barrier`, `std::latch`, and `std::counting_semaphore`
- [ ] `std::jthread` and thread cancellation classes
- [ ] `<version>`
- [ ] `std::osyncstream`
- [ ] `std::u8string` and other `char8_t` uses
- [ ] `constexpr` for `<algorithm>`, `<utility>`, `<complex>`
- [ ] `std::string::starts_with` / `ends_with` and `std::string_view::starts_with` / `ends_with`
- [ ] `std::assume_aligned`
- [ ] `std::bind_front`
- [ ] `std::c8rtomb`/`std::mbrtoc8`
- [ ] `std::make_obj_using_allocator` etc
- [ ] `std::make_shared_for_overwrite` / `std::make_unique_for_overwrite`
- [ ] heterogeneous lookup in unordered associative containers
- [ ] `std::polymoprhic_allocator` with additional member functions and `std::byte` as its default template argument
- [ ] `std::execution::unseq`
- [ ] `std::midpoint` and `std::lerp`
- [ ] `std::ssize`
- [ ] `std::is_bounded_array`, `std::is_unbounded_array`
- [ ] Ranges
- [ ] uniform container erasure (`std::erase`/`std::erase_if`)
- [ ] Mathematical constants

</div>

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="01_auto/schmeichel.jpg" -->

</script></section><section data-markdown><script type="text/template">
## What problems can you find in this code?

```cpp
///fails=conversion from 'int' to non-scalar type 'std::vector<int>' requested
///hide
#include <string>
#include <vector>

void foo() {
///unhide
// (a)
int i;

// (b)
std::vector<std::string> v;
int size = v.size();

// (c)
std::vector<int> v1(5);
std::vector<int> v2 = 5;
///hide
}
```

<aside class="notes"><ul>
<li>uninitialized variable</li>
<li>possible data lose converting from <code>size_t</code> to <code>int</code></li>
<li>although looking similar, the second line does not compile, because the constructor is <em>explicit</em></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///fails=conversion from '__normal_iterator<const int*,[...]>' to non-scalar type '__normal_iterator<int*,[...]>' requested
///hide
#include <vector>
///unhide
void traverser( const std::vector<int>& v ) {
  for( std::vector<int>::iterator i = v.begin(); 
       i != v.end(); 
       ++i )
  {
        // ...
  }
}
```

<aside class="notes"><ul>
<li>this code does not compile because we need a <code>const_iterator</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};
///unhide
gadget get_gadget();
///hide
gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

<small> assuming `gadget` is implicitly convertible to `widget` </small>

<aside class="notes"><ul>
<li>a temporary <code>getget</code> is created which might be a performance pitfall, as the creation of the temporary object is not at all obvious from reading the call site alone.</li>
<li>it&#39;s possible that using <code>gadget</code> is just as well as viable in this code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="begin_end" class="aside" -->

## Non member `begin` and `end`

Accept anything with a member `begin` and `end` as well as C-style arrays

```cpp
///hide
#include <vector>
#include <cassert>
 
int main() 
{
///unhide
std::vector<int> v = { 3, 1, 4 };
auto vi = std::begin(v);
assert(*vi == 3);

int a[] = { -5, 10, 15 };
auto ai = std::begin(a);
assert(*ai == -5);
///hide
}
```

<aside class="notes"><ul>
<li>prefer to use this in generic code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
What does this function do?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void some_function( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><ul>
<li><code>append_unique</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="01_auto/auto.gif" -->

# auto
<!-- .element: class="chapter" -->

<div class="footnote" style="text-shadow:-1px 0 black, 0 1px black, 1px 0 black, 0 -1px black">

Slides are based on [Herb Sutter's](https://herbsutter.com) GOTW series

</div>

<aside class="notes"><ul>
<li>our main topic today</li>
<li>oldest feature in C++11 (first implementation at 1983)</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="auto" -->

## declaring a local variable

syntax

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto my_new_variable = its_initial_value;
///hide
}
```

deduce type from initializing expression

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto x = 0x12345678ULL; // type of x is unsigned long long
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## similar to template type deduction
```cpp
template<class T> void f( T ) { }

///hide
int main() {
///unhide
int val = 0;

f( val );     // deduces T == int, calls f<int>( val )

auto x = val; // deduces T == int, x is of type int
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Strips off qualifiers and references
```cpp
///hide
int main() {
///unhide
int           val = 0;

int&          ir  = val;
auto          e   = ir;   // The type of e is int

const int     ci  = val;
auto          h   = ci;   // The type of h is int

const int*    cip = &val;
auto          i   = cip;  // The type of i is const int*

int* const    ipc = &val;
auto          j   = ipc;  // The type of j is int*
///hide
}
```

<aside class="notes"><p>You want your new variable to be just like some existing variable or expression over there, and be initialized from it, but that only means that you want the same basic type, not necessarily that other variable’s own personal secondary attributes such as top-level const– or volatile-ness and &amp;/&amp;&amp; reference-ness which are per-variable. For example, just because he’s const doesn’t mean you’re const, and vice versa.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Can be qualified

```cpp
///hide
int main() {
///unhide
int         val = 0;
auto        a   = val; // The type of a is int
auto&       b   = val; // The type of b is int&
const auto  c   = val; // The type of c is const int
const auto& d   = val; // The type of d is const int&
///hide
}
```

<aside class="notes"><p>If needed, <code>const</code> and <code>&amp;</code> can be explicity added</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="01_auto/whats_init.gif" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## Forces initialization

instead of

```cpp
///hide
int main() {
///unhide
int i;
///hide
}
```

write

```cpp
///hide
int main() {
///unhide
auto i = 42;    // guaranteed to be initialized
///hide
}
```

<aside class="notes"><p>solving the first problem</p>
</aside></script></section><section data-markdown><script type="text/template">
## Avoid narrowing conversions

instead of

```cpp
///hide
#include <string>
#include <vector>

int main() {
///unhide
std::vector<std::string> v;
int size = v.size();
///hide
}
```

write

```cpp
///hide
#include <string>
#include <vector>

int main() {
std::vector<std::string> v;
///unhide
auto size = v.size(); // exact type, no narrowing
///hide
}
```

<aside class="notes"><p>solving narrowing conversions</p>
</aside></script></section><section data-markdown><script type="text/template">
## DRY initialization syntax

instead of

```cpp
///hide
#include <vector>

int main() {
///unhide
std::vector<int> v2 = std::vector<int>(5);
///hide
}
```

write

```cpp
///hide
#include <vector>

int main() {
///unhide
auto v2 = std::vector<int>(5); // keep it DRY
///hide
}
```

<aside class="notes"><p>if one wants to use explicit constructor with the assignment syntax they would have to repeat the type but not with auto</p>
</aside></script></section><section data-markdown><script type="text/template">
## Correct type by default

instead of

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
std::vector<int>::const_iterator i = v.begin();
///hide
}
```

write

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
auto i = begin(v);
///hide
}
```

<aside class="notes"><ul>
<li>correct and clear and simpler</li>
<li>stays correct if we change the type of the parameter to be non-const</li>
<li>or even replace vector with some other type of container</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Avoids hidden temporaries

instead of

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

write

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = get_gadget(); // gadget can be used
///hide
}
```

or

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = widget(get_gadget()); // widget is needed
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="static_assert" class="aside" -->

## `static_assert`

Check assertions at compile time:
```cpp
///hide
constexpr auto bool_constexpr = true;
#define message "should never appear"
///unhide
static_assert ( bool_constexpr , message );
```

For example:
```cpp
static_assert(sizeof(void *) == 8, 
  "Only 64-bit code generation is supported.");
```

<aside class="notes"><ul>
<li>If you only support 64 bit you can give a compile time error if anyone tries to use you code to compile for other architectures</li>
<li>Open CE</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="decltype" class="aside" -->

## `decltype`

Similar to `sizeof(expr)` but returns type instead of size.

```cpp
#include <type_traits>

int f();

static_assert(sizeof(f()) == sizeof(int), 
  "f should return int");
static_assert(std::is_same<int, decltype(f())>::value, 
  "f should return int");
```

</script></section><section data-markdown><script type="text/template">
## what should be the return type

```cpp
///hide
#include <iostream>
#define RETURN_TYPE auto

///unhide
template <typename Func, typename T>
RETURN_TYPE trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we implement a generic tracing function which gets a function <code>f</code> and a value <code>t</code> and returns the result of <code>f(t)</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## what should be the return type

first try

```cpp
///fails='t' was not declared in this scope
///hide
#include <iostream>

///unhide
template <typename Func, typename T>
decltype(f(t)) trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><ul>
<li>open CE</li>
<li>to express the return type we need to refer to <code>f</code> and <code>t</code> which are unknown to the compiler at the point of defining the return type.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="trailing_return" -->

## trailing return type

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) -> decltype(f(t)) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we replace the return type with <code>auto</code> and add the actual return type after the arrow.
At this point we can refer to <code>f</code> and <code>t</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="auto_return" -->

## `auto` return type (C++14)

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>in c++14, this idiom was shortened to mean deduce the return type from the return statement</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="concerned.gif" -->

# CONCERNED?
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue" -->

<aside class="notes"><ul>
<li>There are number of popular concerns about using auto.</li>
<li>Let&#39;s tackle some of them.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
> writing auto to declare a variable is primarily about saving typing.

</script></section><section data-markdown><script type="text/template">
Writing auto is about

- [x] correctness <!-- .element: class="fragment" -->
- [x] performance <!-- .element: class="fragment" -->
- [x] maintainability <!-- .element: class="fragment" -->
- [x] robustness <!-- .element: class="fragment" -->
- [x] convenience <!-- .element: class="fragment" -->

<aside class="notes"><p>No, writing auto is about</p>
<ul>
<li>correctness</li>
<li>performance</li>
<li>maintainability</li>
<li>robustness</li>
<li>AND FINALLY, ALSO</li>
<li>convenience</li>
</ul>
<p>Next...</p>
</aside></script></section><section data-markdown><script type="text/template">
> But in some cases I do want to commit to a specific type, not automatically deduce it, so I can’t use auto.

</script></section><section data-markdown><script type="text/template">
Use

```cpp
///hide
template<typename type>
void foo(type init) {
///unhide
auto x = type(init);
///hide
}
```

<aside class="notes"><p>WRONG!</p>
</aside></script></section><section data-markdown><script type="text/template">
> My code gets unreadable quickly when I don’t know what exact type my variable is without hunting around to see what that function or expression returns, so I can’t just use auto all the time.

</script></section><section data-markdown><script type="text/template">
How many concrete types are in this function?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void append_unique( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><p>the lack of exact types makes it much more powerful and doesn’t significantly harm its readability</p>
</aside></script></section><section data-markdown><script type="text/template">
## write code against interfaces, not implementations

- <!-- .element: class="fragment" -->  Functions - hiding code
- <!-- .element: class="fragment" -->  OO - hiding code and data
- <!-- .element: class="fragment" --> Polymorphism - hiding type

<aside class="notes"><ul>
<li>we write functions to hide implmenetation code</li>
<li>we write class to hide private members and methods</li>
<li>we use static (templates) and dynamic (virtual methods) polymorphism to write generic code</li>
<li>using <code>auto</code> is another link in this software development chain</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Using `auto`

- <!-- .element: class="fragment" --> guarantees the variable will be initialized
- <!-- .element: class="fragment" --> efficient by default
- <!-- .element: class="fragment" --> guarantees that you will use the correct exact type
- <!-- .element: class="fragment" --> guarantees that you will continue to use the correct exact type
- <!-- .element: class="fragment" --> is the only good option for hard-to-spell and impossible-to-spell types
- <!-- .element: class="fragment" --> is just generally simpler and less typing

</script></section><section data-markdown><script type="text/template">
# Thank you

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="02_move/neville.jpg" -->

</script></section><section data-markdown><script type="text/template">
## How many copies?

```cpp
///hide
#include <vector>
#include <cstdint>

///unhide
template<typename Buffer>
std::vector<Buffer> generateBuffers(const size_t INSTANCES, 
                                    const size_t BUFFER_SIZE)
{
    std::vector<Buffer> v;
    for (size_t i = 0; i < INSTANCES; ++i)
    {
        v.push_back(Buffer(BUFFER_SIZE));
    }
    return v;
}
```

<aside class="notes"><ul>
<li>copying from temporary buffer</li>
<li>copying when capacity is full</li>
<li>possible copying when returning <code>v</code></li>
<li>in all theses cases the source is destroyed immediately after copying</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Member initialization

```cpp [|4-6|6]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D {};
int f(D);
///unhide
class A
{
public:
    A() : a(7), b(5), hash_algorithm("MD5"), s("Constructor run") {}
    A(int a_val) : a(a_val), b(5), hash_algorithm("MD5"), s("Constructor run") {}
    A(D d) : a(f(d)), b(a), hash_algorithm("MD5"), s("Constroctor run") {}
private:
    int a, b;
    HashingFunction hash_algorithm;
    std::string s;
};
```

<!-- .element: style="font-size:0.4em;" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Non-static data member initializers

```cpp [|8-10|4-6]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D {};
int f(D);
///unhide
class A
{
public:
    A() {}
    A(int a_val) : a(a_val) {}
    A(D d) : a(f(d)), b(a) {}
private:
    int a = 7, b = 5;
    HashingFunction hash_algorithm = HashingFunction("MD5");
    std::string s = "Constructor run";
};
```

<!-- .element: style="font-size: 0.5em" -->

<aside class="notes"><p><code>auto</code> is not allowed even with initializer;</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="delegating_constructors" class="aside" -->

## Delegating constructors

```cpp [|4-9|10]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D {};
int f(D);
///unhide
class A
{
public:
    A(int _a = 7, 
      int _b = 5, 
      const HashingFunction& _hash_algorithm = HashingFunction("MD5"), 
      const std::string& _s = "Constructor run") 
    : a(_a), b(_b), hash_algorithm(_hash_algorithm), s(_s) 
    {}
    A(D d) : A(f(d), a) {}
private:
    int a, b;
    HashingFunction hash_algorithm;
    std::string s;
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="nullptr" class="aside" -->

## `nullptr`

A type safe replacement for `NULL` macro

```cpp
///external
///compiler=vcpp_v19_24_x64
///options=/O2
///hide
#include <cstddef>
///unhide
void foo(int);
void foo(char*);

///hide
int main(){
///unhide
foo(42); // calls foo(int);
foo(NULL); // calls foo(int);
foo(nullptr); // calls foo(char*);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Buffer copy

```cpp [|2-3|5-10|12-18|20-29|31]
///hide
#include <algorithm>
///unhide
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }

    Buffer& operator=(const Buffer& other) 
    {
        delete[] m_pArray;
        m_size = other.m_size;
        m_pArray = new int[m_size];
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};






```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## implement assignment by copy constructor

```cpp [20-26]
///hide
#include <algorithm>
///unhide
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
    
    Buffer& operator=(const Buffer& other) 
    {
        Buffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};








```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## Steal from temporary

```cpp
///hide
#include <cstddef>
struct Buffer {
size_t m_size;
int* m_pArray;

Buffer(size_t size = 0) 
    : m_size(size)
    , m_pArray(size == 0 
                ? nullptr 
                : new int[size])
{}
///unhide
Buffer(const Buffer& temporary)
    : m_size(temporary.m_size)
    , m_pArray(temporary.m_pArray)
{}
///hide
~Buffer() { delete[] m_pArray; }
};
```

<aside class="notes"><ul>
<li>As we know the temporary won’t be used after the assignment operator, why not “move” its resources to the new object instead of copy them?</li>
<li>There&#39;s a problem with this code though - double delete</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Without double delete

```cpp
///hide
#include <cstddef>
struct Buffer {
size_t m_size;
int* m_pArray;

Buffer(size_t size = 0) 
    : m_size(size)
    , m_pArray(size == 0 
                ? nullptr 
                : new int[size])
{}
///unhide
Buffer(Buffer& temporary)
    : m_size(temporary.m_size)
    , m_pArray(temporary.m_pArray)
{
    temporary.m_size = 0;
    temporary.m_pArray = nullptr;
}
///hide
~Buffer() { delete[] m_pArray; }
};
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="02_move/move_it.gif" data-background-size="contain" data-transition="none slide" -->

# Move semantics
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 8%" -->

</script></section><section data-markdown><script type="text/template">
## How can we tell?

```cpp
///hide
#include <algorithm>

struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}
    Buffer(const Buffer& other)
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                    other.m_pArray + m_size, 
                    m_pArray);
    }
    ~Buffer() { delete[] m_pArray; }
};

int main() {
const auto BUFFER_SIZE = 4;
///unhide
Buffer c = Buffer(BUFFER_SIZE); // can move
Buffer d = c; // cannot move
// keep using c and d
///hide
}
```

<aside class="notes"><p>We need a way to distinguish between references to temporary objects and regular objects.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Value type

Originally:

> - l-value: can be on the left hand side of an assignment
> - r-value: can be **only** on the right hand side of an assignment

</script></section><section data-markdown><script type="text/template">
## Left or right?

```cpp [|4|5|6|7|8|9]
///hide
#include <vector>
#include <algorithm>

using std::min;

int main() {
///unhide
int a, b, *p;
std::vector<int> v(2);

a         = 42;
b         = a;
b         = a * b;
p         = new int;
*p        = min(a, b);
v.front() = 6;
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Value type

More accurately: 

> an expression is an *l*-value if it has a specific memory location and its address can be taken using the & operator, otherwise it is an *r*-value.

</script></section><section data-markdown><script type="text/template">
## Value type

```cpp
///fails=lvalue required as unary '&' operand
///hide
void foo() {
///unhide
int a, b;
int* c;
c = &a;
c = &(a * b); // error
///hide
}
```

All expressions returning temporary values are r-values.

All named objects are l-values.

</script></section><section data-markdown><script type="text/template">
## L-value references

A (non-const) reference can be bound only to l-values:

```cpp
///fails=cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'
int a, b;
int& c = a;
int& d = (a * b); // error
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="rvalue_references" -->

## R-value references

Can be bound only to r-values and uses the && syntax.

```cpp
///fails=cannot bind rvalue reference of type 'int&&' to lvalue of type 'int'
int a = 1, b = 2;
int&& c = a; // error
int&& d = (a * b);
cout << ++d << endl;
```

<aside class="notes"><p><code>d</code> is extending the lifetime of <code>(a * b)</code></p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="move_constructors" -->

## Move constructor and assignment operator

```cpp [|3-11,22-24|13-20|26-33]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 

    // move constructor
    MovableBuffer(MovableBuffer&& other)
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(MovableBuffer&& other)
    {
        MovableBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};








```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/ryKzdF90wADpRQ6hHuvUvhat1Z0)

</script></section><section data-markdown><script type="text/template">
## Move only

```cpp [|20]
///fails=use of deleted function 'constexpr MoveOnlyBuffer::MoveOnlyBuffer(const MoveOnlyBuffer&)'
///hide
#include <cstddef>
#include <utility>

///unhide
struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

    MoveOnlyBuffer& operator=(MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};








```

<!-- .element: class="split" -->

<aside class="notes"><ul>
<li>show compiler error</li>
<li>performance bug in the movable class</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## `std::move`

casts the argument to an `rvalue`

```cpp
///hide
#include <type_traits>
///unhide
namespace std {

template< class T >
typename remove_reference<T>::type&& move( T&& t ) noexcept {
    return static_cast<typename remove_reference<T>::type&&>(t);
}

} // namespace std
```

<!-- .element: style="font-size: 0.5em;" -->

</script></section><section data-markdown><script type="text/template">
## (really) move only

```cpp [20]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

    MoveOnlyBuffer& operator=(MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};








```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/mevho4kNsJTPbnA7S8zrFToi5Is)

</script></section><section data-markdown><script type="text/template">
## Exception safety

<table style="font-size:0.55em">
    <tr>
        <td>Nothrow exception guarantee</td> <td>the function never throws exceptions</td>
    </tr>
    <tr>
        <td>Strong exception guarantee</td> <td>If the function throws an exception, the state of the program is rolled back to the state just before the function call</td>
    </tr>
    <tr>
        <td>Basic exception guarantee</td> <td>If the function throws an exception, the program is in a valid state. No resources are leaked, and all objects' invariants are intact</td>
    </tr>
    <tr>
        <td>No exception guarantee</td> <td><img src="02_move/dragons.jpg" alt="dragons" style="position: relative; height: 20%; left: 30%"></img></td>
    </tr>
</table>

</script></section><section data-markdown><script type="text/template">
`vector::push_back` pseudo code

```cpp
///fails=expected initializer before '<' token
template<typename T>
void vector<T>::push_back(const T& value) {
    if (size == capacity) {
        allocate larger buffer
        if (is movable) {
            // move all Ts to the new buffer
        } else {
            // copy all Ts to the new buffer
        }
    }
    // copy value to the end if the buffer
}
```

</script></section><section data-markdown><script type="text/template">
## copy

<svg class="animated" width="80%" xmlns="http://www.w3.org/2000/svg">
    <defs>
          <pattern id="empty" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#ffffff" stroke= "#333333" stroke-width="2" />
          </pattern>
          <pattern id="full" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#876fc1" stroke= "#333333" stroke-width="2" />
          </pattern>
    </defs>
    <text x="2" y="35" fill="white">Old</text>
    <rect x="122" y="2" width="400" height="40" fill="url(#full)" />
    <text class="error" x="322" y="75" fill="red" style="opacity: 0">
        ERROR
    </text>
    <g class="new">
        <text x="2" y="115" fill="white">New</text>
        <rect x="122" y="82" width="600" height="40" fill="url(#empty)" />
        <rect class="filling" x="122" y="82" width="200" height="40" fill="url(#full)" />
    </g>
</svg>

</script></section><section data-markdown><script type="text/template">
## move

<svg class="animated" width="80%" xmlns="http://www.w3.org/2000/svg">
    <defs>
          <pattern id="empty" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#ffffff" stroke= "#333333" stroke-width="2" />
          </pattern>
          <pattern id="full" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#876fc1" stroke= "#333333" stroke-width="2" />
          </pattern>
    </defs>
    <text x="2" y="35" fill="white">Old</text>
    <rect x="122" y="2" width="400" height="40" fill="url(#full)" />
    <rect class="filling" x="122" y="2" width="200" height="40" fill="url(#empty)" />
    <text class="error" x="322" y="75" fill="red" style="opacity: 0">
        ERROR
    </text>
    <g class="new">
        <text x="2" y="115" fill="white">New</text>
        <rect x="122" y="82" width="600" height="40" fill="url(#empty)" />
        <rect class="filling" x="122" y="82" width="200" height="40" fill="url(#full)" />
    </g>
</svg>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="noexcept_specifier" -->

## `noexcept` specifier

A function can be decorated with `noexcept(expr)` specifier to indicate whether it will throw:

```cpp
int* allocate_array_impl(int N){
    return new int[N];
}

template<int N>
int* allocate_array() noexcept(N >= 0) {
    return allocate_array_impl(N);
}

int* a = allocate_array<42>();
int* b = allocate_array<-1>();
```

`noexcept` is a shortcut for `noexcept(true)`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="noexcept_operator" -->

## `noexcept` operator

`noexcept(expr)` returns `true` if `expr` is declared to not throw any exceptions.

```cpp
template<typename Func>
void wrapper(Func func) noexcept(noexcept(func())) {
    func();
}
```

</script></section><section data-markdown><script type="text/template">
- destructors are implicitly `noexcept`
- if a `noexcept` function throws, the function `std::terminate` is called 

```cpp
extern void f();  // potentially-throwing
void g() noexcept {
    f();      // valid, even if f throws
    throw 42; // valid, effectively a call to std::terminate
}
```

</script></section><section data-markdown><script type="text/template">
## `noexcept` move

```cpp [14, 27-28]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 

    // move constructor
    MovableBuffer(MovableBuffer&& other) noexcept
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other) noexcept
    {
        MovableBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};






```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/Po3o1F2MuAsyRNciCaOoAcnQbyY)

</script></section><section data-markdown><script type="text/template">
## `std::move` again

```cpp
///hide
#include <type_traits>
///unhide
template< class T >
typename std::remove_reference<T>::type&& move( T&& t ) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

<!-- .element: style="font-size: 0.48em;" -->

We can also move `lvalue`s that are not needed anymore:

```cpp
///hide
#include <string>
#include <vector>
#include <iostream>

void foo() {
///unhide
std::vector<std::string> inputs;
for (std::string s; std::cin >> s;) {
    inputs.push_back(std::move(s));
}
///hide
}
```

<aside class="notes"><p>But <code>s</code> is an <code>lvalue</code>!!</p>
</aside></script></section><section data-markdown><script type="text/template">
## reference collapsing

```cpp
///hide
#include <type_traits>

///unhide
template<typename T>
using lref = T&;

template<typename T>
using rref = T&&;

static_assert(std::is_same<lref<lref<int>>, int&>::value, 
              "& * & = &");
static_assert(std::is_same<lref<rref<int>>, int&>::value, 
              "& * && = &");
static_assert(std::is_same<rref<lref<int>>, int&>::value, 
              "&& * & = &");
static_assert(std::is_same<rref<rref<int>>, int&&>::value, 
              "&& * && = &&");
```

</script></section><section data-markdown><script type="text/template">
## forwarding ref

calling `std::move(s)` instantiates 

```cpp
///fails='move' in namespace 'std' does not name a template type
std::move<std::string&>(std::string & && t)
```

i.e. 

```cpp
///fails='move' in namespace 'std' does not name a template type
std::move<std::string&>(std::string & t)
```

- `template<typename T>(T&&)` just retains the type of the call site argument
- such a reference is called a **forwarding reference**

</script></section><section data-markdown><script type="text/template">
## `std::forward`

forwards the argument to another function with the value category it had when passed to the calling function.

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func&& f, T&& t) { 
  std::cout << "Calling f on " << t;
  return f(std::forward<T>(t)); 
}
```

</script></section><section data-markdown><script type="text/template">
## Special member functions

| | | |
|-|-|-|
|1.|default constructor|`T()`|
|2.|copy constructor|`T(const T&)`|
|3.|move constructor|`T(T&&)`|
|4.|destructor|`~T()`|
|5.|copy assignment|`T& operator=(const T&)`|
|6.|move assignment|`T& operator=(T&&)`|

<!-- .element: class="noheader noborder" style="font-size: 35px" -->

**Special** - compiler generated, under certain circumstances

</script></section><section data-markdown><script type="text/template">
![special members](02_move/special_members.jpg) <!-- .element: width="75%" -->

Source: [Howard Hinnant](https://howardhinnant.github.io/classdecl.html)

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="deleted" -->

## deleted function

e.g. to prevent narrowing conversions:

```cpp
///fails=use of deleted function 'void foo(int)'
void foo(short i);
void foo(int i) = delete;

///hide
void bar() {
///unhide
foo(static_cast<short>(42));    // ok
foo(42);                        // error, deleted function
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="defaulted" -->

## defaulted special member function

can force the compiler to generate

```cpp
///hide
#include <type_traits>

///unhide
struct T {
    T() = default;
    T(int i);

    T(T&&);
    T(const T&) = default;
};

static_assert(std::is_default_constructible<T>::value, 
              "default");
static_assert(std::is_copy_constructible<T>::value, 
              "copy");
```

</script></section><section data-markdown><script type="text/template">
## rule of 0

> If you can avoid defining default operations, do

</script></section><section data-markdown><script type="text/template">
## rule of 5(6)

> If you define or =delete any default operation, define or =delete them all

</script></section><section data-markdown><script type="text/template">
## class prototypes:

<div class="r-stack r-stretch">

```cpp
class normal
{
public:
    // rule of zero
};
```

```cpp
class container
{
public:
    container() noexcept;
    ~container() noexcept;

    container(const container& other);
    container(container&& other) noexcept;

    container& operator=(const container& other);
    container& operator=(container&& other) noexcept;
};
```

<!-- .element: class="fragment current-visible" -->

```cpp
class resource_handle
{
public:
    resource_handle() noexcept;
    ~resource_handle() noexcept;

    resource_handle(resource_handle&& other) noexcept;
    resource_handle& operator=(resource_handle&& other) noexcept;

    resource_handle(const resource_handle&) = delete;
    resource_handle& operator=(const resource_handle&) = delete;
};
```

<!-- .element: class="fragment current-visible" style="font-size:0.5em" -->

```cpp
class immoveable
{
public:
    immoveable() noexcept;
    ~immoveable() noexcept;

    immoveable(const immoveable&) = delete; 
    immoveable& operator=(const immoveable&) = delete;

    immoveable(immoveable&&) = delete;
    immoveable& operator=(immoveable&&) = delete;
};
```

<!-- .element: class="fragment current-visible" -->

</div>

Source: [Jonathan Müller](https://foonathan.net/2019/02/special-member-functions/)

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="02_move/roar.gif" data-transition="none slide" -->

# Thank you
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 20%" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="03_initialization/irwin.jpeg" -->

</script></section><section data-markdown><script type="text/template">
Take a look at the following code:


```cpp [|4-6,8-10|1,22-27|8,16,20-21]
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};

int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}







```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## Most vexing parse

```cpp
///hide
struct C{};
struct D{};
struct POD{};
///unhide
C c();            // c: () => C
D d(C(), POD());  // d: (() => C, () => POD) => D
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///hide
int v = 7;
typedef int X;
///unhide
X t1 = v;     // copy initialization
X t2(v);      // direct initialization
X t3 = { v }; // initialize using initializer list
X t4 = X(v);  // make an X from v and copy it to t4
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
int v = 7;
typedef int X;
X t1 = v;     // ok
X t2(v);      // ok
X t3 = { v }; // ok
X t4 = X(v);  // ok
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///fails=conversion from 'int' to non-scalar type 'X' requested
int v = 7;
typedef struct { int x; int y; } X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // ok: X is an aggregate
X t4 = X(v);  // error: we can’t cast an int to a struct
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///fails=conversion from 'int' to non-scalar type 'X' {aka 'std::vector<int>'} requested
///hide
#include <vector>
///unhide
int v = 7;
typedef std::vector<int> X;
X t1 = v;     // error: constructor is explicit
X t2(v);      // ok
X t3 = { v }; // error: not an aggregate
X t4 = X(v);  // ok (make an X from v and copy it to t4)
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///fails=invalid conversion from 'int' to 'X' {aka 'int*'}
int v = 7;
typedef int* X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // error
X t4 = X(v);  // ok: unfortunately converts int to an int*
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## More initialization

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X(42);                      // create a temporary
///hide
}
///unhide
X f(int v) { return v; }    // return a value
///hide
void f2() {
///unhide
void g(X); g(v);            // pass an argument
new X(v);                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X(v), m(v) {}  // base and member initializers
///hide
void f3() {
///unhide
throw v;                    // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="list_initialization" data-background-image="03_initialization/list.gif" -->

# List Initialization

<!-- .element: class="chapter" -->

<div class="footnote" style="text-shadow: 3px 3px black; color: lightblue">

Sources:

- [simplify C++](https://arne-mertz.de/2015/07/new-c-features-uniform-initialization-and-initializer_list/)
- [N2215](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf)

<div>

</script></section><section data-markdown><script type="text/template">
## Initialize (almost) anything with `{}`

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X{42};                      // create a temporary
///hide
}
///unhide
X f(int v) { return {v}; }  // return a value
///hide
void f2() {
///unhide
void g(X); g({v});          // pass an argument
new X{v};                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X{v}, m{v} {}  // base and member initializers
```

This is still forbidden:

```cpp
///fails=expected primary-expression before '{' token
///hide
void f3() {
int v = 42;
///unhide
throw {v};                  // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
# It's also safer

```cpp
///fails=narrowing conversion
int i1(4.2); // no problem
int i2{4.2}; // error: narrowing conversion

double d;
float f1(d); // no problem
float f2{d}; // error: narrowing conversion

float f3(i1); // no problem
float f4{i1}; // error: narrowing conversion

unsigned int ui1(-1); // no problem
unsigned int ui2{-1}; // error: narrowing conversion
```

</script></section><section data-markdown><script type="text/template">
## Now, with list initialization

```cpp [8,17-20]
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : p{2, 22.34}, iarr{0, 1, 2}, d{3.14} {}
};

class D {
public:
  D(C const&, POD const&) {}
};

int main() {
  C c{}; 
  D d{C(), POD()};
  POD* pp = new POD{4, 22.1};
  float* pf = new float[2]{1.2f, 2.3f};
}








```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## Creating an array

```cpp
///options=-std=c++03
///hide
#include <string>

int main(){
///unhide
std::string days[] = { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Creating a vector

```cpp
///options=-std=c++03
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days;
days.reserve(7);

days.push_back("Sunday"); 
days.push_back("Monday"); 
days.push_back("Tuesday"); 
days.push_back("Wednesday"); 
days.push_back("Thursday"); 
days.push_back("Friday"); 
days.push_back("Saturday");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="initializer_list" -->

### `std::initializer_list<T>`

- A lightweight proxy object that provides access to an array of objects of type const T.
- Custructed automatically by the compiler when 
  - calling a constructor/function accepting `std::initializer_list`
  - binding a `braced-init-list` to auto

</script></section><section data-markdown><script type="text/template">
## Example

```cpp [|4,16|10,17]
///hide
#include <vector>
#include <iostream>
///unhide
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};

int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}








```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## and

```cpp
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## or even

```cpp
///hide
#include <map>
#include <string>

int main() {
std::string s1;
///unhide
std::map<int, std::string> m = {
        {1, "a"},
        {2, {'a', 'b', 'c'} },
        {3, s1}
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## `initializer_list` constructor is prefered

```cpp
///hide
#include <vector>
#include <cassert>

int main() {
///unhide
std::vector<int> aDozenOfFives(12, 5);
std::vector<int> twelveAndFive{12, 5};
assert(aDozenOfFives != twelveAndFive);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="range_for" class="aside" -->

## Range-based for loop

Instead of

```cpp [2-4]
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (auto it = begin(v); it != end(v); ++it) {
    std::cout << *it << ' ';
  }
  std::cout << '\n';
}
```

write

```cpp [2-4]
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (const auto& i: v) {
    std::cout << i << ' ';
  }
  std::cout << '\n';
}
```

</script></section><section data-markdown><script type="text/template">
## with `std::initializer_list`

```cpp
///hide
#include <iostream>
int main(){
///unhide
for (auto x : {-1, -2, -3})
  std::cout << x << ' ';
std::cout << '\n';
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Note

```cpp [7-13]
///hide
#include <initializer_list>
#include <type_traits>

///unhide
template<typename Expected, typename Actual>
void hasType(const Actual &) {
  static_assert(std::is_same<Actual, Expected>::value,
                "should be the same");
}

///hide
int main() {
///unhide
int i1{42};
auto i2{42};
hasType<int>(i2);

int i3 = {42};
auto i4 = {42};
hasType<std::initializer_list<int>>(i4);
///hide
}
```

<aside class="notes"><p>This initialization syntax is frequently referred to as &quot;Uniform initialization&quot;. For these reasons, it is not always advised to use this syntax.</p>
</aside></script></section><section data-markdown><script type="text/template">
## note

a *braced-init-list* does not have a type in itself:

```cpp
///fails=no matching function for call to 'do_sth(<brace-enclosed initializer list>)'
template <typename T>
void do_sth(T t);

///hide
void foo() {
///unhide
do_sth({1, 2, 3, 4, 5}); // error: couldn't infer template argument
///hide
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## note

Does not support moves

<div class="split">

```cpp
///hide
#include <vector>
#include <iostream>

///unhide
struct S {
  S() { std::cout << "default\n"; }
  S(const S&) { std::cout << "copy\n"; }
  S(S&&) { std::cout << "move\n"; }
};

///hide
int main() {
///unhide
std::vector<S> v{S(), S(), S()};
///hide
}
```

```cpp
///fails=use of deleted function 'S::S(const S&)'
///hide
#include <vector>
#include <iostream>

///unhide
struct S {
  S() { std::cout << "default\n"; }
  S(const S&) = delete;
  S(S&&) { std::cout << "move\n"; }
};

///hide
void foo() {
///unhide
std::vector<S> v{S(), S(), S()}; // error
///hide
}
```

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="03_initialization/aladdin_thanks.gif" data-background-size="contain" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/bruce.jpg" -->

</script></section><section data-markdown><script type="text/template">
## from Boost::Thread library

```cpp
///libs=boost:173
///hide
#include <boost/thread/pthread/thread_data.hpp>
#include <boost/thread/detail/is_convertible.hpp>
#include <boost/bind.hpp>
///unhide
namespace boost {

class thread {
///hide
  boost::detail::thread_data_ptr thread_info;
  struct dummy;
  void start_thread();

///unhide
  template <class F,class A1>
  thread(F f,A1 a1,
         typename disable_if<boost::thread_detail::is_convertible<F&,thread_attributes >, dummy* >::type=0):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1)))
  {
      start_thread();
  }
  template <class F,class A1,class A2>
  thread(F f,A1 a1,A2 a2):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3>
  thread(F f,A1 a1,A2 a2,A3 a3):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7,class A8>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7,a8)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7,class A8,class A9>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8,A9 a9):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7,a8,a9)))
  {
      start_thread();
  }
};

} // namespace boost
```

<!-- .element: style="font-size:0.3em" -->

</script></section><section data-markdown><script type="text/template">
## common `printf` bug

```cpp
///compiler=g75
#include <cstdio>
#include <string>

std::string getName() {
  return "Dvir";
}

///hide
int main() {

///unhide
printf("Hello %s", getName());
///hide

}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="variadic_templates" data-background-image="04_variadic/smith.gif" -->

## Variadic templates

<!-- .element: class="chapter bottom"  -->

<div class="footnote">

Sources:
- [N2080](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2080.pdf)
- [cppreference](https://en.cppreference.com/w/cpp/language/parameter_pack)
- [Fluent{C++}](https://www.fluentcpp.com/2019/02/05/how-to-define-a-variadic-number-of-arguments-of-the-same-type-part-3/)

<div>

<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; bottom: 0" -->

</script></section><section data-markdown><script type="text/template">
## variadic type

<div class="r-stack">

```cpp
template<typename... Args> struct count;
```

<div class="fragment highlight bottom" style="background-color:#d7d7d747; height:5em; width:9.5em; top: 1em; left: -8.2em">
parameter pack
</div>

</div>

</script></section><section data-markdown><script type="text/template">
## base specialization

```cpp
///hide
#include <cstddef>
template<typename... Args> struct count;
///unhide
template<>
struct count<> {
  static const size_t value = 0;
};
```

</script></section><section data-markdown><script type="text/template">
## recursive case

<div class="r-stack">

```cpp
///hide
#include <cstddef>
template<typename... Args> struct count;
///unhide
template<typename T, typename... Args>
struct count<T, Args...>
{
  static const size_t value = 1 + count<Args...>::value;
};
```

<div class="fragment highlight bottom" style="background-color:#d7d7d747; height: 5em; width: 4.3em; top: 2.5em; left: 7.2em">
pack expansion
</div>

</div>

</script></section><section data-markdown><script type="text/template">
## check

```cpp [14-15]
///hide
#include <cstddef>
///unhide
template<typename... Args> struct count;

template<>
struct count<> {
  static const size_t value = 0;
};

template<typename T, typename... Args>
struct count<T, Args...>
{
  static const size_t value = 1 + count<Args...>::value;
};

static_assert(count<int, int, double>::value == 3, 
              "3 elements");
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## `sizeof...`

```cpp
///hide
#include <cstddef>

///unhide
template<typename... Args> struct count 
{
  static const size_t value = sizeof...(Args);
};

static_assert(count<int, int, double>::value == 3, 
              "3 elements");
```

<aside class="notes"><p>Args is not expanded</p>
</aside></script></section><section data-markdown><script type="text/template">
## type safe `printf`

<!-- .element data-id="title" -->

```cpp []
///hide
#include <iostream>

///unhide
template<typename T, typename... Args>
void tprintf(const char* format, T value, Args... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

<!-- .element: style="font-size:0.45em" data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## with recursion base

<!-- .element data-id="title" -->

```cpp []
///hide
#include <iostream>

///unhide
void tprintf(const char* format) { std::cout << format; }

template<typename T, typename... Args>
void tprintf(const char* format, T value, Args... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

<!-- .element: style="font-size:0.45em" data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## without copy

<!-- .element data-id="title" -->

```cpp []
///hide
#include <iostream>

///unhide
void tprintf(const char* format) { std::cout << format; }

template<typename T, typename... Args>
void tprintf(const char* format, T value, const Args&... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

<!-- .element: style="font-size:0.45em" data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## compiler generated "recursion"

```cpp
///hide
#include <iostream>

void tprintf(const char* format)
{
    std::cout << format;
}

template<typename T, typename... Args>
void tprintf(const char* format, T value, const Args&... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}

///unhide
int main() {
  tprintf("% world% %\n", "Hello", '!', 123);

  // compiler generates
  // tprintf("% world% %\n", "Hello", '!', 123);
  // tprintf(" world% %\n", '!', 123);
  // tprintf(" %\n", 123);
  // tprintf("\n");
}
```

</script></section><section data-markdown><script type="text/template">
## new `boost::thread`

```cpp
///libs=boost:173
///hide
#include <boost/thread/pthread/thread_data.hpp>
#include <boost/thread/detail/is_convertible.hpp>
#include <boost/bind.hpp>
///unhide
namespace boost {

class thread {
///hide
  boost::detail::thread_data_ptr thread_info;
  struct dummy;
  void start_thread();

///unhide
  template <class F, class Arg, class ...Args>
  thread(F&& f, Arg&& arg, Args&&... args) :
    thread_info(make_thread_info(
      thread_detail::decay_copy(boost::forward<F>(f)),
      thread_detail::decay_copy(boost::forward<Arg>(arg)),
      thread_detail::decay_copy(boost::forward<Args>(args))...)
    )
  {
    start_thread();
  }
};

} // namespace boost
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## more pack expansions

```cpp [1|2|3|4-7|8-9]
///hide
template<typename... Args> void f(Args...);
template<typename... Args> void h(Args...);
template<typename... Args>
void foo(Args... args) {
auto n = 0;
///unhide
f(&args...); // f(&E1, &E2, &E3)
f(n, ++args...); // f(n, ++E1, ++E2, ++E3);
f(++args..., n); // f(++E1, ++E2, ++E3, n);
f(const_cast<const Args*>(&args)...);
// f(const_cast<const E1*>(&X1), 
//   const_cast<const E2*>(&X2), 
//   const_cast<const E3*>(&X3))
f(h(args...) + args...);
// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)
///hide
}
```

<aside class="notes"><p>last is nested</p>
</aside></script></section><section data-markdown><script type="text/template">
## non-type template parameter pack

```cpp
template<typename... Ts, int... N>
void g(Ts (&...arr)[N]) {}

///hide
int main() {
///unhide
int n[1];
g("a", n); // Ts (&...arr)[N] expands to 
           // const char (&)[2], int(&)[1]
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Base specifiers and member initializer lists

```cpp
template<class... Mixins>
class X : public Mixins... {
 public:
    X(const Mixins&... mixins) : Mixins(mixins)... { }
};
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="tuple" -->

## `std::tuple`

a variadic pair

```cpp
template< class... Types >
class tuple;
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## return multiple values

```cpp [|1|3|9-13]
///hide
#include <tuple>
#include <string>
#include <iostream>

///unhide
std::tuple<double, char, std::string> get_student(int id)
{
    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");
    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");
    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");
    throw std::invalid_argument("id");
}

///hide
int main() {
///unhide
auto student0 = get_student(0);
std::cout << "ID: 0, "
          << "GPA: " << std::get<0>(student0) << ", "
          << "grade: " << std::get<1>(student0) << ", "
          << "name: " << std::get<2>(student0) << '\n';
///hide
}
```

<!-- .element: data-id="code" style="font-size:0.44em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::tie`

```cpp [9-16]
///hide
#include <tuple>
#include <string>
#include <iostream>

///unhide
std::tuple<double, char, std::string> get_student(int id)
{
    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");
    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");
    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");
    throw std::invalid_argument("id");
}

///hide
int main() {
///unhide
double gpa1;
char grade1;
std::string name1;
std::tie(gpa1, grade1, name1) = get_student(1);
std::cout << "ID: 1, "
          << "GPA: " << gpa1 << ", "
          << "grade: " << grade1 << ", "
          << "name: " << name1 << '\n';
///hide
}
```

<!-- .element: data-id="code" style="font-size:0.44em" -->

<aside class="notes"><p>creates a tuple of references</p>
</aside></script></section><section data-markdown><script type="text/template">
## `std::ignore`

```cpp [|3]
///hide
#include <iostream>
#include <string>
#include <set>
#include <tuple>
 
int main()
{
///unhide
std::set<std::string> set_of_str;
bool inserted = false;
std::tie(std::ignore, inserted) = set_of_str.insert("Test");
if (inserted) {
    std::cout << "Value was inserted successfully\n";
}
///hide
}
```

<!-- .element: style="font-size:0.5em" -->

</script></section><section data-markdown><script type="text/template">
## avoiding cecursion

```cpp
///hide
#include <cassert>
///unhide
int sum() {
  return 0;
}

template<typename T, typename... Args>
int sum(const T& t, const Args&... args)
{
  return t + sum(args...);
}

///hide
int main() {
///unhide
assert(sum(1, 2, 3) == 6);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## `std::initializer_list` for the rescue

```cpp
///hide
#include <cassert>
#include <initializer_list>

///unhide
template<typename... Args>
int sum(const Args&... args)
{
  auto res = 0;
  (void)std::initializer_list<int>{(res += args, 0)...};
  return res;
}

///hide
int main() {
///unhide
assert(sum(1, 2, 3) == 6);
///hide
}
```

<aside class="notes"><p>C++17 has fold expressions</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/same.gif" -->

# variadic arguments of the same type

<!-- .element: class="r-stretch" style="display: flex; align-items: flex-end; text-shadow: 3px 3px black; color: lightblue" -->

</script></section><section data-markdown><script type="text/template">
## Solution #1 

`std::initializer_list`

```cpp
///hide
#include <cassert>
#include <initializer_list>

///unhide
int sum(std::initializer_list<int> ints);

///hide
void foo() {
///unhide
assert(sum({1, 2, 3}) == 6);
// sum({1, 2, "3"}); // fails to compile
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="conjunction" -->

```cpp
#include <type_traits>

template<class...> struct conjunction : std::true_type { };

template<class B1> struct conjunction<B1> : B1 { };

template<class B1, class... Bn>
struct conjunction<B1, Bn...> 
    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};
```

<!-- .element: style="font-size: 0.45em" -->

<aside class="notes"><p>in the standard from C++17</p>
</aside></script></section><section data-markdown><script type="text/template">
## Solution #2

`static_assert`

```cpp
///hide
#include <type_traits>
#include <cassert>

template<class...> struct conjunction : std::true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...> 
    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};
///unhide

template<typename... Args>
int sum(const Args&... args) {
  static_assert(conjunction<std::is_same<Args, int>...>::value, 
                "all arguments should be int");
}

///hide
void foo() {
///unhide
assert(sum(1, 2, 3) == 6);
// sum(1, 2, "3"); // fails to compile
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## SFINAE

"Substitution Failure Is Not An Error"

```cpp [|2,9|5,9]
template<typename T>
void f(T x, typename T::type y);
 
template<typename T>
void f(T x, typename T::other_type y);

struct A
{
    using type = int;
};

///hide
void foo() {
///unhide
f(A(), 42);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
`std::enable_if`

```cpp
template<bool B, class T = void>
struct enable_if {};
 
template<class T>
struct enable_if<true, T> { 
  typedef T type; 
};
```

</script></section><section data-markdown><script type="text/template">
## Solution #3

SFINAE

```cpp
///hide
#include <type_traits>
#include <cassert>

template<class...> struct conjunction : std::true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...> 
    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};

///unhide
template<typename... Ts>
using AllInts = typename std::enable_if<
  conjunction<std::is_same<Ts, int>...>::value
  >::type;


template<typename... Args, typename = AllInts<Args...>>
int sum(const Args&... args);

///hide
void foo() {
///unhide
assert(sum(1, 2, 3) == 6);
// sum(1, 2, "3"); // fails to compile
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/matrix_thanks.gif" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/ferdinand.jpg" -->

</script></section><section data-markdown><script type="text/template">
## count odds

> Given a vector of integers, count the number of odd items.

```cpp
///hide
#include <vector>

///unhide
int count_odds(const std::vector<int>& v);
```

<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
## First try

```cpp
///hide
#include <vector>

///unhide
int count_odds(const std::vector<int>& v)
{
    int ret = 0;
    for (auto it = v.begin(); 
         it != v.end(); 
         ++it)
    {
        if ((*it & 1) == 1)
            ++ret;
    }
    
    return ret;
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="05_lambda/wheel.gif" data-background-size="contain" -->

Don't reinvent the wheel

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `#include <algorithm>`

```cpp
///hide
#include <iterator>

///unhide
template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred);
```

<!-- .element: style="font-size: 0.5em" -->

> Returns the number of iterators it in the range `[first, last)` for which the following condition hold: 
> `pred(*it) != false`

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `#include <algorithm>`

```cpp
///hide
#include <iterator>

///unhide
template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred);
```

<!-- .element: style="font-size: 0.5em" -->

In our case `pred` should have the following signature:

```cpp
bool pred(int i);
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Write a function

```cpp []
///hide
#include <vector>
#include <algorithm>

///unhide
bool isOdd(int i)
{
    return (i & 1) == 1;
}

int count_odds(const std::vector<int>& v)
{
    return std::count_if(v.begin(), v.end(), isOdd);
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Write a function object

```cpp []
///hide
#include <vector>
#include <algorithm>

///unhide
struct IsOdd
{
    bool operator()(int i)
    {
        return (i & 1) == 1;
    }
};

int count_odds(const std::vector<int>& v)
{
    return std::count_if(v.begin(), v.end(), IsOdd());
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## So, what’s the problem?

Creating functions or functors can be a lot of effort, especially if the function/functor is only used in one specific place. 

These functions and functors also unnecessarily ‘clutter up’ the code.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="lambda_expressions" data-background-image="05_lambda/sirtaki.gif" -->

# Lambda expressions

<!-- .element: class="chapter bottom" -->

</script></section><section data-markdown><script type="text/template">
## Do it `λ`-style!

```cpp
///hide
#include <vector>
#include <algorithm>

///unhide
int count_odds(const std::vector<int>& v)
{
    return std::count_if(v.begin(), v.end(), [](int i)->bool
    {
        return (i & 1) == 1;
    });
}
```

</script></section><section data-markdown><script type="text/template">
## Syntax

<div class="r-stack r-stretch">

<div class="fragment highlight top" style="background-color:#1b91ff3d; height:5em; width:5em; top: -3em; left: -16em">
introducer
</div>

<div class="fragment highlight top" style="background-color:#42affa40; height:5em; width:7em; top: -3em; left: -8em">
(optional) parameter list
</div>

<div class="fragment highlight top" style="background-color:#8dcffc57; height:5em; width:7em; top: -3em; left: 2em">
(optional) return type
</div>

<div class="fragment highlight bottom" style="background-color:#bee4fd52; height:5em; width:24em; top: 3em; left: -6.6em">
body
</div>

```cpp
///hide
void foo() {
///unhide
[]          (int i)          ->bool

{ return (i & 1) == 1; }
///hide
;
}
```

<!-- .element: style="height: auto" -->

</div>

</script></section><section data-markdown><script type="text/template">
## behind the scenes

```cpp
///hide
void foo() {
///unhide
[](int i)->bool
{
    return (i & 1) == 1;
}
///hide
;
}
```

is translated to

```cpp [|4]
class __compiler_generated_name__
{
public: 
    inline bool operator()(int i) const
    {
      return (i & 1) == 1;
    }
};
```

</script></section><section data-markdown><script type="text/template">
## Named lambda

```cpp [2-5|7,9]
///hide
#include <vector>
#include <algorithm>
#include <cassert>

///unhide
void remove_odds(std::vector<int> &v) {
    auto isOdd = [](int i)
    {
        return (i & 1) == 1;
    };

    v.erase(std::remove_if(v.begin(), v.end(), isOdd), v.end());

    assert(std::count_if(v.begin(), v.end(), isOdd) == 0);
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## increment vector

> Given an integer and a vector, add the integer to every element of the vector.

```cpp
///hide
#include <vector>

///unhide
void add_to_vector(std::vector<int>& v, int added);
```

<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::for_each`

```cpp
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function fn);
```

<!-- .element: style="font-size: 0.45em" -->

> Applies function `fn` to each of the elements in the range `[first,last)`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::for_each`

```cpp
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function fn);
```

<!-- .element: style="font-size: 0.45em" -->

In our case `fn` should have the following signature:

```cpp
void fn(int& i);
```

</script></section><section data-markdown><script type="text/template">
## First try

```cpp
///fails='added' is not captured
///hide
#include <vector>
#include <algorithm>

///unhide
void add_to_vector_wrong(std::vector<int>& v, int added)
{
    std::for_each(v.begin(), v.end(), [](int& i)
    {
        i += added;
    });
}
```

</script></section><section data-markdown><script type="text/template">
## Using a function object

```cpp
///hide
#include <vector>
#include <algorithm>

///unhide
struct Add
{
    int m_added;
    Add(int added) : m_added(added) {}
    void operator()(int& i)
    {
        i += m_added;
    }
};

void add_to_vector_struct(std::vector<int>& v, int added)
{
    std::for_each(v.begin(), v.end(), Add(added));
}
```

</script></section><section data-markdown><script type="text/template">
## Capture that

```cpp
///hide
#include <vector>
#include <algorithm>

///unhide
void addToVector(std::vector<int>& v, int added)
{
    std::for_each(v.begin(), v.end(), [added](int& i)
    {
        i += added;
    });
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

### new number -> string conversions

```cpp [2-7,10-11|8-9]
#include <string>

struct Employee {
    int id;
    double salary;

    std::string to_string() const {
        return std::string{"Employee ID: "} + std::to_string(id) 
            + ", Salary: " + std::to_string(salary);
    }
};
```

<!-- .element: style="font-size: 0.45em" -->

- <!-- .element: class="fragment" style="font-size: 0.7em" --> no base support
- <!-- .element: class="fragment" style="font-size: 0.7em" --> return value may differ from what std::cout prints by default
- <!-- .element: class="fragment" style="font-size: 0.7em" --> relies on the current locale for formatting purposes

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

### new string -> number conversions

```cpp [11-15]
#include <string>

struct Employee {
    int id;
    double salary;

    Employee(const std::string& str) {
        const auto next_numeric = [](const std::string& s) {
            return s.substr(s.find_first_of("0123456789"));
        };
        const auto id_start = next_numeric(str);
        auto id_end = size_t{};
        id = std::stoi(id_start, &id_end, 10);
        const auto salary_start = next_numeric(id_start.substr(id_end));
        salary = std::stod(salary_start);
    }
};
```

<!-- .element: style="font-size: 0.45em" -->

-  <!-- .element: class="fragment" style="font-size: 0.7em" --> throws if conversion failed
-  <!-- .element: class="fragment" style="font-size: 0.7em" --> relies on the current locale for formatting purposes


</script></section><section data-markdown><script type="text/template">
## By reference

```cpp
///hide
#include <vector>
#include <algorithm>
#include <string>

///unhide
std::string to_string(const std::vector<int>& v)
{
    std::string s;
    std::for_each(v.begin(), v.end(), [&s](int i)
    {
        s += std::to_string(i) + " ";
    });
    return s;
}
```

</script></section><section data-markdown><script type="text/template">
## Capturing members

```cpp [|3,10-12]
///hide
#include <algorithm>

///unhide
struct ContainerIncrementer
{
    int m_x;
    ContainerIncrementer(int x) : m_x(x) {}
    template<typename Container>
    void increment(Container& cont)
    {
        std::for_each(std::begin(cont), 
                      std::end(cont), 
                      [this](int& val) {
                        val += m_x;
                      }
        );
    }
};
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## Default captures

|||
|-|-|
| `[&]` | Capture any referenced variable by reference |
| `[=]` | Capture any referenced variable by making a copy |
| `[=, &foo]` | Capture any referenced variable by making a copy, but capture variable foo by reference |

</script></section><section data-markdown><script type="text/template">
## fill vector

> fill a given vector with the numbers 0,1,2,...

</script></section><section data-markdown><script type="text/template">
## `#include <numeric>`

```
template< class ForwardIt, class T >
void iota( ForwardIt first, ForwardIt last, T value );
```

> Fills the range `[first, last)` with sequentially increasing values, starting with `value`.

</script></section><section data-markdown><script type="text/template">
## fill vector

```cpp [5]
#include <numeric>
#include <vector>

void fill_vector(std::vector<int>& v) {
    std::iota(v.begin(), v.end(), 0);
}
```

</script></section><section data-markdown><script type="text/template">
## fill vector

> fill a given vector with the numbers 0,2,4,...

</script></section><section data-markdown><script type="text/template">

## `#include <algorithm>`

```
template< class ForwardIt, class Generator >
void generate( ForwardIt first, ForwardIt last, Generator g );
```

<!-- .element: style="font-size: 0.5em" -->

> Assigns each element in range `[first, last)` a value generated by the given function object `g`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## fill vector

```cpp [5-10]
///fails=assignment of read-only variable 'i'
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    int i = 0;
    std::generate(v.begin(), v.end(), [i]{
        const auto next = i;
        i += 2;
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## fill vector

```cpp [8]
///fails=assignment of read-only variable 'i'
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    int i = 0;
    std::generate(v.begin(), v.end(), [i]{
        const auto next = i;
        i += 2; // error: assignment of read-only variable 'i'
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## mutable lambda

```cpp [6]
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    int i = 0;
    std::generate(v.begin(), v.end(), [i]() mutable {
        const auto next = i;
        i += 2;
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="lambda_init_capture" data-auto-animate -->

## capture init (C++14)

```cpp [5]
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    std::generate(v.begin(), v.end(), [i = 0]() mutable {
        const auto next = i;
        i += 2;
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Higher order lambda

```cpp
///hide
#include <iostream>
#include <string>

///unhide
auto add_prefix(const std::string &prefix) {
    return [&prefix](const std::string s) {
        return prefix + s;
    };
}

///hide
int main() {
///unhide
std::cout << add_prefix("Hello ")("World") << '\n';
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## careful

```cpp
///compiler=clang600
///hide
#include <iostream>
#include <string>

///unhide
auto add_prefix(const std::string &prefix) {
    return [&prefix](const std::string s) {
        return prefix + s;
    };
}

///hide
int main() {
///unhide
const auto prefixer = add_prefix("Hello ");
std::cout << prefixer("World") << '\n';
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [F.53](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture)

> Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [Con.1](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-immutable)

> By default, make objects immutable

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## it's complicated

```cpp []
///hide
#include <iostream>
#include <string>

///unhide
void draw_upper_case() {
    std::string s;
    for (char c; std::cin >> c; ) {
        s += toupper(c);
    }

    // draw text
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## it's complicated

```cpp [2-8]
///hide
#include <iostream>
#include <string>

///unhide
void draw_upper_case() {
    const auto s = [&] {
        std::string s;
        for (char c; std::cin >> c; ) {
            s += toupper(c);
        }
        return s;
    }();

    // draw text
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `#include <algorithm>`

```cpp [4-7]
///hide
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

///unhide
void draw_upper_case() {
    const auto s = [&] {
        std::string s;
        std::transform(std::istream_iterator<char>{std::cin}, 
                       std::istream_iterator<char>{},
                       std::back_inserter(s),
                       toupper);
        return s;
    }();

    // draw text
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [ES.28](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es28-use-lambdas-for-complex-initialization-especially-of-const-variables)

> Use lambdas for complex initialization, especially of `const` variables

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/sculptures.webp" data-background-position="top" -->

# legacy code
<!-- .element: class="r-stretch" style="display: flex; align-items: flex-end; justify-content: center; text-shadow: 3px 3px black; color: lightblue" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

Many libraries have such an interface

```cpp []
typedef int(*callback)(char*, int);
void register_callback(callback cb);
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

How can we call this with a lambda?

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

A captureless lambda can be converted to a function pointer

```cpp []
///hide
int read_count = 42;

///unhide
typedef int(*callback)(char*, int);
void register_callback(callback cb);

///hide
void register_callback(callback cb) { cb(nullptr, 0); }

int main(){
///unhide
register_callback([](char* buffer, int size) {
    /// read into buffer
    return read_count;
});
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

For capturing lambda we can add a level of indirection if the library supports user data

```cpp [1-2|4-8|9-11]
///hide
#include <fstream>
int read_count = 42;

///unhide
typedef int(*callback)(const char*, int, void*);
void register_callback(callback cb, void* userdata);

///hide
void register_callback(callback cb, void* userdata) { cb(nullptr, 0, userdata); }

int main(){
///unhide
std::fstream f;
auto cb = [&f](const char* buffer, int size) {
    /// read from f into buffer
    return read_count;
};
register_callback([](const char* buffer, int size, void* userdata){
    return (*static_cast<decltype(cb)*>(userdata))(buffer, size);
}, &cb);
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

<aside class="notes"><p>need to keep <code>cb</code> alive while the callback is active</p>
</aside></script></section><section data-markdown><script type="text/template">
## Let's benchmark

[Benchmark 1](https://quick-bench.com/q/lGVLy95a_GURGh2BJAuC9qKwFS4)

[Benchmark 2](https://quick-bench.com/q/19wvZEycM8eMDSXe5PVn4TUwstw)

<aside class="notes"><p>wrong <code>value_type</code> on the first</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="generic_lambdas" -->

## Generic Lambda (C++14)

```cpp
///hide
void foo() {
///unhide
[](const auto& a, auto& b){
    b += a;
}
///hide
;
}
```

is translated to

```cpp [4-5]
class __compiler_generated_name__
{
public: 
    template<typename A, typename B>
    inline void operator()(const A& a, B& b) const
    {
      return b += a;
    }
};
```

</script></section><section data-markdown><script type="text/template">
## Templated Lambda (C++20)

e.g. to force the same type

```cpp
///hide
void foo() {
///unhide
[]<typename T>(const T& a, T& b){
    b += a;
}
///hide
;
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Storing lambda

```cpp []
///hide
template<typename Lambda>
///unhide
class CallbackHolder {
public:
    CallbackHolder(Lambda callback) 
        : m_callback{callback} 
    {}

    void call() {
        m_callback();
    }

    Lambda m_callback;
};
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Storing lambda

templatize

```cpp []
///hide
#include <utility>

///unhide
template<typename Lambda>
class CallbackHolder {
public:
    CallbackHolder(Lambda callback) 
        : m_callback{callback} 
    {}

    void call() {
        m_callback();
    }

    Lambda m_callback;
};

template<typename Lambda>
CallbackHolder<Lambda> make_holder(Lambda&& lambda) {
    return { std::forward<Lambda>(lambda) };
}

///hide
int main() {
///unhide
auto holder = make_holder([](){ return 42; });
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Storing lambda

`std::function`

```cpp []
#include <functional>

class CallbackHolder {
public:
    CallbackHolder(std::function<void()> callback) 
        : m_callback{callback} 
    {}

    void call() {
        m_callback();
    }

    std::function<void()> m_callback;
};

///hide
int main() {
///unhide
CallbackHolder holder{[](){ return 42; }};
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## `std::function`

A general-purpose polymorphic function wrapper. 

```cpp
///hide
template<typename... Ts> class function;

///unhide
template< class R, typename... Args >
class function<R(Args...)>;
```

Can store any `Callable` which recieves `Args` and returns `R`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Free function

```cpp []
///hide
#include <functional>

///unhide
long floor(double d) { return d; }

int main(){
    std::function<long(double)> f = floor;
    return f(4.2);
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Lambda

```cpp []
///hide
#include <functional>

///unhide
auto floor = [](double d)->int { return d; };

int main(){
    std::function<long(double)> f = floor;
    return f(4.2);
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Function abject

```cpp []
///hide
#include <functional>

///unhide
struct floor{
    long operator()(double d) { return d; }
};

int main(){
    std::function<long(double)> f = floor{};
    return f(4.2);
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Member function

```cpp []
///hide
#include <functional>

///unhide
struct floor{
    floor(double d) : m_d{d} {}
    long calc() const { return m_d; }
    double m_d;
};

int main(){
    std::function<long(const floor&)> f = &floor::calc;
    return f(floor{4.2});
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Member variable

```cpp []
///hide
#include <functional>

///unhide
struct floor{
    floor(double d) : m_d{d} {}
    long calc() const { return m_d; }
    double m_d;
};

int main(){
    std::function<double(const floor&)> f = &floor::m_d;
    return f(floor{4.2});
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## virtual function

```cpp []
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get() const { return 1; }
};

struct Derived : Base {
    virtual int get() const { return 2; }
};

///hide
int main() {
///unhide
Base* p = new Derived();
assert(p->get() == 2);
///hide
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
## changing signature

<!-- .slide: class="aside" data-auto-animate -->

```cpp [3,7,11]
///fails=Assertion `p->get(0) == 2' failed
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived : Base {
    virtual int get() const { return 2; }
};

///hide
int main() {
///unhide
Base* p = new Derived();
assert(p->get(0) == 2);
///hide
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="override" class="aside" data-auto-animate -->

## proper compiler error

```cpp [7]
///fails='int Derived::get() const' marked 'override', but does not override
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived : Base {
    int get() const override { return 2; } // error
};

///hide
int main() {
///unhide
Base* p = new Derived();
assert(p->get(0) == 2);
///hide
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="final" class="aside" data-auto-animate -->

## disable override

```cpp [7,11]
///fails=virtual function 'virtual int Grandson::get(int) const' overriding final function
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived : Base {
    int get(int) const final { return 2; }
};

struct Grandson : Derived {
    int get(int) const override { return 3; } // error
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## C++ Core Guidelines [C.128](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final)

> Virtual functions should specify exactly one of `virtual`, `override`, or `final`

</script></section><section data-markdown><script type="text/template">
## final class

<!-- .slide: class="aside" -->

```cpp [6,10]
///fails=cannot derive from 'final' base 'Derived' in derived type 'Grandson'
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived final : Base {
    int get(int) const { return 2; }
};

struct Grandson : Derived { // error
}
```

</script></section><section data-markdown><script type="text/template">
## devirtualization

<!-- .slide: class="aside" -->

```cpp [10-12]
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived final : Base {
    int get(int) const { return 2; }
};

int callGet(const Derived& d, int i) { 
  return d.get(i); 
}
```

</script></section><section data-markdown><script type="text/template">
## `std::function` Ceveats

* might allocate
* may require two calls through function pointers per invocation

[Benchmark 1](https://quick-bench.com/q/DfBQBz4PrwOceIQZIGbodXAXLz8)

[Benchmark 2](https://quick-bench.com/q/28rParTpVouuPVLZvj4O_4O4do8)

<aside class="notes"><p>1st including <code>std::function</code> creation</p>
</aside></script></section><section data-markdown><script type="text/template">
<div class="r-stretch" style="display: flex; flex-direction: column; align-items: center; justify-content: center">

## Lambdas

1. make code more readable
2. improve locality of the code
3. allow to store state easily
4. make using algorithms easy
5. get better with each revision

</div>

<div class="footnote">

Source: [Bartek's coding blog](https://www.bfilipek.com/2020/05/lambdasadvantages.html?m=1#5-lambdas-get-better-with-each-revision-of-c)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/ευχαριστώ.jpg" data-background-size="contain" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="06_smart_pointers/pallister.png" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## what's printed

```cpp
///hide
#include <string>
#include <iostream>
#include <stdexcept>

///unhide
void process(const std::string& str) {
    auto p = new int;
    *p = std::stoi(str);
    std::cout << *p << '\n';
    delete p;
}

///hide
int main() {
///unhide
try {
    process("ll");
} catch (std::exception& ex) {
    std::cout << ex.what() << '\n';
}
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## what's wrong here

```cpp
///options=-fsanitize=address
///fails=attempting double-free
///hide
#include <string>
#include <iostream>
#include <stdexcept>

///unhide
struct S{
    S(): p{new int} {}
    ~S() { delete p; }
    S(const S& other) : p{other.p} {}

    int* p;
};

///hide
int main() {
///unhide
S s1;
S s2 = s1;
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## and here

```cpp
///options=-fsanitize=address
///fails=alloc-dealloc-mismatch
///hide
#include <string>
#include <iostream>
#include <stdexcept>

///unhide
struct S{
    S(): p{new int[10]} {}
    ~S() { delete p; }
    S(S&& other) : p{other.p} { other.p = nullptr; }

    int* p;
};

///hide
int main() {
///unhide
S s1;
S s2 = std::move(s1);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## First solution

</script></section><section data-markdown><script type="text/template">
## Don't heap allocate!

![heap](06_smart_pointers/stopit.webp)

</script></section><section data-markdown><script type="text/template">
## When to heap-allocate

- <!-- .element: class="fragment" --> Runtime Polymorphism
- <!-- .element: class="fragment" --> Decouple compilation units (PIMPL)
- <!-- .element: class="fragment" --> An object needs to outlive its scope

</script></section><section data-markdown><script type="text/template">
## second solution

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="06_smart_pointers/smart.webp" -->

# Smart pointers

<!-- .element: class="chapter bottom" -->

</script></section><section data-markdown><script type="text/template">
## Smart pointers

> a smart pointer is an abstract data type that simulates a pointer while providing additional features, such as automatic memory management or bounds checking.

</script></section><section data-markdown><script type="text/template">
## Ownership

The owner of a dynamically allocated object is the one who is responsible to delete it. 
There are three patterns of object ownership:
- Creator as a Sole Owner
- Sequence of Owners
- Shared Ownership

</script></section><section data-markdown><script type="text/template">
## Creator as a Sole Owner

When a class creates and deletes a resource:

```cpp
///hide
class Object{};

///unhide
struct DumbSingleOwner
{
    DumbSingleOwner() : m_pObject(new Object)
    {}

    ~DumbSingleOwner()
    {
        delete m_pObject;
    }

    Object* m_pObject;
};
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="unique_ptr" -->

## Use `std::unique_ptr`

```cpp
#include <memory>
///hide

class Object{};
///unhide

struct SmartSingleOwner
{
    SmartSingleOwner() : m_pObject(new Object)
    {}
    std::unique_ptr<Object> m_pObject;
};
```

<aside class="notes"><p>Keeps the rule of 0</p>
</aside></script></section><section data-markdown><script type="text/template">
## How does it work?

`unique_ptr` deletes the stored object on its destructor.

</script></section><section data-markdown><script type="text/template">
## Testing

```cpp
///hide
#include <iostream>
#include <memory>

///unhide
struct Object
{
    Object(){ std::cout << "Object constructed\n"; }

    ~Object(){ std::cout << "Object destructed\n"; }
};
///hide

struct DumbSingleOwner
{
    DumbSingleOwner() : m_pObject(new Object)
    {}

    ~DumbSingleOwner()
    {
        delete m_pObject;
    }

    Object* m_pObject;
};

struct SmartSingleOwner
{
    SmartSingleOwner() : m_pObject(new Object)
    {}
    std::unique_ptr<Object> m_pObject;
};
///unhide

int main()
{
    {
        DumbSingleOwner dumb;
    }
    {
        SmartSingleOwner smart;
    } 
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## Can be used as a raw pointer

```cpp [4|5|6]
///hide
#include <string>
#include <memory>
#include <iostream>

///unhide
int main()
{
    std::unique_ptr<std::string> pInt(new std::string("Hello"));
    pInt->append(" World");
    if (pInt)
        std::cout << *pInt << '\n';
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## other useful methods

- `.get()` - returns the stored pointer
- `.reset()` - replaces the managed object
- `.release()` - returns a pointer to the managed object and releases the ownership

</script></section><section data-markdown><script type="text/template">
## Sequence of Owners

Who should delete the created object?

```cpp
///hide
class Object;

///unhide
class Factory
{
public:
    virtual Object* createObject() = 0;
};
```

</script></section><section data-markdown><script type="text/template">
## The caller?

```cpp
///hide
class Object {};

class Factory
{
public:
    virtual Object* createObject() = 0;
};

///unhide
class FreeSpiritFactory : public Factory
{
public:
    Object* createObject() override
    {
        return new Object;
    }
};
```

</script></section><section data-markdown><script type="text/template">
## The factory?

```cpp
///hide
#include <vector>
#include <algorithm>

class Object {};

class Factory
{
public:
    virtual Object* createObject() = 0;
};

///unhide
class AccountantFactory : public Factory
{
public:
    Object* createObject() override
    {
        m_objects.push_back(new Object);
        return m_objects.back();
    }

    ~AccountantFactory()
    {
        std::for_each(m_objects.begin(), m_objects.end(), [](Object* p){
            delete p;
        });
    }

private:
    std::vector<Object*> m_objects;
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## Use `std::unique_ptr`

Now it is clear the caller gets ownership

```cpp
///hide
#include <memory>

class Object {};

///unhide
class SmartFactory
{
public:
    std::unique_ptr<Object> createObject()
    {
        return std::unique_ptr<Object>{ new Object() };
    }
};
```

</script></section><section data-markdown><script type="text/template">
## How does it work?

- The copy constructor and assignment operator of `std::unique_ptr` are deleted. 
- It only has a move constructor and move assignment operator.
- When moved from, the original `std::unique_ptr` releases the object and the destination `std::unique_ptr` acquires it.

</script></section><section data-markdown><script type="text/template">
## Example

```cpp
///hide
#include <memory>
#include <cassert>

int main() {
///unhide
std::unique_ptr<int> pInt(new int(1)); 
// std::unique_ptr<int> pIntCopy = pInt; // doesn't compile
std::unique_ptr<int> pIntMove = std::move(pInt);
assert(pIntMove && !pInt);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Unique array

```cpp [2,4]
///hide
#include <memory>
#include <cstdio>
#include <cstring>

int main() {
///unhide
auto pHello = "Hello World!";
std::unique_ptr<char[]> pCharArray(new char[strlen(pHello) + 1]);
sprintf(pCharArray.get(), pHello);
printf("third letter is %c\n", pCharArray[2]);
///hide
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## Shared ownership

What if the factory does want to keep a reference to the created object?

If the factory would return a pointer, the user might already delete it by the time the factory references it!

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="emplace" class="aside" -->

## `emplace_back`

constructs a collection element in place

```cpp [1-8|12|13]
///hide
#include <iostream>
#include <string>
#include <vector>

///unhide
struct S {
    explicit S(const std::string &s): s{s} 
    { std::cout << "Ctor " << s << "\n"; }
    S(S&& other): s{std::move(other.s)} 
    { std::cout << "Move Ctor " << s << "\n"; }

    std::string s;
};

///hide
int main() {
///unhide
std::vector<S> v;
v.reserve(2);
v.push_back(S("pushed"));
v.emplace_back("emplaced");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

# `emplace`

```cpp
///hide
#include <string>
#include <map>

int main() {
///unhide
std::map<std::string, std::string> m;
m.emplace("key", "value");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="shared_ptr" -->

## Use `std::shared_ptr`

```cpp
///hide
#include <memory>
#include <vector>

class Object {};

///unhide
class SmartAccountant
{
public:
    std::shared_ptr<Object> createObject()
    {
        m_createdObjects.emplace_back(new Object);
        return m_createdObjects.back();
    }

private:
    std::vector<std::shared_ptr<Object>> m_createdObjects;
};
```

</script></section><section data-markdown><script type="text/template">
## How does it work?

The `shared_ptr` works on reference counting, so as long as the factory holds a reference to the created object, it is guaranteed not be deleted. 

</script></section><section data-markdown><script type="text/template">
## no free lunch

<!-- .element: class="chapter bottom" -->

<!-- .slide: data-background-image="06_smart_pointers/lunch.gif" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## Counting has its cost

- A counter should be allocated on the heap
- On each copy of the `shared_ptr` the counter is incremented and on each destruction, decremented.

</script></section><section data-markdown><script type="text/template">
## So, what to do?

- Use shared ownership only if you must
- Pass `shared_ptr` by const reference to functions so less copies will occur.
- Allocate with `make_shared`

</script></section><section data-markdown><script type="text/template">
## `std::make_shared`

Instead of:

```cpp
///hide
#include <memory>

int main(){
///unhide
std::shared_ptr<int> pInt1(new int(5));
///hide
}
```

Write:

```cpp
///hide
#include <memory>

int main(){
///unhide
auto pInt2 = std::make_shared<int>(5);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Why is it good?

- Allocates the counter together with the object – one less dynamic memory allocation and improved locality.
- Can prevent memory leaks on certain situations.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="make_unique" -->

## `std::make_unique`

Similarly, the standard library offers `make_unique` to allocate unique pointers.

```cpp
///hide
#include <memory>
#include <cmath>

int main(){
///unhide
auto pFloat = std::make_unique<float>(INFINITY);
///hide
}
```

<aside class="notes"><p>to conclude...</p>
</aside></script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [R.5](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r5-prefer-scoped-objects-dont-heap-allocate-unnecessarily)

> Prefer scoped objects, don’t heap-allocate unnecessarily

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [C.149](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new)

> Use `unique_ptr` or `shared_ptr` to avoid forgetting to delete objects created using new

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [R.11](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r11-avoid-calling-new-and-delete-explicitly)

> Avoid calling `new` and `delete` explicitly

</script></section><section data-markdown><script type="text/template">
## Custom deleters

- By default, smart pointers call `delete` (or `delete[]` in case of `unique_ptr<T[]>`), to free the managed object.
- The user can choose to call any other function.

</script></section><section data-markdown><script type="text/template">
## Shared array

A custom deleter of a `shared_ptr` is sent as a second parameter to the constructor:

```cpp
///options=-std=c++11
///hide
#include <memory>

int main(){
///unhide
auto pSharedArray = std::shared_ptr<int[]>(new int[3], 
[](int* p)
{
    delete[] p;
});
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Not just memory

Custom deleters enable the standard smart pointers to manage other resources besides memory:

```cpp
///external
///compiler=vcpp_v19_24_x64
///options=/O2
///hide
#include <type_traits>
#include <memory>
///unhide
#include <Windows.h>

///hide

int main() {
///unhide
using LibType = typename std::remove_pointer<HINSTANCE>::type;
auto pLib = std::shared_ptr<LibType>(LoadLibrary("somelib.dll"), FreeLibrary);
if (pLib)
{
    GetProcAddress(pLib.get(), "makeObject");
}
///hide
}
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## `unique_ptr` custom deleter

A custom deleter of a `unique_ptr` should be declared as a second template parameter:

```cpp
///hide
#include <memory>
#include <cstdio>

int main() {
///unhide
auto pMalloced = std::unique_ptr<char, void(*)(char*)>((char*)malloc(4), 
                                                       [](char* p)
{
    free(p);
});

auto pFile = std::unique_ptr<FILE, int(*)(FILE*)>(fopen("myfile.txt", "wt"), 
                                                  [](FILE* f){
    return fclose(f);
});
fprintf(pFile.get(), "Hello World!");
///hide
}
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## Leaky marriage

```cpp [13-17,21|25-30]
///hide
#include <string>
#include <memory>
#include <iostream>

///unhide
class Person
{
public:
    Person(const std::string& name)
     : m_name(name)
    {
        std::cout << m_name << " created.\n";
    }
    ~Person()
    {
        std::cout << m_name << " destroyed.\n";
    }
    void marry
        (const std::shared_ptr<Person>& spouse)
    {
        m_spouse = spouse;
    }

private:
    std::string              m_name;
    std::shared_ptr<Person>  m_spouse;
};
int main()
{
    auto chandler 
        = std::make_shared<Person>("Chandler");
    auto monica 
        = std::make_shared<Person>("Monica");
    chandler->marry(monica);
    monica->marry(chandler);
}












```

<!-- .element: class="split" style="font-size: 0.35em" -->

</script></section><section data-markdown><script type="text/template">
## What happened?

![cycle](06_smart_pointers/marriage.svg)

When there is a cycle of `shared_ptr`s pointing to each other, they all keep each other from being destroyed.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="weak_ptr" -->

## use `std::weak_ptr`

Should be constructed from an existing `shared_ptr`:

```cpp
///hide
#include <memory>

int main() {
///unhide
auto pSharedChar = std::make_shared<char>('x');
std::weak_ptr<char> pWeakChar(pSharedChar);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## `std::weak_ptr`

To access the owned pointer, the user should call `lock()` to get a new `shared_ptr` to the object, if it hasn’t been freed or an empty `shared_ptr` otherwise.

```cpp
///hide
#include <memory>
#include <cstdio>

int main() {
auto pSharedChar = std::make_shared<char>('x');
std::weak_ptr<char> pWeakChar(pSharedChar);
///unhide
if (auto pSharedChar2 = pWeakChar.lock())
{
    printf("%c\n", *pSharedChar2);
}
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## How does it work?

- Each `shared_ptr` contains two counters – one for strong references and another one for weak references.
- When a `shared_ptr` is destroyed, the decision whether to call the deleter is only based on the strong counter.
- The counters themselves are freed when both counters reach 0.

</script></section><section data-markdown><script type="text/template">
## Back to marriage

```cpp [13-17,21]
///hide
#include <string>
#include <memory>
#include <iostream>

///unhide
class Person
{
public:
    Person(const std::string& name)
     : m_name(name)
    {
        std::cout << m_name << " created.\n";
    }
    ~Person()
    {
        std::cout << m_name << " destroyed.\n";
    }
    void marry(
        const std::shared_ptr<Person>& spouse)
    {
        m_spouse = spouse;
    }

private:
    std::string              m_name;
    std::weak_ptr<Person>    m_spouse;
};
int main()
{
    auto chandler 
        = std::make_shared<Person>("Chandler");
    auto monica 
        = std::make_shared<Person>("Monica");
    chandler->marry(monica);
    monica->marry(chandler);
}












```

<!-- .element: class="split" style="font-size:0.35em" -->

</script></section><section data-markdown><script type="text/template">
## better for factory

```cpp [12]
///hide
#include <memory>
#include <vector>

class Object{};

///unhide
class SmarterAccountant
{
public:
    std::shared_ptr<Object> createObject()
    {
        auto res = std::make_shared<Object>();
        m_createdObjects.emplace_back(res);
        return res;
    }

private:
    std::vector<std::weak_ptr<Object>> m_createdObjects;
};
```

</script></section><section data-markdown><script type="text/template">
## casting

The standard library provides functions to cast **`shared_ptr`s**:

```cpp [1-9|13-16]
///hide
#include <memory>

///unhide
struct Base
{
    virtual ~Base();
};

struct Derived : public Base
{
    void doSomething() {}
};

void smartDowncaster(const std::shared_ptr<Base>& pBase)
{
    if (auto pDerived = std::dynamic_pointer_cast<Derived>(pBase))
    {
        pDerived->doSomething();
    }
}
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## casting

<div style="text-align: left">

There's also

- `static_pointer_cast`
- `const_pointer_cast`
- `reinterpret_pointer_cast` (Since C++17)

</div>

<aside class="notes"><p>Since casting creates a copy of the pointer, it can be used with <code>shared_ptr</code>s only! If needed, one can first call <code>get()</code> on the <code>unique_ptr</code> to get the raw pointer and cast the result, but this is generally considered a bad design.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="attributes" class="aside" -->

## attributes

- Standardized GNU's `__attribute__` and MSVC’s `__declspec`
- <!-- .element: class="fragment" --> can be used almost everywhere in the C++ program, and can be applied to almost everything
- <!-- .element: class="fragment" --> each particular attribute is only valid where it is permitted by the implementation
- <!-- .element: class="fragment" --> Besides the standard attributes, implementations may support arbitrary non-standard attributes
- <!-- .element: class="fragment" --> All attributes unknown to an implementation are ignored

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Examples

- `[[noreturn]]`
- `[[deprecated("reason")]]` (C++14)
- `[[maybe_unused]]` (C++17)
- `[[likely]]` (C++20)
- `[[gnu::always_inline]]`

</script></section><section data-markdown><script type="text/template">
## time to benchmark

[raw vs. unique vs. shared](https://quick-bench.com/q/FrCYZD3FgKip5Kwn9Uz76RHM97A)

[with inlining](https://quick-bench.com/q/BOW6gJETy-bFADckH42l_vkjP3w)

[`make_shared` vs. `new`](https://quick-bench.com/q/3J4mZ3uN45kbDosFrpOsMN5BNsk)

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## do work

```cpp [1-5|9-13]
struct ThreadPool
{
    template<typename F>
    void execute(F&&);
};

///hide
template<typename F>
void ThreadPool::execute(F&&) {}

///unhide
struct Work
{
    void execute() {
        m_pool.execute([this]{
            doWork();
        });
    }

    void doWork();

    ThreadPool m_pool;
};
```

<!-- .element: data-id="code" style="font-size: 0.35em" -->

<aside class="notes"><p>what if work is destoryed before the pool?</p>
<div class="footnote">

<p>Source: <a href="https://www.nextptr.com/tutorial/ta1414193955/enable_shared_from_this-overview-examples-and-internals">nextptr</a></p>
</div></aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## do work

```cpp [12-15]
#include <memory>

struct ThreadPool
{
    template<typename F>
    void execute(F&&);
};

///hide
template<typename F>
void ThreadPool::execute(F&&) {}

///unhide
struct Work
{
    void execute() {
        auto self = std::shared_ptr<Work>(this);
        m_pool.execute([self]{
            self->doWork();
        });
    }

    void doWork();

    ThreadPool m_pool;
};
```

<!-- .element: data-id="code" style="font-size: 0.35em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## do work

```cpp [6,17-18]
#include <memory>

///hide
struct ThreadPool
{
    template<typename F>
    void execute(F&&);
};

template<typename F>
void ThreadPool::execute(F&&) {}

///unhide
struct Work
{
    void execute() {
        auto self = std::shared_ptr<Work>(this);
        m_pool.execute([self]{
            self->doWork();
        });
    }

    void doWork();

    ThreadPool m_pool;
};

///hide
void Work::doWork() {}

int main() {
///unhide
auto work = std::make_shared<Work>();
work->doWork();
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.35em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::enable_shared_from_this`

```cpp [3,6]
#include <memory>

///hide
struct ThreadPool
{
    template<typename F>
    void execute(F&&);
};

template<typename F>
void ThreadPool::execute(F&&) {}

///unhide
struct Work : std::enable_shared_from_this<Work>
{
    void execute() {
        auto self = shared_from_this();
        m_pool.execute([self]{
            self->doWork();
        });
    }

    void doWork();

    ThreadPool m_pool;
};

///hide
void Work::doWork() {}

int main() {
///unhide
auto work = std::make_shared<Work>();
work->doWork();
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## how to pass smart pointers

C++ Core Guidelines [R.32](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget): Take a `unique_ptr<widget>` parameter to express that a function assumes ownership of a widget

```cpp
///hide
#include <memory>

class widget;

///unhide
// takes ownership of the widget
void sink(std::unique_ptr<widget>);
```

<!-- .element: data-id="code2" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## how to pass smart pointers

C++ Core Guidelines [R.33](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-thewidget): Take a `unique_ptr<widget>&` parameter to express that a function reseats the `widget`

```cpp
///hide
#include <memory>

class widget;

///unhide
// "will" or "might" reseat pointer
void reseat(std::unique_ptr<widget>&);
```

<!-- .element: data-id="code2" -->

<aside class="notes"><p>Note &quot;reseat&quot; means &quot;making a pointer or a smart pointer refer to a different object.&quot;</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## how to pass smart pointers

C++ Core Guidelines [R.34](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r34-take-a-shared_ptrwidget-parameter-to-express-that-a-function-is-part-owner): Take a `shared_ptr<widget>` parameter to express that a function is part owner

```cpp
///hide
#include <memory>

class widget;

///unhide
// share -- "will" retain refcount
void share(std::shared_ptr<widget>);
```

<!-- .element: data-id="code2" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## how to pass smart pointers

C++ Core Guidelines [R.35](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r35-take-a-shared_ptrwidget-parameter-to-express-that-a-function-might-reseat-the-shared-pointer): Take a `shared_ptr<widget>&` parameter to express that a function might reseat the shared pointer

```cpp
///hide
#include <memory>

class widget;

///unhide
// "might" reseat ptr
void reseat(std::shared_ptr<widget>&);
```

<!-- .element: data-id="code2" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## how to pass smart pointers

C++ Core Guidelines [R.36](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget): Take a `const shared_ptr<widget>&` parameter to express that it might retain a reference count to the object

```cpp
///hide
#include <memory>

class widget;

///unhide
// "might" retain refcount
void may_share(const std::shared_ptr<widget>&);
```

<!-- .element: data-id="code2" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="06_smart_pointers/thanks.webp" data-background-size="contain" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="07_chrono/cantona.jpg" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## how much time

```cpp
///hide
void sleep(int);

void foo() {
///unhide
sleep(10);
///hide
}
```

Need to check [documentation](https://man7.org/linux/man-pages/man3/sleep.3.html)

<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="chrono" data-background-image="07_chrono/chrono.gif" -->

<div class="footnote">

Source: [CppCon 2016: Howard Hinnant "A ＜chrono＞ Tutorial"](https://www.youtube.com/watch?v=P32hvk8b13M)

</div>

# `std::chrono`

<!-- .element: class="chapter" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

Scalar-like construction behavior

```cpp
#include <chrono>
///hide
void foo() {
{
///unhide
std::chrono::seconds s; // no initialization
///hide
}
{
///unhide
std::chrono::seconds s{}; // zero initialization
///hide
}
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

no implicit convesion from int

```cpp
///fails=conversion from 'int' to non-scalar type 'std::chrono::seconds'
#include <chrono>
///hide
void foo() {
{
///unhide
std::chrono::seconds s = 3; // fails
///hide
}
{
///unhide
std::chrono::seconds s{3}; // good
///hide
}
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## new integer types

Exact-width integer types

<div class="split">

- int8_t
- int16_t
- int32_t
- int64_t
- uint8_t
- uint16_t
- uint32_t
- uint64_t

</div>

<aside class="notes"><p><code>(u)intN_t</code> designates a (un)signed integer type with width N, no padding
bits, and a two’s complement representation.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## new integer types

Minimum-width integer types

<div class="split">

- int_least8_t
- int_least16_t
- int_least32_t
- int_least64_t
- uint_least8_t
- uint_least16_t
- uint_least32_t
- uint_least64_t

</div>

<aside class="notes"><p><code>(u)int_leastN_t</code> designates a (un)signed integer type with a width of at least N,  such that no signed integer type with lesser size has at least the specified width.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## new integer types

Fastest minimum-width integer types

<div class="split">

- int_fast8_t
- int_fast16_t
- int_fast32_t
- int_fast64_t
- uint_fast8_t
- uint_fast16_t
- uint_fast32_t
- uint_fast64_t

</div>

<aside class="notes"><p><code>(u)int_fastN_t</code> designates the fastest (un)signed integer type with a width of at fast N.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## new integer types

Integer types capable of holding object pointers

<div class="split">

- intptr_t
- uintptr_t

</div>

<aside class="notes"><p><code>(u)intptr_t</code> designates a (un)signed integer type with the property that any valid
pointer to <code>void</code> can be converted to this type, then converted back to pointer to <code>void</code>,
and the result will compare equal to the original pointer.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## new integer types

Greatest-width integer types

<div class="split">

- intmax_t
- uintmax_t

</div>

<aside class="notes"><p><code>(u)intmax_t</code> designates a (un)signed integer type capable of representing any value of
any (un)signed integer type.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

no implicit convesion to int

```cpp
///fails=cannot convert 'std::chrono::seconds'
#include <chrono>
///hide
void foo() {
{
///unhide
int64_t s = std::chrono::seconds{3}; // fails
///hide
}
{
///unhide
int64_t s = std::chrono::seconds{3}.count(); // good
///hide
}
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

Addition and subtraction

```cpp
#include <chrono>

using std::chrono::seconds;

void f(seconds d);

///hide
void foo() {
///unhide
seconds x{3};
x += seconds{3};
f(x); // f(5 seconds)
x = x - seconds{1};
f(x); // f(4 seconds)
// f(x + 1); // error: seconds + int not allowed
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

comparison

```cpp
///hide
#include <chrono>
#include <iostream>

///unhide
using std::chrono::seconds;

const auto time_limit = seconds{2};

void f(seconds d)
{
  if (d <= time_limit)
    std::cout << "in time: ";
  else
    std::cout << "out of time: ";
  std::cout << d.count() << "s\n";
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

comparison

```cpp
///fails=no match for 'operator<='
///hide
#include <chrono>
#include <iostream>

///unhide
using std::chrono::seconds;

const auto time_limit = 2;

void f(seconds d)
{
  if (d <= time_limit) // error: seconds <= int not allowed
    std::cout << "in time: ";
  else
    std::cout << "out of time: ";
  std::cout << d.count() << "s\n";
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

range of ±292 billion years

```cpp
///hide
#include <chrono>
#include <iostream>

///unhide
using std::chrono::seconds;

int main() {
  const auto secondsInAYear = 60 * 60 * 24 * 365;
  std::cout
   << seconds::max().count() / secondsInAYear << '\n'
   << seconds::min().count() / secondsInAYear << '\n'; 
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::chrono::seconds`

[How much does it cost?!](https://quick-bench.com/q/2Ff1rtmFfBcm--J0RpTYpWbbCW0)

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## literals

```cpp
auto a{42}, b{052}, c{0x2A};  // integer, int
auto d{4.27}, e{5E1};         // floating point, double
auto f{'f'}, g{'\n'};         // character, char
auto h = "foo";               // string, const char[4]
auto i{true}, k{false};       // boolean, bool
```

<div class="footnote">

Source: [SIMPLIFY C++](https://arne-mertz.de/2016/10/modern-c-features-user-defined-literals/)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="utf_chars" class="aside" -->

## new character types and literals

```cpp
///hide
#include <iostream>

int main() {
///unhide
char const utf8[]{u8"Hello, ☃!"};
char16_t const utf16[]{u"Hello, ☃!"};
char32_t const utf32[]{U"Hello, ☃!"};

std::cout 
  << "sizeof(utf8) = " << sizeof(utf8) << '\n'
  << "sizeof(utf16) = " << sizeof(utf16) << '\n'
  << "sizeof(utf32) = " << sizeof(utf32) << '\n';
///hide
}
```

from C++20:

```cpp
///compiler=g93
///options=-std=c++2a
char8_t const utf8[]{u8"Hello, ☃!"};
```

<aside class="notes"><p>char8_t was introduced to enable overloading between char and char8_t</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## literal suffixes

```cpp
auto a{32u};     // unsigned int
auto b{043l};    // long
auto c{0x34ull}; // unsigned long long
auto d{4.27f};   // float
auto e{5E1l};    // long double
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## user-defined literals

```cpp []
///hide
#include <cmath>
#include <cassert>

///unhide
const auto PI = 3.14159265358979323846264L;

long double operator""_deg ( long double deg )
{
    return deg * PI / 180;
}

///hide
int main() {
///unhide
assert(std::sin(90.0_deg) == 1);
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## user-defined literals

alternatively

```cpp []
///hide
#include <cmath>
#include <cassert>
#include <string>

///unhide
const auto PI = 3.14159265358979323846264L;

long double operator""_deg ( const char* deg )
{
    return std::stold(deg) * PI / 180;
}

///hide
int main() {
///unhide
assert(std::sin(90.0_deg) == 1);
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## user-defined literals

also takes integrals

```cpp []
///hide
#include <cmath>
#include <cassert>
#include <string>

///unhide
const auto PI = 3.14159265358979323846264L;

long double operator""_deg ( const char* deg )
{
    return std::stold(deg) * PI / 180;
}

///hide
int main() {
///unhide
assert(std::sin(90_deg) == 1);
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## allowed paramaters

user-defined integer literals

```cpp
///hide
struct T {};

///unhide
T operator""_suffix ( unsigned long long int );

T x = 42_suffix;
```

<!-- .element: data-id="code2" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## allowed paramaters

user-defined floating-point literals

```cpp
///hide
struct T {};

///unhide
T operator""_suffix ( long double );

T x = 42.0_suffix;
```

<!-- .element: data-id="code2" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## allowed paramaters

raw literal operators

```cpp
///hide
struct T {};

///unhide
T operator""_suffix ( const char* );

T x = 42_suffix;

T y = 42.0_suffix;
```

<!-- .element: data-id="code2" style="font-size: 0.5em" -->

used as fallbacks for integer and floating-point user-defined literals

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## allowed paramaters

user-defined character literals

```cpp
///compiler=g93
///options=-std=c++2a
///hide
struct T {};

///unhide
T operator""_suffix ( char );
T operator""_suffix ( wchar_t );
T operator""_suffix ( char8_t ); // C++20
T operator""_suffix ( char16_t );
T operator""_suffix ( char32_t );

T x = u'4'_suffix;
```

<!-- .element: data-id="code2" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="UDL" class="aside" data-auto-animate -->

## allowed paramaters

user-defined string literals

```cpp
///compiler=g93
///options=-std=c++2a
///hide
#include <cstdint>

struct T {};

///unhide
T operator""_suffix ( const char     * , std::size_t );
T operator""_suffix ( const wchar_t  * , std::size_t );
T operator""_suffix ( const char8_t  * , std::size_t ); // C++20
T operator""_suffix ( const char16_t * , std::size_t );
T operator""_suffix ( const char32_t * , std::size_t );

T x = U"42"_suffix;
```

<!-- .element: data-id="code2" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="string_literals" class="aside" data-auto-animate -->

## Library string literals (C++14)

String literals

```cpp
#include <string>
///hide
#include <iostream>
///unhide

///hide
int main()
{
///unhide
using namespace std::string_literals;
// or using namespace std::literals;

const std::string s1 = "abc\0def";
const std::string s2 = "abc\0def"s;
std::cout << "s1: " << s1.size() << " \"" << s1 << "\"\n";
std::cout << "s2: " << s2.size() << " \"" << s2 << "\"\n";
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="complex_literals" class="aside" data-auto-animate -->

## Library string literals (C++14)

Complex literals

```cpp
#include <complex>
///hide
#include <iostream>
///unhide

///hide
int main()
{
///unhide
using namespace std::complex_literals;
// or using namespace std::literals;

const auto c = 1.0 + 1i;
std::cout << "abs" << c << " = " << abs(c) << '\n';
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="duration_literals" data-auto-animate -->

## Library string literals (C++14)

Chrono literals

```cpp
#include <chrono>
///hide
#include <iostream>
///unhide

///hide
int main()
{
///unhide
using namespace std::chrono_literals;
// or using namespace std::literals;

auto halfmin = 30s;
std::cout 
  << "half a minute is " << halfmin.count() << " seconds\n";
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="ratio" data-background-image="07_chrono/ratio.gif" -->

<div class="footnote">

Source: [The C++ Standard Library: A Tutorial and Reference, Nicolai Josuttis](https://www.informit.com/articles/article.aspx?p=1881386)

</div>

## `std::ratio`

<!-- .element: class="chapter" -->

</script></section><section data-markdown><script type="text/template">
## compile-time rational number

```cpp
///hide
#include <iostream>
///unhide
#include <ratio>

///hide
int main()
{
///unhide
using FiveThirds = std::ratio<5,3>;
std::cout << FiveThirds::num << "/" << FiveThirds::den << '\n';

using AlsoFiveThirds = std::ratio<25,15>;
std::cout << AlsoFiveThirds::num << "/" << AlsoFiveThirds::den << '\n';

using one = std::ratio<42,42>;
std::cout << one::num << "/" << one::den << '\n';

using zero = std::ratio<0>;
std::cout << zero::num << "/" << zero::den << '\n';

using Neg = std::ratio<7,-3>;
std::cout << Neg::num << "/" << Neg::den << '\n';
///hide
}
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## compile-time rational arithmetic

```cpp
///hide
#include <ratio>

///unhide
static_assert(
  std::ratio_equal<
    std::ratio_add<
      std::ratio<1,4>, 
      std::ratio<2,3>
    >::type,
    std::ratio_multiply<
      std::ratio<1, 3>, 
      std::ratio<11, 4>
    >::type
  >::value,
  "rationals FTW"
);
```

</script></section><section data-markdown><script type="text/template">
## compile-time error checks

```cpp
///fails=static assertion failed: overflow in multiplication
///hide
#include <ratio>
#include <limits>

///unhide
std::ratio_multiply<
    std::ratio<1, std::numeric_limits<intmax_t>::max()>,
    std::ratio<1, 2>
>::type; // error: overflow in multiplication

std::ratio_divide<
    std::ratio<1, 2>,
    std::ratio<0>
>::type; // error: denominator cannot be zero
```

</script></section><section data-markdown><script type="text/template">
## predefined ratios

|name|value|name|value|
|----|-----|----|-----|
|`yocto`*|`std::ratio<1, 1000000000000000000000000>`|`deca`|`std::ratio<10, 1>`|
|`zepto`*|`std::ratio<1, 1000000000000000000000>`|`hecto`|`std::ratio<100, 1>`|
|`atto`|`std::ratio<1, 1000000000000000000>`|`kilo`|`std::ratio<1000, 1>`|
|`femto`|`std::ratio<1, 1000000000000000>`|`mega`|`std::ratio<1000000, 1>`|
|`pico`|`std::ratio<1, 1000000000000>`|`giga`|`std::ratio<1000000000, 1>`|
|`nano`|`std::ratio<1, 1000000000>`|`tera`|`std::ratio<1000000000000, 1>`|
|`micro`|`std::ratio<1, 1000000>`|`peta`|`std::ratio<1000000000000000, 1>`|
|`milli`|`std::ratio<1, 1000>`|`exa`|`std::ratio<1000000000000000000, 1>`|
|`centi`|`std::ratio<1, 100>`|`zetta`*|`std::ratio<1000000000000000000000, 1>`|
|`deci`|`std::ratio<1, 10>`|`yotta`*|`std::ratio<1000000000000000000000000, 1>`|

<!-- .element: class="noborder" style="font-size: 0.38em" -->

`*` if `std::intmax_t` can represent the denominator

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## `std::chrono::duration`

```cpp
///hide
#include <ratio>

///unhide
template<
  class Rep,
  class Period = std::ratio<1>
> class duration;
```

</script></section><section data-markdown><script type="text/template">
## predefined durations

|name|literal|value|
|----|-------|-----|
|`std::chrono::nanoseconds`|`ns`|`duration<int_least64_t, std::nano>`|
|`std::chrono::microseconds`|`us`|`duration<int_least55_t, std::micro>`|
|`std::chrono::milliseconds`|`ms`|`duration<int_least45_t, std::milli>`|
|`std::chrono::seconds`|`s`|`duration<int_least35_t>`|
|`std::chrono::minutes`|`min`|`duration<int_least29_t, std::ratio<60>>`|
|`std::chrono::hours`|`h`|`duration<int_least23_t, std::ratio<3600>>`|

<!-- .element: class="noborder" style="font-size: 0.5em" -->

`*` some types can use smaller integers

<!-- .element: class="noborder" style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## conversions

lossless conversions are implicit

```cpp
///hide
#include <chrono>

///unhide
using namespace std::chrono_literals;

std::chrono::milliseconds m = 3s; // 3000ms
std::chrono::nanoseconds n = 5h;  // 18000000000000ns
```

</script></section><section data-markdown><script type="text/template">
## conversions

lossy conversions require `duration_cast` (truncates towards zero)

```cpp
///hide
#include <chrono>

///unhide
using namespace std::chrono_literals;
using namespace std::chrono;

auto s = duration_cast<seconds>(3400ms); // 3s
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="chrono_rounding" -->

## more conversions (C++17)

```cpp
///options=-std=c++17
///hide
#include <chrono>
#include <iostream>

int main() {
///unhide
using namespace std::chrono;

std::cout << floor<seconds>(3600ms).count() << '\n';
std::cout << ceil<seconds>(3400ms).count() << '\n';
std::cout << round<seconds>(3600ms).count() << '\n';
std::cout << round<seconds>(3400ms).count() << '\n';
///hide
}
```

<aside class="notes"><p>Only use an explicit cast when an implicit
conversion won&#39;t work.
If the implicit conversion compiles, it will be exact.
Otherwise it won&#39;t compile and you can make the
decision of which rounding mode you need</p>
</aside></script></section><section data-markdown><script type="text/template">
## mixed arithmetics

like rational arithmetic

```cpp
///hide
#include <chrono>
#include <cassert>

int main() {
///unhide
using namespace std::chrono_literals;

assert(30ms - 1100us == 28900us);
assert(500ms + 2500000us == 3s);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## custom representations

users can use any arithmetics type as the underlying represenations

```cpp
///hide
#include <chrono>
#include <iostream>

int main() {
using namespace std::chrono_literals;
///unhide
using seconds32 = std::chrono::duration<uint32_t>;
using fseconds = std::chrono::duration<float>;

fseconds f = 45ms;
std::cout << f.count() << "s\n"; // 0.045s
///hide
}
```

<aside class="notes"><p><code>duration_cast</code> is not needed on floating point representation.</p>
</aside></script></section><section data-markdown><script type="text/template">
## custom durations

```cpp
///hide
#include <chrono>
#include <iostream>

int main() {
///unhide
using namespace std;

using frames = chrono::duration<int32_t, ratio<1, 60>>;
using fmillis = chrono::duration<float, milli>;

fmillis f = 45ms + frames{5};
std::cout << f.count() << "ms\n"; // 128.333ms
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="07_chrono/second.gif" data-background-size="contain" -->

## `time points and clocks`

<!-- .element: class="chapter" -->

</script></section><section data-markdown><script type="text/template">
## `std::chrono::time_point`

A specific point in time, with respect to some clock, which has a precision of some duration

```cpp
template <
  class Clock, 
  class Duration = typename Clock::duration
> class time_point;
```

</script></section><section data-markdown><script type="text/template">
## clock

a bundle of a duration, a time_point and a static function to get the current time.

```cpp
///hide
#include <chrono>

namespace chrono = std::chrono;

///unhide
struct some_clock
{
  using duration = chrono::duration<int64_t, std::micro>;
  using rep = duration::rep;
  using period = duration::period;
  using time_point = chrono::time_point<some_clock>;

  static constexpr bool is_steady = false;

  static time_point now() noexcept;
};
```

</script></section><section data-markdown><script type="text/template">
## standard clocks

- `std::chrono::system_clock` for wall-clock time (what time of day is it?)
- `std::chrono::steady_clock` for duration measurements

</script></section><section data-markdown><script type="text/template">
## duration vs. time point

`10000s` means **any** 10,000 seconds, but

```cpp
///hide
#include <chrono>

void foo() {
namespace chrono = std::chrono;
using namespace std::chrono_literals;
///unhide
chrono::time_point<chrono::system_clock, chrono::seconds>{10000s};
///hide
}
```

<!-- .element: style="font-size: 0.5em" -->

means 

1970-01-01 02:46:40 UTC

</script></section><section data-markdown><script type="text/template">
## time point conversions

lossless is implicit, lossy with `time_point_cast`

```cpp
///hide
#include <chrono>

using namespace std::chrono_literals;
///unhide
using namespace std::chrono;
template <class D>
using sys_time = time_point<system_clock, D>;

sys_time<milliseconds> tpm = sys_time<seconds>{5s};
sys_time<seconds> tps = time_point_cast<seconds>(tpm);
```

time_points associated with different clocks
**do not** convert to one another.

</script></section><section data-markdown><script type="text/template">
## time point arithmetic

substracting two time points yields a duration

```cpp
///hide
#include <chrono>
#include <iostream>

int main() {
using namespace std::chrono;
using namespace std::chrono_literals;
///unhide
const auto start = steady_clock::now();
system_clock::now();
const auto end = steady_clock::now();
auto d = duration_cast<microseconds>(end - start);
std::cout 
  << "getting time of day took " 
  << d.count() << "us\n";
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="07_chrono/thanks.gif" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="08_error_handling/butt.jpg" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## enum safety

```cpp
///fails=Assertion `isRed(CndRed)' failed
///hide
#include <cassert>

///unhide
enum Color { ClrRed, ClrOrange, ClrYellow, ClrGreen };
enum Alert { CndGreen, CndYellow, CndRed };

bool isRed(Alert alert) {
    return alert == ClrRed;
}

int main(){
    assert(isRed(CndRed)); // oops
}
```


<div class="footnote">

Source: [N2347](wg21.link/n2347)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## enum safety

```cpp []
///options=--short-enums
///fails=static assertion failed
enum Version { Ver1 = 1, Ver2 = 2 };

struct Packet {
 Version ver; // bad, size can vary by implementation
 // … more data …
 Version getVersion() const { return ver; }
};

static_assert(sizeof(Packet) == sizeof(int), "");
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" id="scoped_enums" -->

## scoped enums

```cpp
///hide
#include <cassert>

///unhide
enum class Color { Red, Orange, Yellow, Green };
enum class Alert { Green, Yellow, Red };

bool isRed(Alert alert) {
  // return alert == Color::Red; // doesn't compile
  return alert == Alert::Red;
}

int main(){
  assert(isRed(Alert::Red));
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## sized enums

```cpp [1,9]
///options=--short-enums
enum Version : int { Ver1 = 1, Ver2 = 2 };

struct Packet {
 Version ver; // bad, size can vary by implementation
 // … more data …
 Version getVersion() const { return ver; }
};

static_assert(sizeof(Packet) == sizeof(int), "");
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

C++ Core Guidelines [Enum.3](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#enum3-prefer-class-enums-over-plain-enums): Prefer class enums over "plain" enums

</script></section><section data-markdown><script type="text/template">
<!-- .slide: -->

## let's fly

![flights](08_error_handling/flights.svg)

<!-- .element: class="r-stretch" -->

<div class="footnote">

Source: [Andrzej's C++ blog](https://akrzemi1.wordpress.com/2017/09/04/using-error-codes-effectively/)

</div>

</script></section><section data-markdown><script type="text/template">
## different error codes

<!-- .slide: -->

```cpp
enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};


enum class Flights1Errc
{
  // no 0
  ZeroFlightsFound     = 11,
  InvalidRequestFormat = 12,
  CouldNotConnect      = 13,
  DatabaseError        = 14,
  NotEnoughMemory      = 15,
  InternalError        = 16,
  NoSuchAirport        = 17,
  JourneyInThePast     = 18,
  DatesNotMonotonic    = 19,
};

enum class SeatsErrc
{
  // no 0
  InvalidRequest = 1,
  CouldNotConnect,
  InternalError,
  NoResponse,
  NonexistentClass,
  NoSeatAvailable,
};


```

<!-- .element: class="split" style="column-count: 3" -->

</script></section><section data-markdown><script type="text/template">
## error source

1. User sent us an illogical request.
2. There is some problem with the system which the user will not understand but which prevents us from returning the requested answer.
3. No airline we are aware of is able to offer a requested trip.

</script></section><section data-markdown><script type="text/template">
## error severty

1. A bug.
2. An incorrect configuration.
3. A (perhaps temporary) shortage of resources.
4. Normal (like “no solutions found”) — user may be disappointed, but developers or the system did nothing wrong.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="08_error_handling/fixedit.gif" -->

# error handling

<!-- .element: class="chapter" -->

</script></section><section data-markdown><script type="text/template">
## `std::error_category`

A base class for error domains.

```cpp
///hide
#include <string>

///unhide
namespace std {
  class error_category {
  public:
    virtual const char* name() const noexcept = 0;
    virtual string message(int ev) const = 0;
    // other functions
  };
}
```

</script></section><section data-markdown><script type="text/template">
## defining a category

```cpp [1,3-4,18,21|4-7|9-17|20]
#include <system_error>
///hide
enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};
///unhide
 
namespace {
struct Flights0ErrCategory : std::error_category {
  const char* name() const noexcept override {
    return "flights0";
  }

  std::string message(int ev) const override {
    switch (static_cast<Flights0Errc>(ev))
    {
    case Flights0Errc::NonexistentLocations: return "nonexistent airport name in request";
    case Flights0Errc::DatesInThePast: return "request for a date from the past";
    /// etc.
    default: return "(unrecognized error)";
    }
  }
};
 
const Flights0ErrCategory flights0ErrCategory;
} // namespace
```

<!-- .element: style="font-size: 0.35em" -->

`flights0.cpp`

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="error_code" -->

## `std::error_code`

Error number and category.

```cpp [2,4,11-12|13-14|5-10]
///hide
#include <type_traits>
#include <string>

namespace std {
template<typename>
struct is_error_code_enum : std::false_type {};
}

class error_category;

///unhide
namespace std {
  class error_code {
  public:
    error_code(int val, const error_category& cat) noexcept;
    template<class ErrorCodeEnum, 
             typename = std::enable_if_t<
                          std::is_error_code_enum<
                            ErrorCodeEnum
                          >::value>>
      error_code(ErrorCodeEnum e) noexcept;
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;
    // other members
  };
}
```

<!-- .element: style="font-size: 0.45em" -->

<aside class="notes"><p><code>operator bool()</code> returns <code>value() != 0</code></p>
</aside></script></section><section data-markdown><script type="text/template">
## defining an error code

<div class="grid2">

```cpp [1|3-14|16-22|24]
# include <system_error>

enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};

namespace std
{
  template <>
  struct is_error_code_enum<Flights0Errc> 
    : true_type 
  {};
}

std::error_code make_error_code(Flights0Errc);
```

<!-- .element: data-fragment-index="0" -->

```cpp [0|0|0|1-4]
///hide
#include <system_error>

enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};

namespace std
{
  template <> struct 
  is_error_code_enum<Flights0Errc> 
  : true_type {};
}

struct Flights0ErrCategory : std::error_category {
  const char* name() const noexcept override {
    return "flights0";
  }

  std::string message(int ev) const override {
    return {};
  }

};
const Flights0ErrCategory flights0ErrCategory;

///unhide
std::error_code make_error_code(Flights0Errc e) {
  return {static_cast<int>(e), 
          flights0ErrCategory};
}
```

<!-- .element: data-fragment-index="0" -->

`flights0.hpp`

`flights0.cpp`

</div>

<aside class="notes"><p>similarly for <code>Flights1Errc</code> and <code>SeatsErrc</code></p>
</aside></script></section><section data-markdown><script type="text/template">
## using `std::error_code`

```cpp 
///hide
#include <system_error>
#include <iostream>
#include <cassert>

enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};

namespace std
{
  template <> struct 
  is_error_code_enum<Flights0Errc> 
  : true_type {};
}

namespace {
struct Flights0ErrCategory : std::error_category {
  const char* name() const noexcept override {
    return "flights0";
  }

  std::string message(int ev) const override {
    switch (static_cast<Flights0Errc>(ev))
    {
    case Flights0Errc::NonexistentLocations: return "nonexistent airport name in request";
    case Flights0Errc::DatesInThePast: return "request for a date from the past";
    /// etc.
    default: return "(unrecognized error)";
    }
  }
};
 
const Flights0ErrCategory flights0ErrCategory;
} // namespace

std::error_code make_error_code(Flights0Errc e) {
  return {static_cast<int>(e), 
          flights0ErrCategory};
}

#if 0
///unhide
#include "flights0.hpp"
///hide
#endif
///unhide

int main()
{
  std::error_code ec = Flights0Errc::DatesInThePast;
  std::cout << ec << ": " << ec.message() << '\n';
  assert(ec == Flights0Errc::DatesInThePast);
  assert(ec != Flights0Errc::InvertedDates);
}
```

</script></section><section data-markdown><script type="text/template">
## combining system errors

```cpp
enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="error_condition" -->

## `std::error_condition`

```cpp
///hide
#include <type_traits>
#include <string>

namespace std {
template<typename>
struct is_error_condition_enum : std::false_type {};
}

class error_category;

///unhide
namespace std {
  class error_condition {
  public:
    error_condition(int val, const error_category& cat) noexcept;
    template<class ErrorConditionEnum, 
             typename = std::enable_if_t<
                          std::is_error_condition_enum<
                            ErrorConditionEnum
                          >::value>>
      error_condition(ErrorConditionEnum e) noexcept;
    int value() const noexcept;
    const error_category& category() const noexcept;
    std::string message() const;
    explicit operator bool() const noexcept;
    // other members
  };
}
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## what's the difference?

- **`error_code`** is used for storing and transmitting error codes as they were produced by originating library, unchanged;
- **`error_condition`** is used for performing queries on `error_code`s, for the purpose of grouping or classification or translation.

</script></section><section data-markdown><script type="text/template">
### using `std::error_condition`

<div class="grid2">

```cpp []
# include <system_error>
 
enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};

namespace std
{
  template <>
  struct is_error_condition_enum<SubsystemError> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (SubsystemError e);
```

<!-- .element: style="font-size: 0.3em" -->

```cpp []
///hide
# include <system_error>
 
enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};

namespace std
{
  template <>
  struct is_error_condition_enum<SubsystemError> 
  : true_type {};
}
#if 0
///unhide
#include "subsystem.hpp"
///hide
#endif
///unhide

namespace {
 
class SubsystemErrorCategory 
  : public std::error_category {
public:
  const char* name() const noexcept override {
    return "submodule-error";
  }
  std::string message(int ev) const override {
    switch (static_cast<SubsystemError>(ev)) {
      /// all messages
      default: return "(uncharted)";
    }
  }
};
 
const SubsystemErrorCategory 
  theSubsystemErrorCategory {};
  
}

std::error_condition make_error_condition
  (SubsystemError e) {
  return {static_cast<int>(e), 
          theSubsystemErrorCategory};
}
```

<!-- .element: style="font-size: 0.3em" -->

`subsystem.hpp`

`subsystem.cpp`

</div>

</script></section><section data-markdown><script type="text/template">
## mapping `error_code` to `error_condition`

```cpp [3,6-20]
///hide
#include <system_error>
#include <cassert>
#include <iostream>

enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};

namespace std
{
  template <> struct 
  is_error_code_enum<Flights0Errc> 
  : true_type {};
}

enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};

namespace std
{
  template <>
  struct is_error_condition_enum<SubsystemError> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (SubsystemError e);
///unhide
namespace {

struct Flights0ErrCategory : std::error_category {
  const char* name() const noexcept override;
  std::string message(int ev) const override;
  std::error_condition default_error_condition(int ev)
    const noexcept override {
    switch (static_cast<Flights0Errc>(ev))
    {
    case Flights0Errc::NonexistentLocations: return SubsystemError::InputBadAirport;
    case Flights0Errc::DatesInThePast: return SubsystemError::InputPastDate;
    case Flights0Errc::InvertedDates: return SubsystemError::InputBadDateRange;
    case Flights0Errc::NoFlightsFound: return SubsystemError::NoFlightFound;
    case Flights0Errc::ProtocolViolation: return SubsystemError::SubsysProtocolErr;
    case Flights0Errc::ConnectionError: return SubsystemError::SubsysConfig;
    case Flights0Errc::ResourceError: return SubsystemError::SubsysResource;
    case Flights0Errc::Timeout: return SubsystemError::SubsysTimeout;
    default: assert (false); return {};
    }
  }
};
 
}
```

<!-- .element: style="font-size: 0.35em" -->

`flights0.cpp`

<aside class="notes"><p>similarly for <code>Flights1Errc</code> and <code>SeatsErrc</code></p>
</aside></script></section><section data-markdown><script type="text/template">
## low level query

```cpp
///hide
#include <system_error>
#include <iostream>

enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};

namespace std
{
  template <> struct 
  is_error_code_enum<Flights0Errc> 
  : true_type {};
}

std::error_code make_error_code(Flights0Errc);

enum class SeatsErrc
{
  // no 0
  InvalidRequest = 1,
  CouldNotConnect,
  InternalError,
  NoResponse,
  NonexistentClass,
  NoSeatAvailable,
};

namespace std
{
  template <> struct 
  is_error_code_enum<SeatsErrc> 
  : true_type {};
}

std::error_code make_error_code(SeatsErrc);

enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};

namespace std
{
  template <>
  struct is_error_condition_enum<SubsystemError> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (SubsystemError e);

///unhide
void handle_error(std::error_code ec) {
  if (ec == SubsystemError::InputPastDate) {
      std::cerr << "please entry future date\n";
  } else if (ec == SubsystemError::InputBadDateRange) {
      std::cerr << "return date is before departure\n";
  }
  /// handle other cases 
}

///hide
void foo() {
///unhide
handle_error(Flights0Errc::DatesInThePast);
handle_error(SeatsErrc::NonexistentClass);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## how does this work

```cpp
///hide
#include <system_error>

using namespace std;

///unhide
bool operator==(const error_code& lhs, 
                const error_condition& rhs) noexcept {
  return lhs.category().equivalent(lhs.value(), rhs) ||
         rhs.category().equivalent(lhs, rhs.value());
}

class error_category {
///hide
  std::error_condition default_error_condition(int ev) const;

  bool operator==( const std::error_category& rhs ) const noexcept;

///unhide
  virtual bool equivalent(int code, 
                          const error_condition& cond) 
                          const noexcept {
    return default_error_condition(code) == cond;
  }

  virtual bool equivalent(const error_code& code, 
                          int cond) 
                          const noexcept {
    return *this == code.category() && code.value() == cond;
  }
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## going to a higher level

<div class="grid2">

```cpp []
#include <system_error>

enum class FailureSource
{
  // no 0
  BadUserInput = 1,
  SystemError,
  NoSolution,

};
  
namespace std
{
  template <>
  struct is_error_condition_enum<FailureSource> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (FailureSource e);
```

```cpp []
#include <system_error>

enum class Severity
{
  // no 0
  Bug = 1,
  Config,
  Resource,
  Normal,
};
  
namespace std
{
  template <>
  struct is_error_condition_enum<Severity> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (Severity e);
```

`failure_source.hpp`

`severity.hpp`

</div>

</script></section><section data-markdown><script type="text/template">
## mapping low to high

```cpp
///hide
#include <system_error>

enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};

namespace std
{
  template <>
  struct is_error_condition_enum<SubsystemError> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (SubsystemError e);

enum class Severity
{
  // no 0
  Bug = 1,
  Config,
  Resource,
  Normal,
};
  
namespace std
{
  template <>
  struct is_error_condition_enum<Severity> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (Severity e);

///unhide
class SeverityCategory : public std::error_category {
public:
  bool equivalent(const std::error_code& ec, int cond) const noexcept override {     
    switch (static_cast<Severity>(cond)) {
    case Severity::Bug: return ec == SubsystemError::SubsysProtocolErr
                            || ec == SubsystemError::SubsysInternal;
          
    case Severity::Config: return ec == SubsystemError::SubsysConfig;
  
    case Severity::Resource: return ec == SubsystemError::SubsysResource        
                                 || ec == SubsystemError::SubsysTimeout;
          
    case Severity::Normal: return ec == SubsystemError::InputBadAirport
                               || ec == SubsystemError::InputPastDate
                               || ec == SubsystemError::InputBadDateRange
                               || ec == SubsystemError::InputBadClass
                               || ec == SubsystemError::NoFlightFound
                               || ec == SubsystemError::NoSeatFound;
                
    default: return false;
    }
  }
};
```

<!-- .element: style="font-size: 0.35em" -->

`severity.cpp`

</script></section><section data-markdown><script type="text/template">
## high level query

```cpp
///hide
#include <system_error>
#include <cassert>
#include <iostream>

enum class Flights0Errc
{
  // no 0
  NonexistentLocations = 10,
  DatesInThePast,
  InvertedDates,
  NoFlightsFound       = 20,
  ProtocolViolation    = 30,
  ConnectionError,
  ResourceError,
  Timeout,
};

namespace std
{
  template <> struct 
  is_error_code_enum<Flights0Errc> 
  : true_type {};
}

std::error_code make_error_code(Flights0Errc);

enum class SubsystemError
{
    // no 0
    InputBadAirport = 1,
    InputPastDate,
    InputBadDateRange,
    InputBadClass,
    NoFlightFound,
    NoSeatFound,
    SubsysProtocolErr,
    SubsysInternal,
    SubsysResource,
    SubsysConfig,
    SubsysTimeout,
};

namespace std
{
  template <>
  struct is_error_condition_enum<SubsystemError> 
  : true_type {};
}

enum class Severity
{
  // no 0
  Bug = 1,
  Config,
  Resource,
  Normal,
};
  
namespace std
{
  template <>
  struct is_error_condition_enum<Severity> 
  : true_type {};
}
  
std::error_condition make_error_condition
  (Severity e);

///unhide
void handle_error(std::error_code ec) {
  if (ec == Severity::Bug) {
      assert(false);
      std::cerr << "BUG BUG BUG\n";
  } else if (ec == Severity::Config) {
      std::cerr << "configuration error: " << ec << "\n";
  } else if (ec == Severity::Resource) {
      std::cout << "Please try again in a few minutes\n";
  } else {
    assert(ec == Severity::Normal);
  }
}

///hide
void foo() {
///unhide
handle_error(Flights0Errc::DatesInThePast);
///hide
}
``` 

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
# system agnostic failure handling

![error mapping](08_error_handling/error_mapping.svg)

 <!-- .element: class="r-stretch" --> 

- Adding an additional subsystem will only require mappign to `SubsystemError` without affecting the rest of the system. 
- Adding high level queries is easy.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="08_error_handling/aha.gif" -->

## In the standard library

<!-- .element: class="chapter bottom" -->

</script></section><section data-markdown><script type="text/template">
## `std::system_error`

Thrown by various library functions with an associated `std::error_code`.

```cpp
///hide
#include <iostream>
#include <fstream>
 
int main() {
///unhide
try {
  std::ifstream in;
  in.exceptions(std::ifstream::failbit);
  in.open("no such file");
} catch (const std::system_error& ex) {
  std::cerr << "got ec " << ex.code() 
            << ": " << ex.what() << '\n';
}
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## OS `error_condition`

based on posix errors

```cpp []
///hide
#include <type_traits>
namespace std {
template<typename> struct is_error_condition_enum;
struct error_condition {
  error_condition(int, int);
};
int generic_error();
}

///unhide
namespace std {

enum class errc {
    broken_pipe,                        // EPIPE
    invalid_argument,                   // EINVAL
    operation_not_permitted,            // EPERM
    permission_denied,                  // EACCES
    /// etc.
};

template<> struct is_error_condition_enum<errc> : true_type {};

error_condition make_error_condition(errc e) noexcept {
  return {static_cast<int>(e), generic_error()};
}

}
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## `std::system_category`

Should be used by library implementers to report OS errors.

```cpp
///external
///compiler=vcpp_v19_24_x64
///hide
#include <Windows.h>
#include <string>
#include <system_error>

///unhide
std::string read_file(const char *path) {
  HANDLE file = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ, nullptr,
                            OPEN_EXISTING, 0, nullptr);
  if (file == INVALID_HANDLE_VALUE) {
    throw std::system_error(GetLastError(), std::system_category());
  }

  auto size = GetFileSize(file, nullptr);

  std::string str;
  str.resize(size);

  DWORD read = 0;
  if (!ReadFile(file, &str.front(), size, &read, nullptr)) {
    throw std::system_error(GetLastError(), std::system_category());
  }

  return str;
}
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::excpetion_ptr`

A shared-ownership smart pointer that manages an exception object, and may be passed to another function, possibly on another thread.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate id="exception_ptr" -->

## `std::excpetion_ptr`

```cpp [12-17|1-9,18]
///hide
#include <iostream>
#include <string>
#include <exception>
#include <stdexcept>

///unhide
void handle_eptr(std::exception_ptr eptr) { // passing by value is ok
  try {
    if (eptr) {
      std::rethrow_exception(eptr);
    }
  } catch(const std::exception& e) {
    std::cout << "Caught exception \"" << e.what() << "\"\n";
  }
}
 
int main() {
    std::exception_ptr eptr;
    try {
        std::string().at(1); // this generates an std::out_of_range
    } catch(...) {
        eptr = std::current_exception(); // capture
    }
    handle_eptr(eptr);
} // destructor for std::out_of_range called here, when the eptr is destructed
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="08_error_handling/wink.gif" data-background-size="contain" -->

## thank you

<!-- .element: class="chapter bottom" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="09_concurrency/martial.jpg" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="concurrency" data-background-image="09_concurrency/speed.webp" -->

<div class="footnote">

Source: [C++ Concurrency in Action, Anthony Williams](https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition)

</div>

# Concurrency

<!-- .element: class="chapter" -->

<aside class="notes"><p>Until C++11 came the standard didn&#39;t acknowledge the existence of multithreaded applications. But since then there were many additions to support concurrent programming.</p>
</aside></script></section><section data-markdown><script type="text/template">
## hello `std::thread`

```cpp
///compiler=clang600
///options=-pthread
#include <iostream>
#include <thread>

int main()
{
    std::thread t([]{
      std::cout<<"Hello Concurrent World\n";
    });
    t.join();
}
```

<aside class="notes"><p>forgetting to join with terminate the program</p>
</aside></script></section><section data-markdown><script type="text/template">
## on exception


```cpp [1-3,10-11,16-23]
///compiler=clang600
///options=-pthread
///hide
#include <iostream>
#include <thread>
#include <stdexcept>

///unhide
void can_throw() {
    throw std::runtime_error("error");
}

void foo()
{
    std::thread t([]{
      std::cout<<"Hello Concurrent World\n";
    });
    can_throw();
    t.join();
}

int main()
{
  try {
    foo();
  } catch (const std::exception& ex) {
    std::cerr 
      << "got exception: " 
      << ex.what() 
      << '\n';
  }
}


```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## catch that


```cpp [10-16]
///compiler=clang600
///options=-pthread
///hide
#include <iostream>
#include <thread>
#include <stdexcept>

///unhide
void can_throw() {
    throw std::runtime_error("error");
}

void foo()
{
    std::thread t([]{
      std::cout<<"Hello Concurrent World\n";
    });
    try {
      can_throw();
    } catch(...) {
      t.join();
      throw;
    }
    t.join();
}

int main()
{
  try {
    foo();
  } catch (const std::exception& ex) {
    std::cerr 
      << "got exception: " 
      << ex.what() 
      << '\n';
  }
}






```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## RAII style

```cpp
///hide
#include <thread>

///unhide
class thread_joiner
{
public:
    explicit thread_joiner(std::thread& thread)
      : m_thread{thread}
    {}
    ~thread_joiner()
    {
      if(m_thread.joinable())
      {
        m_thread.join();
      }
    }
private:
    std::thread& m_thread;
};
```

<!-- .element: style="font-size: 0.5em" -->

<aside class="notes"><p>checking <code>joinable()</code> is important because <code>join()</code> will fail if the thread had already been joined</p>
</aside></script></section><section data-markdown><script type="text/template">
## use joiner

```cpp [7-11]
///compiler=clang600
///options=-pthread
///hide
#include <iostream>
#include <thread>
#include <stdexcept>

class thread_joiner
{
public:
    explicit thread_joiner(std::thread& thread)
      : m_thread{thread}
    {}
    ~thread_joiner()
    {
      if(m_thread.joinable())
      {
        m_thread.join();
      }
    }
private:
    std::thread& m_thread;
};

///unhide
void can_throw() {
    throw std::runtime_error("error");
}

void foo()
{
    std::thread t([]{
      std::cout<<"Hello Concurrent World\n";
    });
    thread_joiner joiner{t};
    can_throw();
}

int main()
{
  try {
    foo();
  } catch (const std::exception& ex) {
    std::cerr 
      << "got exception: " 
      << ex.what() 
      << '\n';
  }
}


```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## document editor

![word tabs](09_concurrency/word_tabs.png)

<aside class="notes"><p>We run each document-editing window in its own thread. Opening a new document therefore requires starting a new thread. The thread handling the request isn’t going to care about waiting for that other thread to finish, because it’s working on an unrelated document, so this makes it a prime candidate for running a detached thread.</p>
</aside></script></section><section data-markdown><script type="text/template">
## `detach` and passing arguments

```cpp [1-4,12-17]
///hide
#include <string>
#include <thread>

///unhide
enum class user_command
{
  open_new_document
};

///hide
void open_document_and_display_gui(const std::string);
bool done_editing();
user_command get_user_input();
std::string get_filename_from_user();
void process_user_input(user_command);

///unhide
void edit_document(const std::string& filename)
{
    open_document_and_display_gui(filename);
    while(!done_editing())
    {
        const auto cmd = get_user_input();
        if(cmd == user_command::open_new_document)
        {
            const auto new_name = get_filename_from_user();
            std::thread t(edit_document, new_name);
            t.detach();
        }
        else
        {
            process_user_input(cmd);
        }
    }
}
```

<!-- .element: style="font-size: 0.35em" -->

</script></section><section data-markdown><script type="text/template">
## lvalue reference?

```cpp []
///fails=std::thread arguments must be invocable after conversion to rvalues
///hide
#include <thread>
#include <fstream>

///unhide
void readFile(int& i) {
  std::fstream f{"input.txt"};
  f >> i;
}

///hide
void use() {
///unhide
int i;
std::thread t{readFile, i};
t.join();
///hide
}
```

<!-- .element: style="font-size: 0.35em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `std::reference_wrapper`

a copyable, assignable reference

```cpp
///hide
#include <iostream>
///unhide
#include <functional>

///hide
int main() {
///unhide
int x = 10, y = 20;
std::reference_wrapper<int> ref = x;
// ref = 15; // doesn't compile
x = 15;
std::cout << ref << '\n'; // prints 15
ref = y; // now bound to y
int& yy = ref;
yy = 25;
std::cout << y << '\n'; // prints 25
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `std::ref`, `std::cref`

```cpp
///hide
#include <type_traits>
///unhide
#include <functional>

///hide
int main() {
///unhide
int x = 10;

auto xref = std::ref(x);
static_assert(std::is_same<decltype(xref), 
  std::reference_wrapper<int>>::value,
  "non const");

auto cxref = std::cref(x);
static_assert(std::is_same<decltype(cxref), 
  std::reference_wrapper<const int>>::value,
  "const");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## counting sort comparisons

```cpp
///hide
#include <algorithm>
#include <functional>
#include <iostream>
#include <numeric>
#include <vector>

///unhide
struct counting_less {
  template<typename T> 
  bool operator()(const T& x, const T& y) {
    ++count;
    return x < y;
  }

  int count = 0;
};

///hide
int main() {
///unhide
std::vector<int> elements{5, 3, 7, 2, 0};
counting_less cl;
std::sort(elements.begin(), elements.end(), cl);
std::cout << cl.count << " comparisons in sort\n";
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## back to `thread`

```cpp [7]
///hide
#include <thread>
#include <fstream>

///unhide
void readFile(int& i) {
  std::fstream f{"input.txt"};
  f >> i;
}

///hide
void use() {
///unhide
int i;
std::thread t{readFile, std::ref(i)};
t.join();
///hide
}
```

<!-- .element: style="font-size: 0.35em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" id="next_prev" -->

## generic iterator traversal

before:

```cpp
template<typename Iterator>
auto get_3rd_from(Iterator it) ->decltype(*it) {
  return *(++(++(++it)));
}
```

after:

```cpp
#include <iterator>

template<typename Iterator>
auto get_3rd_to_last(Iterator it) ->decltype(*it) {
  return *std::next(it, 3);
}
```

</script></section><section data-markdown><script type="text/template">
## owning `thread_joiner`

```cpp [4-5,14-17,19]
///hide
#include <thread>

///unhide
class thread_joiner
{
public:
    explicit thread_joiner(std::thread thread)
      : m_thread{std::move(thread)}
    {}
    ~thread_joiner() {
      if(m_thread.joinable())
      {
        m_thread.join();
      }
    }
    thread_joiner(const thread_joiner&) = delete;
    thread_joiner(thread_joiner&&) = default;
    thread_joiner& operator=(const thread_joiner&) = delete;
    thread_joiner& operator=(thread_joiner&&) = default;
private:
    std::thread m_thread;
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## parallel accumulate

```cpp [1-2|3-4|6-10|12-16|19-23,28|24-27|30|33|37-40]
///compiler=clang600
///options=-pthread
///hide
#include <thread>
#include <numeric>
#include <algorithm>
#include <vector>
#include <iostream>

class thread_joiner
{
public:
    explicit thread_joiner(std::thread thread)
      : m_thread{std::move(thread)}
    {}
    ~thread_joiner()
    {
      if(m_thread.joinable())
      {
        m_thread.join();
      }
    }
    thread_joiner(const thread_joiner&) = delete;
    thread_joiner(thread_joiner&&) = default;
    thread_joiner& operator=(const thread_joiner&) = delete;
    thread_joiner& operator=(thread_joiner&&) = default;
private:
    std::thread m_thread;
};

///unhide
template <typename Iterator, typename T, size_t MIN_PER_THREAD = 25>
T parallel_accumulate(Iterator first, Iterator last, T init) {
  const auto length = std::distance(first, last);
  if (!length) return init;

  const auto max_threads = (length + MIN_PER_THREAD - 1) / MIN_PER_THREAD;
  const auto hardware_threads = std::thread::hardware_concurrency();
  const auto num_threads =
      std::min<size_t>(hardware_threads != 0 ? hardware_threads : 2, 
                       max_threads);

  const auto block_size = length / num_threads;
  std::vector<T> results(num_threads);
  const auto accumulator = [](Iterator first, Iterator last, T& result) {
      result = std::accumulate(first, last, 0);
  };

  {
    std::vector<thread_joiner> threads;
    auto block_start = first;
    std::transform(results.begin(), std::prev(results.end()), 
                   std::back_inserter(threads), 
                   [&](T& result){
        const auto block_end = std::next(block_start, block_size);
        std::thread t{accumulator, block_start, block_end, std::ref(result)};
        block_start = block_end;
        return thread_joiner{std::move(t)};
    });

    accumulator(block_start, last, results.back());
  }
  
  return std::accumulate(results.begin(), results.end(), init);
}

int main() {
    std::vector<int64_t> v(10000);
    std::iota(v.begin(), v.end(), 1);

    std::cout << parallel_accumulate(v.begin(), v.end(), 0) << '\n';
}
```

<!-- .element: "style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="09_concurrency/sharing.gif" -->

## data sharing

<!-- .element: class="chapter bottom" -->

<aside class="notes"><p>As opposed to multi-process program, it is much easier to share data between different threads but that of course opens the door to data races. Let&#39;s see what tools we have to address this issue.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## protecting with a `mutex`

```cpp [4,8,10,15,18]
///hide
#include <list>
#include <algorithm>
///unhide
#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    some_mutex.lock();
    some_list.push_back(new_value);
    some_mutex.unlock();
}

bool list_contains(int value_to_find)
{
    some_mutex.lock();
    return std::find(some_list.begin(), some_list.end(), value_to_find)
        != some_list.end();
    some_mutex.unlock();
}
```

<!-- .element: data-id="code" style="font-size:0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## RAII with a `lock_guard`

```cpp [4,8,14]
///hide
#include <list>
#include <algorithm>
///unhide
#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    some_list.push_back(new_value);
}

bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    return std::find(some_list.begin(), some_list.end(), value_to_find)
        != some_list.end();
}
```

<!-- .element: data-id="code" style="font-size:0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## locking multiple mutexes

```cpp [8-14|18-20]
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <thread>
#include <vector>

///unhide
class X
{
private:
    std::vector<int> vec;
    std::mutex m;
public:
    X(const std::vector<int>& vec): vec{vec} {}
    friend void swap(X& lhs, X& rhs)
    {
        if(&lhs==&rhs) return;
        std::lock_guard<std::mutex> lock_a{lhs.m};
        std::lock_guard<std::mutex> lock_b{rhs.m};
        std::swap(lhs.vec, rhs.vec);
    }
};

///hide
int main() {
std::vector<int> i1, i2; 
///unhide
X x1{i1}, x2{i2};
std::thread t1{[&]{ swap(x1, x2); }};
std::thread t2{[&]{ swap(x2, x1); }};
///hide
t1.join();
t2.join();
}
```

<!-- .element: data-id="code2" style="font-size:0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## use `std::lock`

```cpp [11-13]
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <thread>
#include <vector>

///unhide
class X
{
private:
    std::vector<int> vec;
    std::mutex m;
public:
    X(const std::vector<int>& vec): vec{vec} {}
    friend void swap(X& lhs, X& rhs)
    {
        if(&lhs==&rhs) return;
        std::lock(lhs.m, rhs.m);
        std::lock_guard<std::mutex> lock_a{lhs.m, std::adopt_lock};
        std::lock_guard<std::mutex> lock_b{rhs.m, std::adopt_lock};
        std::swap(lhs.vec, rhs.vec);
    }
};

///hide
int main() {
std::vector<int> i1, i2; 
///unhide
X x1{i1}, x2{i2};
std::thread t1{[&]{ swap(x1, x2); }};
std::thread t2{[&]{ swap(x2, x1); }};
///hide
t1.join();
t2.join();
}
```

<!-- .element: data-id="code2" style="font-size:0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="scoped_lock" data-auto-animate -->

## use `std::scoped_lock` (C++17)

```cpp [11]
///compiler=clang600
///options=-std=c++17 -pthread
///hide
#include <mutex>
#include <thread>
#include <vector>

///unhide
class X
{
private:
    std::vector<int> vec;
    std::mutex m;
public:
    X(const std::vector<int>& vec): vec{vec} {}
    friend void swap(X& lhs, X& rhs)
    {
        if(&lhs==&rhs) return;
        std::scoped_lock<std::mutex,std::mutex> guard{lhs.m, rhs.m};
        std::swap(lhs.vec, rhs.vec);
    }
};

///hide
int main() {
std::vector<int> i1, i2; 
///unhide
X x1{i1}, x2{i2};
std::thread t1{[&]{ swap(x1, x2); }};
std::thread t2{[&]{ swap(x2, x1); }};
///hide
t1.join();
t2.join();
}
```

<!-- .element: data-id="code2" style="font-size:0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## or use `std::unique_lock`

```cpp [11-13]
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <thread>
#include <vector>

///unhide
class X
{
private:
    std::vector<int> vec;
    std::mutex m;
public:
    X(const std::vector<int>& vec): vec{vec} {}
    friend void swap(X& lhs, X& rhs)
    {
        if(&lhs==&rhs) return;
        std::unique_lock<std::mutex> lock_a{lhs.m,std::defer_lock};
        std::unique_lock<std::mutex> lock_b{rhs.m,std::defer_lock};
        std::lock(lock_a,lock_b);
        std::swap(lhs.vec, rhs.vec);
    }
};

///hide
int main() {
std::vector<int> i1, i2; 
///unhide
X x1{i1}, x2{i2};
std::thread t1{[&]{ swap(x1, x2); }};
std::thread t2{[&]{ swap(x2, x1); }};
///hide
t1.join();
t2.join();
}
```

<!-- .element: data-id="code2" style="font-size:0.4em" -->

<aside class="notes"><p><code>unique_lock</code> has more features than <code>lock_guard</code> but is also more expensive.</p>
</aside></script></section><section data-markdown><script type="text/template">
## transferring mutex ownership

```cpp [1-2,20,21|4-17|24-31]
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <vector>
#include <thread>

///unhide
template<typename T>
class Synchronized {
public:
    struct Locked {
      std::unique_lock<std::mutex> m_lock;
      T* m_data;

      Locked(std::mutex& mutex, T& data)
        : m_lock{mutex}
        , m_data{&data}
      {}

      T* operator->() { return m_data; }
    };
    Locked operator->() {
        return {m_mutex, m_data};
    }

private:
    std::mutex m_mutex;
    T m_data;
};
int main() {
    Synchronized<std::vector<int>> pv;
    auto foo = [&pv]{
        pv->push_back(42);
    };
    std::thread t1{foo}, t2{foo};
    t1.join();
    t2.join();
    return pv->size();
}











```

<!-- .element: class="split" -->

<aside class="notes"><p>proposed for standardization in <a href="wg21.link/n4033">n4033</a></p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## single threaded lazy initialization

```cpp []
///hide
#include <memory>

struct Resource {
  void doSomething();
};

///unhide
std::unique_ptr<Resource> pResource;

void foo() {
  if(!pResource) {
    pResource.reset(new Resource);
  }
  pResource->doSomething();
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## multi-threaded lazy initialization

```cpp []
///hide
#include <memory>
#include <mutex>

struct Resource {
  void doSomething();
};

///unhide
std::unique_ptr<Resource> pResource;
std::mutex resourceMutex;

void foo() {
  {
    std::lock_guard<std::mutex> lk(resourceMutex);
    if(!pResource) {
      pResource.reset(new Resource);
    }
  }
  pResource->doSomething();
}
```

<!-- .element: data-id="code" -->

<aside class="notes"><p>causes serialization of threads using the resource</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## double-checked locking pattern

```cpp []
///hide
#include <memory>
#include <mutex>

struct Resource {
  void doSomething();
};

///unhide
std::unique_ptr<Resource> pResource;
std::mutex resourceMutex;

void foo() {
  if(!pResource) {
    std::lock_guard<std::mutex> lk(resourceMutex);
    if(!pResource) {
      pResource.reset(new Resource);
    }
  }
  pResource->doSomething();
}
```

<!-- .element: data-id="code" -->

<aside class="notes"><p>there&#39;s a possiblity for a race condition if the compiler reorders the code on line 11 to first set the pointer to be non-empty before completely constructing the resource.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## use `std::call_once`

```cpp [2,5-7]
///hide
#include <memory>
#include <mutex>

struct Resource {
  void doSomething();
};

///unhide
std::unique_ptr<Resource> pResource;
std::once_flag resourceFlag;

void foo() {
  std::call_once(resourceFlag, []{
    pResource.reset(new Resource);
  });
  pResource->doSomething();
}
```

<!-- .element: data-id="code" -->

<aside class="notes"><p><code>std::call_once</code> will typically have a lower overhead than using a mutex explicitly, especially when the initialization has already been done</p>
</aside></script></section><section data-markdown><script type="text/template">
## safe static init

```cpp []
///hide
struct Resource {
  void doSomething();
};

///unhide
void foo()
{
  static Resource resource;
  resource.doSomething();
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="shared_lock" -->

## read write mutex (C++17)

```cpp [1,5-6,11-13,18]
///options=-std=c++17
///hide
#include <map>
#include <string>
#include <mutex>
///unhide
#include <shared_mutex>

///hide
class DnsEntry {};

///unhide
class DnsCach {
public:
  const DnsEntry* findEntry(const std::string& domain) const {
    std::shared_lock<std::shared_mutex> lk(m_entryMutex);
    const auto it = m_entries.find(domain);
    return (it == m_entries.end()) ? nullptr : &it->second;
  }

  void update_or_add_entry(const std::string& domain,
                           const DnsEntry& dns_details) {
    std::unique_lock<std::shared_mutex> lk(m_entryMutex);
    m_entries[domain] = dns_details;
  }
private:
  std::map<std::string, DnsEntry> m_entries;
  mutable std::shared_mutex m_entryMutex;
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## can't lock mutex multiple times

```cpp
///hide
#include <mutex>

///unhide
struct C {
  void func1() {
    std::lock_guard<std::mutex> lock{m_mutex};
    // do work
  }

  void func2() {
    std::lock_guard<std::mutex> lock{m_mutex};
    // do work
    func1();
    // do more work
  }

  std::mutex m_mutex;
};
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## use `std::recursive_mutex`

```cpp
///hide
#include <mutex>

///unhide
struct C {
  void func1() {
    std::lock_guard<std::recursive_mutex> lock{m_mutex};
    // do work
  }

  void func2() {
    std::lock_guard<std::recursive_mutex> lock{m_mutex};
    // do work
    func1();
    // do more work
  }

  std::recursive_mutex m_mutex;
};
///hide

int main() {
  C{}.func2();
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## or [better](https://quick-bench.com/q/yK3BksMuPRaQqs3sOMtyCtW5lW8)

```cpp
///hide
#include <mutex>

///unhide
struct C {
  void func1() {
    std::lock_guard<std::mutex> lock{m_mutex};
    func1_impl();
  }

  void func2() {
    std::lock_guard<std::mutex> lock{m_mutex};
    func1_impl();
  }

  void func1_impl() {}

  std::mutex m_mutex;
};
///hide

int main() {
  C{}.func2();
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="09_concurrency/synchronization.gif" -->

## synchronization

<!-- .element: class="chapter bottom" -->

<aside class="notes"><p>besides from protecting shared data, many times one thread needs to wait for data prepared by a different thread or get the result of some computation done by a thread.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## waiting for an event

```cpp []
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <thread>
#include <iostream>

///unhide
bool flag;
std::mutex m;

void waitForFlag() {
  const auto check_flag = []{
    std::lock_guard<std::mutex> lk(m);
    return flag;
  };
  while(!check_flag());
  std::cout << "flag set\n";
}
///hide

int main() {
    std::thread t1{waitForFlag};
    std::thread t2{[]{
        std::this_thread::sleep_for(std::chrono::seconds{1});
        std::lock_guard<std::mutex> lk(m);
        flag = true;
    }};

    t2.join();
    t1.join();
}
```

<!-- .element: data-id="code" -->

<aside class="notes"><p>waist of cpu cycles and locking prevents other thread from setting flag</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## waiting for an event

```cpp []
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <thread>
#include <iostream>

///unhide
bool flag;
std::mutex m;

void waitForFlag() {
  const auto check_flag = []{
    std::lock_guard<std::mutex> lk(m);
    return flag;
  };
  while(!check_flag()) {
    using namespace std::chrono_literals;
    std::this_thread::sleep_for(100ms);
  }
  std::cout << "flag set\n";
}
///hide

int main() {
    std::thread t1{waitForFlag};
    std::thread t2{[]{
        std::this_thread::sleep_for(std::chrono::seconds{1});
        std::lock_guard<std::mutex> lk(m);
        flag = true;
    }};

    t2.join();
    t1.join();
}
```

<!-- .element: data-id="code" -->

<aside class="notes"><p>hard to get the sleep period right</p>
</aside></script></section><section data-markdown><script type="text/template">
## condition variables

```cpp [1,4|7-8|13]
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <thread>
#include <iostream>
///unhide
#include <condition_variable>

std::mutex m;
std::condition_variable dataCond;

void waitForFlag() {
  std::unique_lock<std::mutex> lk(m);
  dataCond.wait(lk);
  std::cout << "flag set\n";
}

void setFlag() {
  dataCond.notify_one();
}
///hide

int main() {
    std::thread t1{waitForFlag};
    std::thread t2{setFlag};

    t2.join();
    t1.join();
}
```

<aside class="notes"><p>need to use <code>unique_lock</code>. Note that the condition variable is notified with the mutex unlocked so that, if the waiting thread wakes immediately, it doesn’t then have to block again, waiting for the notifier to unlock the mutex. 
But where is the condition?</p>
</aside></script></section><section data-markdown><script type="text/template">
## producer consumer

```cpp [2,5-14|17-32|21-23]
///hide
#include <mutex>
#include <condition_variable>
#include <queue>

struct DataChunk {};

bool moreDataToPrepare();
DataChunk prepareData();
bool isLastChunk(const DataChunk&);
void process(const DataChunk&);

///unhide
std::mutex mut;
std::queue<DataChunk> dataQueue;
std::condition_variable dataCond;

void dataPreparationThread() {
  while(moreDataToPrepare()) {
    const auto data = prepareData();
    {
      std::lock_guard<std::mutex> lk(mut);
      dataQueue.push(data);
    }
    dataCond.notify_one();
  }
}


void dataProcessingThread() {
  while(true) {
    const auto data = []{
      std::unique_lock<std::mutex> lk(mut);
      dataCond.wait(lk, []{
        return !dataQueue.empty();
      });
      const auto data = dataQueue.front();
      dataQueue.pop();
      return data;
    }();
    process(data);
    if(isLastChunk(data))
      break;
  }
}
```

<!-- .element: class="split" -->

<aside class="notes"><p>the cond. var. calls checks the condition before going to sleep.
the condition variable unlocks the mutex when waiting and relocks when it&#39;s awaiken to check the condition.
There&#39;s also <code>notify_all</code> for awaikening <strong>all</strong> threads waiting on the same cond.</p>
</aside></script></section><section data-markdown><script type="text/template">
## platform specific

```cpp [11-19]
///options=-pthread
///hide
#include <pthread.h>
#include <iostream>
#include <thread>
#include <cstring>

///unhide
void f(int num) {
  std::this_thread::sleep_for(std::chrono::seconds(1));

  sched_param sch;
  int policy;
  pthread_getschedparam(pthread_self(), &policy, &sch);
  std::cout << "Thread " << num << " is executing at priority "
            << sch.sched_priority << '\n';
}

///hide
int main() {
///unhide
std::thread t1(f, 1), t2(f, 2);

sched_param sch;
int policy;
pthread_getschedparam(t1.native_handle(), &policy, &sch);
sch.sched_priority = 20;
if (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &sch)) {
  std::cout << "Failed to setschedparam: " << std::strerror(errno) << '\n';
}
///hide

t1.join(); 
t2.join();
}
```

<!-- .element: style="font-size: 0.4em" -->

<aside class="notes"><p>: there&#39;s a similar facility for mutex types</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="09_concurrency/future.gif" data-background-size="contain" -->

## std::future

<!-- .element: class="chapter" -->

<aside class="notes"><p><code>std::thread</code> doesn&#39;t return a value. Although we could send it a reference to the result and then wait there is a better alternative.</p>
</aside></script></section><section data-markdown><script type="text/template">
## `std::future`

Getting the result of an asynchronous operation

```cpp
template< class T > class future {
public:
  // returns the result
  T get();

  // is this attached to an operation result
  bool valid() const noexcept;
};
```

<aside class="notes"><p>How to obtain a future?</p>
</aside></script></section><section data-markdown><script type="text/template">
## `std::async`

runs a function asynchronously

```cpp
///hide
#include <iostream>
///unhide
#include <future>

///hide
int findTheAnswerToLifeTheUniverseAndEverything();
void doOtherStuff();

void foo() {
///unhide
std::future<int> theAnswer 
  = std::async(findTheAnswerToLifeTheUniverseAndEverything);
doOtherStuff();
std::cout 
  << "The answer is " 
  << theAnswer.get() // blocks
  << '\n';
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## launch policy

```cpp
///hide
#include <string>
#include <future>

///unhide
struct X
{
  void foo(int,std::string const&);
  std::string bar(std::string const&);
};

std::string run() {
  X x;
  // on a separate thread, calls p->foo(42,“hello”) where p is &x
  auto f1 = std::async(std::launch::async, &X::foo, &x, 42 , "hello");

  // during f2.get(), calls x.bar("goodbye")
  auto f2 = std::async(std::launch::deferred, &X::bar , std::ref(x), "goodbye");
  return f2.get();

} // ~f1 will block
```

<!-- .element: style="font-size: 0.4em" -->

<aside class="notes"><p>without a policy, it&#39;s implementation defined</p>
</aside></script></section><section data-markdown><script type="text/template">
## be careful

```cpp
///hide
#include <future>
#include <functional>

///unhide
void runInParallel(std::function<void()> f1, 
                   std::function<void()> f2)
{
  std::async(f1); // start as though in a new thread?
  f2();           // execute in main thread
}
```

<aside class="notes"><p>it&#39;s sequential becuase the future returned by <code>async</code> is blocked on destruction</p>
</aside></script></section><section data-markdown><script type="text/template">
## `std::packaged_task`

An asynchronous `std::function`

```cpp [1-2,18-26|1-2,4-15]
///hide
#include <deque>
#include <mutex>
#include <future>
#include <thread>
#include <utility>

bool shutdownReceived();

///unhide
std::mutex m;
std::deque<std::packaged_task<void()>> tasks;

void guiThread() {
  while(!shutdownReceived()) {
    auto task = []{
      std::lock_guard<std::mutex> lk(m);
      if(tasks.empty())
        return std::packaged_task<void()>{};
      auto task = std::move(tasks.front());
      tasks.pop_front();
      return task;
    }();
    if (task.valid())
      task();
  }
}

template<typename Func>
std::future<void> sendTaskToGui(Func f)
{
  std::packaged_task<void()> task(std::move(f));
  std::future<void> res = task.get_future();
  std::lock_guard<std::mutex> lk(m);
  tasks.push_back(std::move(task));
  return res;
}







```

<!-- .element: class="split" -->

</script></section><section data-markdown><script type="text/template">
## `std::promise`

implementing a packaged task

```cpp [5-6,13,16]
///hide
#include <functional>
#include <future>

///unhide
template <typename> class my_task;

template <typename R, typename ...Args>
class my_task<R(Args...)> {
  std::function<R(Args...)> fn;
  std::promise<R> pr;
public:
  template <typename ...Ts>
  explicit my_task(Ts &&... ts) : fn(std::forward<Ts>(ts)...) { }

  template <typename ...Ts>
  void operator()(Ts &&... ts) {
    pr.set_value(fn(std::forward<Ts>(ts)...));
  }

  std::future<R> get_future() { return pr.get_future(); }
};
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## async accumulate

```cpp [1-2|4-13|15-19|21-31|33-36]
///hide
#include <future>
#include <numeric>
#include <vector>

///unhide
template <typename Iterator, typename T, ptrdiff_t MIN_PER_THREAD = 25>
T async_accumulate(Iterator first, Iterator last, T init)
{
  const auto length = std::distance(first, last);
  if (!length)
    return init;

  const auto max_threads = (length + MIN_PER_THREAD - 1) / MIN_PER_THREAD;
  const auto hardware_threads = std::thread::hardware_concurrency();
  const auto num_threads =
      std::min<ptrdiff_t>(hardware_threads != 0 ? hardware_threads : 2,
                          max_threads);
  const auto block_size = length / num_threads;

  std::vector<std::future<T>> results;
  results.reserve(num_threads);
  const auto accumulator = [](Iterator first, Iterator last) {
    return std::accumulate(first, last, 0);
  };

  auto block_start = first;
  for (auto block_end = std::next(block_start, block_size); 
       std::distance(block_start, last) >= block_size; 
       block_start = block_end, block_end = std::next(block_start, block_size))
  {
    results.push_back(std::async(accumulator, block_start, block_end));
  };

  std::promise<T> pr;
  results.push_back(pr.get_future());
  pr.set_value(accumulator(block_start, last));

  return std::accumulate(results.begin(), results.end(), init, 
                         [](int current, std::future<T> &rhs) {
    return current + rhs.get();
  });
}
```

<!-- .element: "style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
## sharing the future

```cpp [1-2|4-11|13-14|18-25|27-36]
///compiler=clang600
///options=-pthread
///hide
#include <iostream>
#include <future>
#include <chrono>

int main()
{
///unhide
std::promise<void> ready_promise, t1_ready_promise, t2_ready_promise;
std::shared_future<void> ready_future(ready_promise.get_future());

auto fun =
    [](std::shared_future<void> ready_future,
       std::promise<void> ready_promise,
       std::chrono::time_point<std::chrono::high_resolution_clock>& start) {
      ready_promise.set_value();
      ready_future.wait();  // waits for the signal from main()
      return std::chrono::high_resolution_clock::now() - start;
    };

auto fut1 = t1_ready_promise.get_future();
auto fut2 = t2_ready_promise.get_future();

std::chrono::time_point<std::chrono::high_resolution_clock> start;

auto result1 = std::async(std::launch::async, fun, ready_future,
                          std::move(t1_ready_promise), std::ref(start));
auto result2 = std::async(std::launch::async, fun, ready_future,
                          std::move(t2_ready_promise), std::ref(start));

// wait for the threads to become ready
fut1.wait();
fut2.wait();

// the threads are ready, start the clock
start = std::chrono::high_resolution_clock::now();

// signal the threads to go
ready_promise.set_value();

std::cout << "Thread 1 received the signal "
          << result1.get().count() << " ms after start\n"
          << "Thread 2 received the signal "
          << result2.get().count() << " ms after start\n";
///hide
}
```

<!-- .element: style="font-size: 0.4em" -->

<aside class="notes"><p><code>std::future::get</code> can only be called by a single thread. For multiple threads refering the same data, use <code>std::shared_ptr</code>.
Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a shared_future object.</p>
</aside></script></section><section data-markdown><script type="text/template">
## alternatively

```cpp
///hide
#include <future>

///unhide
std::promise<void> ready_promise;
auto ready_future = ready_promise.get_future().share();
```

</script></section><section data-markdown><script type="text/template">
## duration based waits

```cpp [3-5]
///hide
#include <future>
#include <chrono>

int some_task();
void do_something_with(int);

void foo() {
///unhide
using namespace std::chrono_literals;

auto f = std::async(some_task);
if(f.wait_for(35ms) == std::future_status::ready)
  do_something_with(f.get());
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## time point based waits

```cpp [8-15]
///hide
#include <condition_variable>
#include <mutex>
#include <chrono>

///unhide
std::condition_variable cv;
bool done;
std::mutex m;

bool wait_loop()
{
  using namespace std::chrono_literals;
  const auto timeout = std::chrono::steady_clock::now() + 500ms;
  std::unique_lock<std::mutex> lk(m);
  while(!done)
  {
    if(cv.wait_until(lk, timeout) == std::cv_status::timeout)
      break;
  }
  return done;
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## timed lock

```cpp [4,10]
///compiler=clang600
///options=-pthread
///hide
#include <mutex>
#include <future>
#include <cassert>

///unhide
using namespace std::chrono_literals;
using clk = std::chrono::steady_clock;

std::timed_mutex m;

int main() {
  m.lock();
  auto f = std::async(std::launch::async, []{
    const auto t0 = clk::now();
    assert(m.try_lock_for(300ms) == true);
    const auto t1 = clk::now();
    m.unlock();
    auto d = t1 - t0 - 250ms;
    assert(d < 50ms);
  });
  std::this_thread::sleep_for(250ms);
  m.unlock();
  f.wait();
}
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="09_concurrency/errors.gif" -->

## Error handling

<!-- .element: class="chapter bottom" -->

<aside class="notes"><p>It&#39;s hard to imaging but there are someting errors in a program. How do we deal with them in a multithreaded code?</p>
</aside></script></section><section data-markdown><script type="text/template">
## `std::system_error`

thrown by several threading functions

```cpp
///compiler=clang600
///options=-pthread
///hide
#include <thread>
#include <iostream>

int main() {
///unhide
try {
  std::thread{}.join();
} catch (const std::system_error& ex) {
  std::cerr 
    << ex.code() 
    << ", " 
    << ex.code().message() 
    << '\n';
}
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## `std::future_error`

thrown by futures

```cpp
///compiler=clang600
///options=-pthread
///hide
#include <future>
#include <iostream>
#include <thread>

int main() {
///unhide
try {
  auto f = std::promise<int>{}.get_future();
  f.get();
} catch (const std::future_error& ex) {
  std::cerr 
    << ex.code() 
    << ", " 
    << ex.code().message() 
    << '\n';
}
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## catch exception

```cpp []
///hide
#include <cmath>
#include <iostream>
#include <stdexcept>

///unhide
double throwingSqrt(double x)
{
    if (x < 0)
    {
      throw std::out_of_range("x<0");
    }
    return sqrt(x);
}

///hide
int main() {
///unhide
try {
  auto y = throwingSqrt(-1);
} catch (const std::exception& ex) {
  std::cerr << ex.what() << '\n';
}
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## in a thread

```cpp []
///compiler=clang600
///options=-pthread
///hide
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <thread>

double throwingSqrt(double x) {
  if (x < 0) {
    throw std::out_of_range("x<0");
  }
  return sqrt(x);
}

int main() {
///unhide
try {
  double result;
  std::thread t{[&result](double x) {
                  result = throwingSqrt(x);
                }, -1};
  t.join();
} catch (const std::exception& ex) {
  std::cerr << ex.what() << '\n';
}
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## transfer the exception

```cpp [3,5-9,13-15]
///compiler=clang600
///options=-pthread
///hide
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <thread>

double throwingSqrt(double x) {
  if (x < 0) {
    throw std::out_of_range("x<0");
  }
  return sqrt(x);
}

int main() {
///unhide
try {
  double result;
  std::exception_ptr ptr;
  std::thread t{[&result, &ptr](double x) {
                  try {
                    result = throwingSqrt(x);
                  } catch (...) {
                    ptr = std::current_exception();
                  }
                }, -1};
  t.join();
  if (ptr) {
    std::rethrow_exception(ptr);
  }
} catch (const std::exception& ex) {
  std::cerr << ex.what() << '\n';
}
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## use `promise`

```cpp [2-3,5-9,12]
///compiler=clang600
///options=-pthread
///hide
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <thread>
#include <future>

double throwingSqrt(double x) {
  if (x < 0) {
    throw std::out_of_range("x<0");
  }
  return sqrt(x);
}

int main() {
///unhide
try {
  std::promise<double> p;
  auto f = p.get_future();
  std::thread t{[&p](double x) {
                  try {
                    p.set_value(throwingSqrt(x));
                  } catch (...) {
                    p.set_exception(std::current_exception());
                  }
                }, -1};
  t.join();
  double y = f.get();
} catch (const std::exception& ex) {
  std::cerr << ex.what() << '\n';
}
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## use `async`

```cpp [2]
///compiler=clang600
///options=-pthread
///hide
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <future>

double throwingSqrt(double x) {
  if (x < 0) {
    throw std::out_of_range("x<0");
  }
  return sqrt(x);
}

int main() {
///unhide
try {
  double y = std::async(throwingSqrt, -1).get();
} catch (const std::exception& ex) {
  std::cerr << ex.what() << '\n';
}
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="atomic" data-background-image="09_concurrency/atomic.gif" -->

## `std::atomic` and memory ordering

<!-- .element: class="chapter" style="display:inherit" -->

<div class="footnote">

Source: Fedor Pikus, [C++ atomics, from basic to advanced. What do they really do?](https://www.youtube.com/watch?v=ZQFzMfHIxng)

</div>

<aside class="notes"><p>all the synchronization and data sharing protection tools we&#39;ve covered couldn&#39;t work without a well defined memory model. 
C++11 contains a well defined memory model along with low level synchronization constructs called &#39;atomics&#39;.</p>
</aside></script></section><section data-markdown><script type="text/template">
## atomic operation

indivisible - can’t be observed half-done from any thread in the system.

</script></section><section data-markdown><script type="text/template">
## atomic type

all **single** operations on are atomic

</script></section><section data-markdown><script type="text/template">
## `std::atomic`

```cpp
template< class T >
struct atomic;
```

`T` must be *trivially copyable* 

<aside class="notes"><p>can be <code>memcpy</code>-ed.</p>
</aside></script></section><section data-markdown><script type="text/template">
## allowed operations

```cpp []
///hide
#include <cassert>
///unhide
#include <atomic>

struct Pair{int first; int second;};
std::atomic<Pair> x;

int main() {
  x.store(Pair{42, 43});
  assert(x.exchange(Pair{45, 45}).first == 42);
  assert(x.load().second == 45);
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## pointer types

adds addition & substruction

```cpp []
///hide
#include <cassert>
///unhide
#include <atomic>

int arr[42] = {0};
std::atomic<int*> x{arr};

int main() {
  assert(x.fetch_add(2) == arr);
  assert(x.fetch_sub(1) == &arr[2]);
  assert(x.load() == &arr[1]);
}
```

<!-- .element: data-id="pointer" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## pointer types

alternatively

```cpp []
///hide
#include <cassert>
///unhide
#include <atomic>

int arr[42] = {0};
std::atomic<int*> x{arr};

int main() {
  assert((x += 2) == &arr[2]);
  assert(--x == &arr[1]);
}
```

<!-- .element: data-id="pointer" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## integral types

adds bitwise operations

```cpp []
///hide
#include <cassert>
///unhide
#include <atomic>

std::atomic<uint32_t> x{0xFFF};

int main() {
  assert(x.fetch_and(0xF0F) == 0xFFF);
  assert(x.fetch_or(0x070) == 0xF0F);
  assert(x.fetch_xor(0xFFF) == 0xF7F);
  assert(x.load() == 0x080);
}
```

<!-- .element: data-id="integral" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## integral types

adds bitwise operations

```cpp []
///hide
#include <cassert>
///unhide
#include <atomic>

std::atomic<uint32_t> x{0xFFF};

int main() {
  assert((x &= 0xF0F) == 0xF0F);
  assert((x |= 0x070) == 0xF7F);
  assert((x ^= 0xFFF) == 0x080);
}
```

<!-- .element: data-id="integral" -->

</script></section><section data-markdown><script type="text/template">
## only single operations

```cpp
///hide
#include <atomic>

///unhide
std::atomic<int> x;

///hide
int main() {
///unhide
x = x + 2; // not atomic
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## might be emulated

```cpp
///options=-latomic
///hide
#include <atomic>
#include <cassert>

int main() {
///unhide
assert(std::atomic<int>{}.is_lock_free());

struct S{int arr[4];};
assert(not std::atomic<S>{}.is_lock_free());
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: id="is_always_lock_free" -->

## compile time check (C++17)

```cpp
///options=-std=c++17
///hide
#include <atomic>

///unhide
static_assert(std::atomic<bool>::is_always_lock_free);
```

</script></section><section data-markdown><script type="text/template">
## Compare-and-swap (CAS)

used in most lock-free algorithms

```cpp
///hide
#include <atomic>

///unhide
std::atomic<int> x{0};

void atomic_multiply(int y) {
  int x0 = x;
  while ( !x.compare_exchange_strong(x0, x0 * y) );
}
```

</script></section><section data-markdown><script type="text/template">
## Pseudo code

<!-- .slide: data-auto-animate -->

```cpp [2-3|4|5-6|7-8]
///hide
struct Lock{};

template<typename T>
struct atomic {
T value;
///unhide
bool compare_exchange_strong(T& old_v, T new_v) {
  T tmp = value; // Current value of the atomic
  if (tmp != old_v) { old_v = tmp; return false; }
  Lock l; // Get exclusive access
  tmp = value; // value could have changed!
  if (tmp != old_v) { old_v = tmp; return false; }
  value = new_v;
  return true;
}
///hide
};
```

<!-- .element: data-id="cas" -->

<aside class="notes"><p>double-checked locking pattern. Lock is not a real mutex but some form of exclusive access implemented in hardware</p>
</aside></script></section><section data-markdown><script type="text/template">
## Psuedo code - weak

<!-- .slide: data-auto-animate -->

```cpp [1,4-5]
///hide
struct TimedLock{
  bool locked();
};

template<typename T>
struct atomic {
T value;
///unhide
bool compare_exchange_weak(T& old_v, T new_v) {
  T tmp = value; // Current value of the atomic
  if (tmp != old_v) { old_v = tmp; return false; }
  TimedLock tl; // Get exclusive access
  if (!tl.locked()) return false; // old_v is correct
  tmp = value; // value could have changed!
  if (tmp != old_v) { old_v = tmp; return false; }
  value = new_v;
  return true;
}
///hide
};
```

<!-- .element: data-id="cas" -->

</script></section><section data-markdown><script type="text/template">
## reading and writing

```cpp []
///hide
#include <vector>
#include <atomic>
#include <iostream>
#include <thread>

///unhide
std::vector<int> data;
std::atomic<bool> ready(false);

void writer() {
  data.push_back(42);
  ready.store(true);
}

void reader() {
  while (not ready.load()) {
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }
  std::cout << "The answer is " << data.back() << '\n';
}
```

<!-- .element: style="font-size: 0.45em" -->

<aside class="notes"><ul>
<li>Atomics are used to get exclusive access to memory or to
reveal memory to other threads</li>
<li>What guarantees that other threads see this memory in
the desired state</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## memory barriers

- How changes to memory made by one thread become visible to other threads
- modeled by `std::memory_order` enum

</script></section><section data-markdown><script type="text/template">
### `std::memory_order_relaxed`

- no synchronization or ordering constraints imposed on **other** reads or writes.
- operations before atomic operation can be observed after it and vice versa

</script></section><section data-markdown><script type="text/template">
## counter

```cpp
///hide
#include <atomic>
#include <cstddef>

///unhide
class S{
  static std::atomic<size_t> instanceCount;

  S() {
    instanceCount.fetch_add(1, std::memory_order_relaxed);
  }

  ~S() {
    instanceCount.fetch_sub(1, std::memory_order_relaxed);
  }
};
```

</script></section><section data-markdown><script type="text/template">
### `std::memory_order_acquire`

- all memory operations scheduled after the barrier in the program order become visible after the barrier
- reads and writes, in the thread doing the atomic operation, cannot be reordered from after to before the barrier

</script></section><section data-markdown><script type="text/template">
### `std::memory_order_release`

- all memory operations scheduled before the barrier in the program order become visible before the barrier
- reads and writes, in the thread doing the atomic operation cannot be reordered from before to after the barrier

</script></section><section data-markdown><script type="text/template">
## `std::atomic_flag`

```cpp
///hide
#include <atomic>

///unhide
class spinlock_mutex {
    std::atomic_flag flag;
public:
    spinlock_mutex(): flag{ATOMIC_FLAG_INIT}
    {}

    void lock() {
      while(flag.test_and_set(std::memory_order_acquire));
    }

    void unlock() {
      flag.clear(std::memory_order_release);
    }
};
```

</script></section><section data-markdown><script type="text/template">
## Release-Acquire ordering

```cpp []
///hide
#include <vector>
#include <atomic>
#include <iostream>
#include <thread>

///unhide
std::vector<int> data;
std::atomic<bool> ready(false);

void writer() {
  data.push_back(42);
  ready.store(true, std::memory_order_release);
}

void reader() {
  while (not ready.load(std::memory_order_acquire)) {
      std::this_thread::sleep_for(std::chrono::milliseconds(1));
  }
  std::cout << "The answer is " << data.back() << '\n';
}
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
### `std::memory_order_acq_rel`

- no operation can move across the barrier
- but only if both threads use the same atomic variable

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## read modify write

```cpp []
///hide
#include <vector>
#include <atomic>
#include <cassert>

///unhide
std::vector<int> data;
std::atomic<int> flag{0};

void writer() {
  data.push_back(42);
  flag.store(1, std::memory_order_release);
}

void middleMan() {
  int expected = 1;
  while (!flag.compare_exchange_strong(expected, 2, 
                                       std::memory_order_acq_rel));
}

void reader() {
  while (flag.load(std::memory_order_acquire) < 2) ;
  assert(data.back() == 42);
}
```

<!-- .element: data-id="cas" style="font-size: 0.42em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->


## read modify write

```cpp []
///hide
#include <vector>
#include <atomic>
#include <cassert>

///unhide
std::vector<int> data;
std::atomic<int> flag{0};

void writer() {
  data.push_back(42);
  flag.store(1, std::memory_order_release);
}

void middleMan() {
  int expected = 1;
  while (!flag.compare_exchange_strong(expected, 2, 
                                       std::memory_order_acq_rel,
                                       std::memory_order_relaxed));
}

void reader() {
  while (flag.load(std::memory_order_acquire) < 2) ;
  assert(data.back() == 42);
}
```

<!-- .element: data-id="cas" style="font-size: 0.42em" -->

</script></section><section data-markdown><script type="text/template">
### `std::memory_order_seq_cst`

- sequential consistency
- single total modification order of all atomics
- the default order
- makes your programs slow

</script></section><section data-markdown><script type="text/template">
## a simple thread pool

```cpp [2-4|6-15|18-27|29|31-39]
///hide
#include <algorithm>
#include <functional>
#include <future>
#include <vector>

template <typename T>
struct thread_safe_queue {
  template <typename U = T>
  void push(U&&);
  bool try_pop(T&);
};

class thread_joiner {
 public:
  explicit thread_joiner(std::thread thread) : m_thread{std::move(thread)} {}
  ~thread_joiner() {
    if (m_thread.joinable()) {
      m_thread.join();
    }
  }
  thread_joiner(const thread_joiner&) = delete;
  thread_joiner(thread_joiner&&) = default;
  thread_joiner& operator=(const thread_joiner&) = delete;
  thread_joiner& operator=(thread_joiner&&) = default;

 private:
  std::thread m_thread;
};

///unhide
class thread_pool {
  thread_safe_queue<std::function<void()>> work_queue;
  std::atomic<bool> done{false};
  std::vector<thread_joiner> threads;

  void worker_thread() {
    while (!done) {
      std::function<void()> task;
      if (work_queue.try_pop(task)) {
        task();
      } else {
        std::this_thread::yield();
      }
    }
  }

 public:
  thread_pool() {
    const auto thread_count = std::thread::hardware_concurrency();
    threads.reserve(thread_count);
    std::generate_n(std::back_inserter(threads), 
                    thread_count, 
                    [this] {
      return thread_joiner{std::thread{&thread_pool::worker_thread, 
                                       this}};
    });
  }

  ~thread_pool() { done = true; }

  template <typename FunctionType>
  std::future<typename std::result_of<FunctionType()>::type> submit(
      FunctionType f) {
    using result_type = typename std::result_of<FunctionType()>::type;
    std::packaged_task<result_type()> task(std::move(f));
    const auto res = task.get_future();
    work_queue.push([task] { task(); });
    return res;
  }
};
```

<!-- .element: style="font-size: 0.45em" -->

<aside class="notes"><p>there&#39;s a lot of contention on the queue. to avoid that we&#39;ll add a separate work queue for each thread</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: id="thread_local" -->

## `thread_local`

```cpp [2-5|9-25|47-52]
///hide
#include <algorithm>
#include <functional>
#include <future>
#include <vector>
#include <queue>

template <typename T>
struct thread_safe_queue {
  template <typename U = T>
  void push(U&&);
  bool try_pop(T&);
};

class thread_joiner {
 public:
  explicit thread_joiner(std::thread thread) : m_thread{std::move(thread)} {}
  ~thread_joiner() {
    if (m_thread.joinable()) {
      m_thread.join();
    }
  }
  thread_joiner(const thread_joiner&) = delete;
  thread_joiner(thread_joiner&&) = default;
  thread_joiner& operator=(const thread_joiner&) = delete;
  thread_joiner& operator=(thread_joiner&&) = default;

 private:
  std::thread m_thread;
};

///unhide
class thread_pool {
  thread_safe_queue<std::function<void()>> pool_work_queue;
  using local_queue = std::queue<std::function<void()>>;
  static thread_local std::unique_ptr<local_queue> 
    local_work_queue;
  std::atomic<bool> done{false};
  std::vector<thread_joiner> threads;

  void worker_thread() {
    local_work_queue = std::make_unique<local_queue>();

    while (!done) {
      std::function<void()> task;
      if (not local_work_queue->empty()) {
        task = std::move(local_work_queue->front());
        local_work_queue->pop();
        task();
      }
      else if (pool_work_queue.try_pop(task))  {
        task();
      } else {
        std::this_thread::yield();
      }
    }
  }

 public:
  thread_pool() {
    const auto thread_count = std::thread::hardware_concurrency();
    threads.reserve(thread_count);
    std::generate_n(std::back_inserter(threads), 
                    thread_count, 
                    [this] {
      return thread_joiner{std::thread{&thread_pool::worker_thread, 
                                       this}};
    });
  }

  ~thread_pool() { done = true; }

  template <typename FunctionType>
  std::future<typename std::result_of<FunctionType()>::type> submit(
      FunctionType f) {
    using result_type = typename std::result_of<FunctionType()>::type;
    std::packaged_task<result_type()> task(std::move(f));
    const auto res = task.get_future();
    const auto work = [task] { task(); };
    if (local_work_queue) {
      local_work_queue->push(work);
    } else {
      pool_work_queue.push(work);
    }
    return res;
  }
};
```

<!-- .element: style="font-size: 0.45em" -->


</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="09_concurrency/thanks.gif" -->
</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"highlight":{"highlightOnLoad":true}}, queryOptions);
    </script>

    <script src="./_assets/scripts/startfrom.js"></script>
    <script src="./_assets/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="./_assets/scripts/customize.js"></script>
    <script src="./_assets/scripts/compiler-explorer.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
