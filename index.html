<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./_assets/node_modules/github-fork-ribbon-css/gh-fork-ribbon.css" />
    <link rel="stylesheet" href="./_assets/css/custom.css" />
    <link rel="stylesheet" href="./_assets/css/animations.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># C++11 and Beyond! <!-- .element: id="title" -->

<img id="logo" src="00_title/cpp_logo.png" alt="logo">

<table id="versions">
  <tr>
    <td><h1 id="v11">11</h1></td>
    <td><h1 id="v14">14</h1></td>
    <td><h1 id="v17">17</h1></td>
    <td><h1 id="v20">20</h1></td>
  </tr>
</table>

[Dvir Yitzchaki](https://github.com/dvirtz)

<aside class="notes"><ul>
<li>The first C++ standard was published on 1998 with a small bug fix update on 2003.</li>
<li>After being stale for over a decade, starting from 2011, the standard switched to a train model where a new standard is being released every 3 years.</li>
<li>In this series we&#39;re going to discuss the new language and library features added to the C++ standard in the new revisons released since.</li>
<li>On each session we will have one main topic and smaller features will be introduced as needed.</li>
<li>Let&#39;s start.</li>
</ul>
</aside></script></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="01_auto/schmeichel.jpg" -->

</script></section><section data-markdown><script type="text/template">
## What problems can you find in this code?

```cpp
///fails=conversion from 'int' to non-scalar type 'std::vector<int>' requested
///hide
#include <string>
#include <vector>

void foo() {
///unhide
// (a)
int i;

// (b)
std::vector<std::string> v;
int size = v.size();

// (c)
std::vector<int> v1(5);
std::vector<int> v2 = 5;
///hide
}
```

<aside class="notes"><ul>
<li>uninitialized variable</li>
<li>possible data lose converting from <code>size_t</code> to <code>int</code></li>
<li>although looking similar, the second line does not compile, because the constructor is <em>explicit</em></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///fails=conversion from '__normal_iterator<const int*,[...]>' to non-scalar type '__normal_iterator<int*,[...]>' requested
///hide
#include <vector>
///unhide
void traverser( const std::vector<int>& v ) {
  for( std::vector<int>::iterator i = v.begin(); 
       i != v.end(); 
       ++i )
  {
        // ...
  }
}
```

<aside class="notes"><ul>
<li>this code does not compile because we need a <code>const_iterator</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};
///unhide
gadget get_gadget();
///hide
gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

<small> assuming `gadget` is implicitly convertible to `widget` </small>

<aside class="notes"><ul>
<li>a temporary <code>getget</code> is created which might be a performance pitfall, as the creation of the temporary object is not at all obvious from reading the call site alone.</li>
<li>it&#39;s possible that using <code>gadget</code> is just as well as viable in this code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Non member `begin` and `end`

Accept anything with a member `begin` and `end` as well as C-style arrays

```cpp
///hide
#include <vector>
#include <cassert>
 
int main() 
{
///unhide
std::vector<int> v = { 3, 1, 4 };
auto vi = std::begin(v);
assert(*vi == 3);

int a[] = { -5, 10, 15 };
auto ai = std::begin(a);
assert(*ai == -5);
///hide
}
```

<aside class="notes"><ul>
<li>prefer to use this in generic code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
What does this function do?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void some_function( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><ul>
<li><code>append_unique</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="01_auto/auto.gif" -->

# auto
<!-- .element: class="chapter" -->

<div class="footnote" style="text-shadow:-1px 0 black, 0 1px black, 1px 0 black, 0 -1px black">

Slides are based on [Herb Sutter's](herbsutter.com) GOTW series

</div>

<aside class="notes"><ul>
<li>our main topic today</li>
<li>oldest feature in C++11 (first implementation at 1983)</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## declaring a local variable

syntax

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto my_new_variable = its_initial_value;
///hide
}
```

deduce type from initializing expression

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto x = 0x12345678ULL; // type of x is unsigned long long
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## similar to template type deduction
```cpp
template<class T> void f( T ) { }

///hide
int main() {
///unhide
int val = 0;

f( val );     // deduces T == int, calls f<int>( val )

auto x = val; // deduces T == int, x is of type int
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Strips off qualifiers and references
```cpp
///hide
int main() {
///unhide
int           val = 0;

int&          ir  = val;
auto          e   = ir;   // The type of e is int

const int     ci  = val;
auto          h   = ci;   // The type of h is int

const int*    cip = &val;
auto          i   = cip;  // The type of i is const int*

int* const    ipc = &val;
auto          j   = ipc;  // The type of j is int*
///hide
}
```

<aside class="notes"><p>You want your new variable to be just like some existing variable or expression over there, and be initialized from it, but that only means that you want the same basic type, not necessarily that other variable’s own personal secondary attributes such as top-level const– or volatile-ness and &amp;/&amp;&amp; reference-ness which are per-variable. For example, just because he’s const doesn’t mean you’re const, and vice versa.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Can be qualified

```cpp
///hide
int main() {
///unhide
int         val = 0;
auto        a   = val; // The type of a is int
auto&       b   = val; // The type of b is int&
const auto  c   = val; // The type of c is const int
const auto& d   = val; // The type of d is const int&
///hide
}
```

<aside class="notes"><p>If needed, <code>const</code> and <code>&amp;</code> can be explicity added</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="01_auto/whats_init.gif" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## Forces initialization

instead of

```cpp
///hide
int main() {
///unhide
int i;
///hide
}
```

write

```cpp
///hide
int main() {
///unhide
auto i = 42;    // guaranteed to be initialized
///hide
}
```

<aside class="notes"><p>solving the first problem</p>
</aside></script></section><section data-markdown><script type="text/template">
## Avoid narrowing conversions

instead of

```cpp
///hide
#include <string>
#include <vector>

int main() {
///unhide
std::vector<std::string> v;
int size = v.size();
///hide
}
```

write

```cpp
///hide
#include <string>
#include <vector>

int main() {
std::vector<std::string> v;
///unhide
auto size = v.size(); // exact type, no narrowing
///hide
}
```

<aside class="notes"><p>solving narrowing conversions</p>
</aside></script></section><section data-markdown><script type="text/template">
## DRY initialization syntax

instead of

```cpp
///hide
#include <vector>

int main() {
///unhide
std::vector<int> v2 = std::vector<int>(5);
///hide
}
```

write

```cpp
///hide
#include <vector>

int main() {
///unhide
auto v2 = std::vector<int>(5); // keep it DRY
///hide
}
```

<aside class="notes"><p>if one wants to use explicit constructor with the assignment syntax they would have to repeat the type but not with auto</p>
</aside></script></section><section data-markdown><script type="text/template">
## Correct type by default

instead of

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
std::vector<int>::const_iterator i = v.begin();
///hide
}
```

write

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
auto i = begin(v);
///hide
}
```

<aside class="notes"><ul>
<li>correct and clear and simpler</li>
<li>stays correct if we change the type of the parameter to be non-const</li>
<li>or even replace vector with some other type of container</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Avoids hidden temporaries

instead of

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

write

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = get_gadget(); // gadget can be used
///hide
}
```

or

```cpp
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = widget(get_gadget()); // widget is needed
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `static_assert`

Check assertions at compile time:
```cpp
///hide
constexpr auto bool_constexpr = true;
#define message "should never appear"
///unhide
static_assert ( bool_constexpr , message );
```

For example:
```cpp
static_assert(sizeof(void *) == 8, 
  "Only 64-bit code generation is supported.");
```

<aside class="notes"><ul>
<li>If you only support 64 bit you can give a compile time error if anyone tries to use you code to compile for other architectures</li>
<li>Open CE</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `decltype`

Similar to `sizeof(expr)` but returns type instead of size.

```cpp
#include <type_traits>

int f();

static_assert(sizeof(f()) == sizeof(int), 
  "f should return int");
static_assert(std::is_same<int, decltype(f())>::value, 
  "f should return int");
```

</script></section><section data-markdown><script type="text/template">
## what should be the return type

```cpp
///hide
#include <iostream>
#define RETURN_TYPE auto

///unhide
template <typename Func, typename T>
RETURN_TYPE trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we implement a generic tracing function which gets a function <code>f</code> and a value <code>t</code> and returns the result of <code>f(t)</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## what should be the return type

first try

```cpp
///fails='t' was not declared in this scope
///hide
#include <iostream>

///unhide
template <typename Func, typename T>
decltype(f(t)) trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><ul>
<li>open CE</li>
<li>to express the return type we need to refer to <code>f</code> and <code>t</code> which are unknown to the compiler at the point of defining the return type.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## trailing return type

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) -> decltype(f(t)) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we replace the return type with <code>auto</code> and add the actual return type after the arrow.
At this point we can refer to <code>f</code> and <code>t</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## `auto` return type (C++14)

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>in c++14, this idiom was shortened to mean deduce the return type from the return statement</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="concerned.gif" -->

# CONCERNED?
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue" -->

<aside class="notes"><ul>
<li>There are number of popular concerns about using auto.</li>
<li>Let&#39;s tackle some of them.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
> writing auto to declare a variable is primarily about saving typing.

</script></section><section data-markdown><script type="text/template">
Writing auto is about

- [x] correctness <!-- .element: class="fragment" -->
- [x] performance <!-- .element: class="fragment" -->
- [x] maintainability <!-- .element: class="fragment" -->
- [x] robustness <!-- .element: class="fragment" -->
- [x] convenience <!-- .element: class="fragment" -->

<aside class="notes"><p>No, writing auto is about</p>
<ul>
<li>correctness</li>
<li>performance</li>
<li>maintainability</li>
<li>robustness</li>
<li>AND FINALLY, ALSO</li>
<li>convenience</li>
</ul>
<p>Next...</p>
</aside></script></section><section data-markdown><script type="text/template">
> But in some cases I do want to commit to a specific type, not automatically deduce it, so I can’t use auto.

</script></section><section data-markdown><script type="text/template">
Use

```cpp
///hide
template<typename type>
void foo(type init) {
///unhide
auto x = type(init);
///hide
}
```

<aside class="notes"><p>WRONG!</p>
</aside></script></section><section data-markdown><script type="text/template">
> My code gets unreadable quickly when I don’t know what exact type my variable is without hunting around to see what that function or expression returns, so I can’t just use auto all the time.

</script></section><section data-markdown><script type="text/template">
How many concrete types are in this function?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void append_unique( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><p>the lack of exact types makes it much more powerful and doesn’t significantly harm its readability</p>
</aside></script></section><section data-markdown><script type="text/template">
## write code against interfaces, not implementations

- <!-- .element: class="fragment" -->  Functions - hiding code
- <!-- .element: class="fragment" -->  OO - hiding code and data
- <!-- .element: class="fragment" --> Polymorphism - hiding type

<aside class="notes"><ul>
<li>we write functions to hide implmenetation code</li>
<li>we write class to hide private members and methods</li>
<li>we use static (templates) and dynamic (virtual methods) polymorphism to write generic code</li>
<li>using <code>auto</code> is another link in this software development chain</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Using `auto`

- <!-- .element: class="fragment" --> guarantees the variable will be initialized
- <!-- .element: class="fragment" --> efficient by default
- <!-- .element: class="fragment" --> guarantees that you will use the correct exact type
- <!-- .element: class="fragment" --> guarantees that you will continue to use the correct exact type
- <!-- .element: class="fragment" --> is the only good option for hard-to-spell and impossible-to-spell types
- <!-- .element: class="fragment" --> is just generally simpler and less typing

</script></section><section data-markdown><script type="text/template">
# Thank you

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="02_move/neville.jpg" -->

</script></section><section data-markdown><script type="text/template">
## How many copies?

```cpp
///hide
#include <vector>
#include <cstdint>

///unhide
template<typename Buffer>
std::vector<Buffer> generateBuffers(const size_t INSTANCES, 
                                    const size_t BUFFER_SIZE)
{
    std::vector<Buffer> v;
    for (size_t i = 0; i < INSTANCES; ++i)
    {
        v.push_back(Buffer(BUFFER_SIZE));
    }
    return v;
}
```

<aside class="notes"><ul>
<li>copying from temporary buffer</li>
<li>copying when capacity is full</li>
<li>possible copying when returning <code>v</code></li>
<li>in all theses cases the source is destroyed immediately after copying</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Member initialization

```cpp [|4-6|6]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D {};
int f(D);
///unhide
class A
{
public:
    A() : a(7), b(5), hash_algorithm("MD5"), s("Constructor run") {}
    A(int a_val) : a(a_val), b(5), hash_algorithm("MD5"), s("Constructor run") {}
    A(D d) : a(f(d)), b(a), hash_algorithm("MD5"), s("Constroctor run") {}
private:
    int a, b;
    HashingFunction hash_algorithm;
    std::string s;
};
```

<!-- .element: style="font-size:0.4em;" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Non-static data member initializers

```cpp [|8-10|4-6]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D {};
int f(D);
///unhide
class A
{
public:
    A() {}
    A(int a_val) : a(a_val) {}
    A(D d) : a(f(d)), b(a) {}
private:
    int a = 7, b = 5;
    HashingFunction hash_algorithm = HashingFunction("MD5");
    std::string s = "Constructor run";
};
```

<aside class="notes"><p><code>auto</code> is not allowed even with initializer;</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Delegating constructors

```cpp [|4-9|10]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D {};
int f(D);
///unhide
class A
{
public:
    A(int _a = 7, 
      int _b = 5, 
      const HashingFunction& _hash_algorithm = HashingFunction("MD5"), 
      const std::string& _s = "Constructor run") 
    : a(_a), b(_b), hash_algorithm(_hash_algorithm), s(_s) 
    {}
    A(D d) : A(f(d), a) {}
private:
    int a, b;
    HashingFunction hash_algorithm;
    std::string s;
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `nullptr`

A type safe replacement for `NULL` macro

```cpp
///external
///compiler=vcpp_v19_24_x64
///options=/O2
///hide
#include <cstddef>
///unhide
void foo(int);
void foo(char*);

///hide
int main(){
///unhide
foo(42); // calls foo(int);
foo(NULL); // calls foo(int);
foo(nullptr); // calls foo(char*);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Buffer copy

<div class="container">

```cpp [|2-3|5-10|12-18|0|0]
///hide
#include <algorithm>
///unhide
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///hide
    Buffer& operator=(const Buffer& other) 
    {
        delete[] m_pArray;
        m_size = other.m_size;
        m_pArray = new int[m_size];
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

```cpp 19[|0|0|0|19-28|30]
///hide
#include <algorithm>
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///unhide
    Buffer& operator=(const Buffer& other) 
    {
        delete[] m_pArray;
        m_size = other.m_size;
        m_pArray = new int[m_size];
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

<div>

</script></section><section data-markdown><script type="text/template">
## implement assignment by copy constructor

<div class="container">

```cpp [0]
///hide
#include <algorithm>
///unhide
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///hide
    Buffer& operator=(const Buffer& other) 
    {
        Buffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

```cpp 19[19-25]
///hide
#include <algorithm>
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///unhide
    Buffer& operator=(const Buffer& other) 
    {
        Buffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

<div>

</script></section><section data-markdown><script type="text/template">
## Steal from temporary

```cpp
///hide
#include <cstddef>
struct Buffer {
size_t m_size;
int* m_pArray;

Buffer(size_t size = 0) 
    : m_size(size)
    , m_pArray(size == 0 
                ? nullptr 
                : new int[size])
{}
///unhide
Buffer(const Buffer& temporary)
    : m_size(temporary.m_size)
    , m_pArray(temporary.m_pArray)
{}
///hide
~Buffer() { delete[] m_pArray; }
};
```

<aside class="notes"><ul>
<li>As we know the temporary won’t be used after the assignment operator, why not “move” its resources to the new object instead of copy them?</li>
<li>There&#39;s a problem with this code though - double delete</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Without double delete

```cpp
///hide
#include <cstddef>
struct Buffer {
size_t m_size;
int* m_pArray;

Buffer(size_t size = 0) 
    : m_size(size)
    , m_pArray(size == 0 
                ? nullptr 
                : new int[size])
{}
///unhide
Buffer(Buffer& temporary)
    : m_size(temporary.m_size)
    , m_pArray(temporary.m_pArray)
{
    temporary.m_size = 0;
    temporary.m_pArray = nullptr;
}
///hide
~Buffer() { delete[] m_pArray; }
};
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="02_move/move_it.gif" data-background-size="contain" data-transition="none slide" -->

# Move semantics
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 8%" -->

</script></section><section data-markdown><script type="text/template">
## How can we tell?

```cpp
///hide
#include <algorithm>

struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}
    Buffer(const Buffer& other)
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                    other.m_pArray + m_size, 
                    m_pArray);
    }
    ~Buffer() { delete[] m_pArray; }
};

int main() {
const auto BUFFER_SIZE = 4;
///unhide
Buffer c = Buffer(BUFFER_SIZE); // can move
Buffer d = c; // cannot move
// keep using c and d
///hide
}
```

<aside class="notes"><p>We need a way to distinguish between references to temporary objects and regular objects.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Value type

Originally:

> - l-value: can be on the left hand side of an assignment
> - r-value: can be **only** on the right hand side of an assignment

</script></section><section data-markdown><script type="text/template">
## Left or right?

```cpp [|4|5|6|7|8|9]
///hide
#include <vector>
#include <algorithm>

using std::min;

int main() {
///unhide
int a, b, *p;
std::vector<int> v(2);

a         = 42;
b         = a;
b         = a * b;
p         = new int;
*p        = min(a, b);
v.front() = 6;
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Value type

More accurately: 

> an expression is an *l*-value if it has a specific memory location and its address can be taken using the & operator, otherwise it is an *r*-value.

</script></section><section data-markdown><script type="text/template">
## Value type

```cpp
///fails=lvalue required as unary '&' operand
///hide
void foo() {
///unhide
int a, b;
int* c;
c = &a;
c = &(a * b); // error
///hide
}
```

All expressions returning temporary values are r-values.

All named objects are l-values.

</script></section><section data-markdown><script type="text/template">
## L-value references

A (non-const) reference can be bound only to l-values:

```cpp
///fails=cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int'
int a, b;
int& c = a;
int& d = (a * b); // error
```

</script></section><section data-markdown><script type="text/template">
## R-value references

Can be bound only to r-values and uses the && syntax.

```cpp
///fails=cannot bind rvalue reference of type 'int&&' to lvalue of type 'int'
int a = 1, b = 2;
int&& c = a; // error
int&& d = (a * b);
cout << ++d << endl;
```

<aside class="notes"><p><code>d</code> is extending the lifetime of <code>(a * b)</code></p>
</aside></script></section><section data-markdown><script type="text/template">
## Move constructor and assignment operator

<div class="container">

```cpp [|3-11|13-20|0]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 

    // move constructor
    MovableBuffer(MovableBuffer&& other)
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(MovableBuffer&& other)
    {
        MovableBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 22[|22-24|0|26-34]
///hide
#include <cstddef>
#include <utility>

struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 
    
    // move constructor
    MovableBuffer(MovableBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other)
    {
        MovableBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/ryKzdF90wADpRQ6hHuvUvhat1Z0)

</script></section><section data-markdown><script type="text/template">
## Move only

<div class="container">

```cpp [|0]
///fails=use of deleted function 'constexpr MoveOnlyBuffer::MoveOnlyBuffer(const MoveOnlyBuffer&)'
///hide
#include <cstddef>
#include <utility>

///unhide
struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    MoveOnlyBuffer& operator=(MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 18[|21]
///fails=use of deleted function 'constexpr MoveOnlyBuffer::MoveOnlyBuffer(const MoveOnlyBuffer&)'
///hide
#include <cstddef>
#include <utility>

struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    MoveOnlyBuffer& operator=(
        MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

<aside class="notes"><ul>
<li>show compiler error</li>
<li>performance bug in the movable class</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## `std::move`

casts the argument to an `rvalue`

```cpp
///hide
#include <type_traits>
///unhide
namespace std {

template< class T >
typename remove_reference<T>::type&& move( T&& t ) noexcept {
    return static_cast<typename remove_reference<T>::type&&>(t);
}

} // namespace std
```

<!-- .element: style="font-size: 0.5em;" -->

</script></section><section data-markdown><script type="text/template">
## (really) move only

<div class="container">

```cpp [0]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    MoveOnlyBuffer& operator=(MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 18[21]
///hide
#include <cstddef>
#include <utility>

struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    MoveOnlyBuffer& operator=(
        MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/mevho4kNsJTPbnA7S8zrFToi5Is)

</script></section><section data-markdown><script type="text/template">
## Exception safety

<table style="font-size:0.55em">
    <tr>
        <td>Nothrow exception guarantee</td> <td>the function never throws exceptions</td>
    </tr>
    <tr>
        <td>Strong exception guarantee</td> <td>If the function throws an exception, the state of the program is rolled back to the state just before the function call</td>
    </tr>
    <tr>
        <td>Basic exception guarantee</td> <td>If the function throws an exception, the program is in a valid state. No resources are leaked, and all objects' invariants are intact</td>
    </tr>
    <tr>
        <td>No exception guarantee</td> <td><img src="02_move/dragons.jpg" alt="dragons" style="position: relative; height: 20%; left: 30%"></img></td>
    </tr>
</table>

</script></section><section data-markdown><script type="text/template">
`vector::push_back` pseudo code

```cpp
///fails=expected initializer before '<' token
template<typename T>
void vector<T>::push_back(const T& value) {
    if (size == capacity) {
        allocate larger buffer
        if (is movable) {
            // move all Ts to the new buffer
        } else {
            // copy all Ts to the new buffer
        }
    }
    // copy value to the end if the buffer
}
```

</script></section><section data-markdown><script type="text/template">
## copy

<svg class="animated" width="80%" xmlns="http://www.w3.org/2000/svg">
    <defs>
          <pattern id="empty" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#ffffff" stroke= "#333333" stroke-width="2" />
          </pattern>
          <pattern id="full" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#876fc1" stroke= "#333333" stroke-width="2" />
          </pattern>
    </defs>
    <text x="2" y="35" fill="white">Old</text>
    <rect x="122" y="2" width="400" height="40" fill="url(#full)" />
    <text class="error" x="322" y="75" fill="red" style="opacity: 0">
        ERROR
    </text>
    <g class="new">
        <text x="2" y="115" fill="white">New</text>
        <rect x="122" y="82" width="600" height="40" fill="url(#empty)" />
        <rect class="filling" x="122" y="82" width="200" height="40" fill="url(#full)" />
    </g>
</svg>

</script></section><section data-markdown><script type="text/template">
## move

<svg class="animated" width="80%" xmlns="http://www.w3.org/2000/svg">
    <defs>
          <pattern id="empty" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#ffffff" stroke= "#333333" stroke-width="2" />
          </pattern>
          <pattern id="full" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#876fc1" stroke= "#333333" stroke-width="2" />
          </pattern>
    </defs>
    <text x="2" y="35" fill="white">Old</text>
    <rect x="122" y="2" width="400" height="40" fill="url(#full)" />
    <rect class="filling" x="122" y="2" width="200" height="40" fill="url(#empty)" />
    <text class="error" x="322" y="75" fill="red" style="opacity: 0">
        ERROR
    </text>
    <g class="new">
        <text x="2" y="115" fill="white">New</text>
        <rect x="122" y="82" width="600" height="40" fill="url(#empty)" />
        <rect class="filling" x="122" y="82" width="200" height="40" fill="url(#full)" />
    </g>
</svg>

</script></section><section data-markdown><script type="text/template">
## `noexcept` specifier

A function can be decorated with `noexcept(expr)` specifier to indicate whether it will throw:

```cpp
int* allocate_array_impl(int N){
    return new int[N];
}

template<int N>
int* allocate_array() noexcept(N >= 0) {
    return allocate_array_impl(N);
}

int* a = allocate_array<42>();
int* b = allocate_array<-1>();
```

`noexcept` is a shortcut for `noexcept(true)`.

</script></section><section data-markdown><script type="text/template">
## `noexcept` operator

`noexcept(expr)` returns `true` if `expr` is declared to not throw any exceptions.

```cpp
template<typename Func>
void wrapper(Func func) noexcept(noexcept(func())) {
    func();
}
```

</script></section><section data-markdown><script type="text/template">
- destructors are implicitly `noexcept`
- if a `noexcept` function throws, the function `std::terminate` is called 

```cpp
extern void f();  // potentially-throwing
void g() noexcept {
    f();      // valid, even if f throws
    throw 42; // valid, effectively a call to std::terminate
}
```

</script></section><section data-markdown><script type="text/template">
## `noexcept` move

<div class="container">

```cpp [14]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 

    // move constructor
    MovableBuffer(MovableBuffer&& other) noexcept
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other) noexcept
    {
        MovableBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 22[27-28]
///hide
#include <cstddef>
#include <utility>

struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 
    
    // move constructor
    MovableBuffer(MovableBuffer&& other) noexcept
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other) noexcept
    {
        MovableBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/Po3o1F2MuAsyRNciCaOoAcnQbyY)

</script></section><section data-markdown><script type="text/template">
## `std::move` again

```cpp
///hide
#include <type_traits>
///unhide
template< class T >
typename std::remove_reference<T>::type&& move( T&& t ) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

<!-- .element: style="font-size: 0.48em;" -->

We can also move `lvalue`s that are not needed anymore:

```cpp
///hide
#include <string>
#include <vector>
#include <iostream>

void foo() {
///unhide
std::vector<std::string> inputs;
for (std::string s; std::cin >> s;) {
    inputs.push_back(std::move(s));
}
///hide
}
```

<aside class="notes"><p>But <code>s</code> is an <code>lvalue</code>!!</p>
</aside></script></section><section data-markdown><script type="text/template">
## reference collapsing

```cpp
///hide
#include <type_traits>

///unhide
template<typename T>
using lref = T&;

template<typename T>
using rref = T&&;

static_assert(std::is_same<lref<lref<int>>, int&>::value, 
              "& * & = &");
static_assert(std::is_same<lref<rref<int>>, int&>::value, 
              "& * && = &");
static_assert(std::is_same<rref<lref<int>>, int&>::value, 
              "&& * & = &");
static_assert(std::is_same<rref<rref<int>>, int&&>::value, 
              "&& * && = &&");
```

</script></section><section data-markdown><script type="text/template">
## forwarding ref

calling `std::move(s)` instantiates 

```cpp
///fails='move' in namespace 'std' does not name a template type
std::move<std::string&>(std::string & && t)
```

i.e. 

```cpp
///fails='move' in namespace 'std' does not name a template type
std::move<std::string&>(std::string & t)
```

- `template<typename T>(T&&)` just retains the type of the call site argument
- such a reference is called a **forwarding reference**

</script></section><section data-markdown><script type="text/template">
## `std::forward`

forwards the argument to another function with the value category it had when passed to the calling function.

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func&& f, T&& t) { 
  std::cout << "Calling f on " << t;
  return f(std::forward<T>(t)); 
}
```

</script></section><section data-markdown><script type="text/template">
## Special member functions

<table class="noborder" style="font-size: 35px">
    <tr>
        <td>1.</td> <td>default constructor</td> <td><code>T()</code></td>
    <tr>
    <tr>
        <td>2.</td> <td>copy constructor</td> <td><code>T(const T&)</code></td>
    <tr>
    <tr>
        <td>3.</td> <td>move constructor</td> <td><code>T(T&&)</code></td>
    <tr>
    <tr>
        <td>4.</td> <td>destructor</td> <td><code>~T()</code></td>
    <tr>
    <tr>
        <td>5.</td> <td>copy assignment</td> <td><code>T& operator=(const T&)</code></td>
    <tr>
    <tr>
        <td>6.</td> <td>move assignment</td> <td><code>T& operator=(T&&)</code></td>
    <tr>
</table>

**Special** - compiler generated, under certain circumstances

</script></section><section data-markdown><script type="text/template">
![special members](02_move/special_members.jpg) <!-- .element: width="75%" -->

Source: [Howard Hinnant](https://howardhinnant.github.io/classdecl.html)

</script></section><section data-markdown><script type="text/template">
## deleted function

e.g. to prevent narrowing conversions:

```cpp
///fails=use of deleted function 'void foo(int)'
void foo(short i);
void foo(int i) = delete;

///hide
void bar() {
///unhide
foo(static_cast<short>(42));    // ok
foo(42);                        // error, deleted function
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## defaulted special member function

can force the compiler to generate

```cpp
///hide
#include <type_traits>

///unhide
struct T {
    T() = default;
    T(int i);

    T(T&&);
    T(const T&) = default;
};

static_assert(std::is_default_constructible<T>::value, 
              "default");
static_assert(std::is_copy_constructible<T>::value, 
              "copy");
```

</script></section><section data-markdown><script type="text/template">
## rule of 0

> If you can avoid defining default operations, do

</script></section><section data-markdown><script type="text/template">
## rule of 5(6)

> If you define or =delete any default operation, define or =delete them all

</script></section><section data-markdown><script type="text/template">
## class prototypes:

<div class="r-stack r-stretch">

```cpp
class normal
{
public:
    // rule of zero
};
```

```cpp
class container
{
public:
    container() noexcept;
    ~container() noexcept;

    container(const container& other);
    container(container&& other) noexcept;

    container& operator=(const container& other);
    container& operator=(container&& other) noexcept;
};
```

<!-- .element: class="fragment current-visible" -->

```cpp
class resource_handle
{
public:
    resource_handle() noexcept;
    ~resource_handle() noexcept;

    resource_handle(resource_handle&& other) noexcept;
    resource_handle& operator=(resource_handle&& other) noexcept;

    resource_handle(const resource_handle&) = delete;
    resource_handle& operator=(const resource_handle&) = delete;
};
```

<!-- .element: class="fragment current-visible" style="font-size:0.5em" -->

```cpp
class immoveable
{
public:
    immoveable() noexcept;
    ~immoveable() noexcept;

    immoveable(const immoveable&) = delete; 
    immoveable& operator=(const immoveable&) = delete;

    immoveable(immoveable&&) = delete;
    immoveable& operator=(immoveable&&) = delete;
};
```

<!-- .element: class="fragment current-visible" -->

</div>

Source: [Jonathan Müller](https://foonathan.net/2019/02/special-member-functions/)

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="02_move/roar.gif" data-transition="none slide" -->

# Thank you
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 20%" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="03_initialization/irwin.jpeg" -->

</script></section><section data-markdown><script type="text/template">
Take a look at the following code:

<div class="container">

```cpp [|4-6,8-10|1|8,16]
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};
///hide
int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}
```

```cpp 18[|0|21-26|19-20]
///hide
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};
///unhide
int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}
```

</div>

</script></section><section data-markdown><script type="text/template">
## Most vexing parse

```cpp
///hide
struct C{};
struct D{};
struct POD{};
///unhide
C c();            // c: () => C
D d(C(), POD());  // d: (() => C, () => POD) => D
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///hide
int v = 7;
typedef int X;
///unhide
X t1 = v;     // copy initialization
X t2(v);      // direct initialization
X t3 = { v }; // initialize using initializer list
X t4 = X(v);  // make an X from v and copy it to t4
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
int v = 7;
typedef int X;
X t1 = v;     // ok
X t2(v);      // ok
X t3 = { v }; // ok
X t4 = X(v);  // ok
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///fails=conversion from 'int' to non-scalar type 'X' requested
int v = 7;
typedef struct { int x; int y; } X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // ok: X is an aggregate
X t4 = X(v);  // error: we can’t cast an int to a struct
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///fails=conversion from 'int' to non-scalar type 'X' {aka 'std::vector<int>'} requested
///hide
#include <vector>
///unhide
int v = 7;
typedef std::vector<int> X;
X t1 = v;     // error: constructor is explicit
X t2(v);      // ok
X t3 = { v }; // error: not an aggregate
X t4 = X(v);  // ok (make an X from v and copy it to t4)
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Different initialization syntax

```cpp []
///fails=invalid conversion from 'int' to 'X' {aka 'int*'}
int v = 7;
typedef int* X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // error
X t4 = X(v);  // ok: unfortunately converts int to an int*
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## More initialization

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X(42);                      // create a temporary
///hide
}
///unhide
X f(int v) { return v; }    // return a value
///hide
void f2() {
///unhide
void g(X); g(v);            // pass an argument
new X(v);                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X(v), m(v) {}  // base and member initializers
///hide
void f3() {
///unhide
throw v;                    // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="03_initialization/list.gif" -->

# List Initialization

<!-- .element: class="chapter" -->

<div class="footnote" style="text-shadow: 3px 3px black; color: lightblue">

Sources:

- [simplify C++](https://arne-mertz.de/2015/07/new-c-features-uniform-initialization-and-initializer_list/)
- [N2215](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf)

<div>

</script></section><section data-markdown><script type="text/template">
## Initialize (almost) anything with `{}`

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X{42};                      // create a temporary
///hide
}
///unhide
X f(int v) { return {v}; }  // return a value
///hide
void f2() {
///unhide
void g(X); g({v});          // pass an argument
new X{v};                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X{v}, m{v} {}  // base and member initializers
```

This is still forbidden:

```cpp
///fails=expected primary-expression before '{' token
///hide
void f3() {
int v = 42;
///unhide
throw {v};                  // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
# It's also safer

```cpp
///fails=narrowing conversion
int i1(4.2); // no problem
int i2{4.2}; // error: narrowing conversion

double d;
float f1(d); // no problem
float f2{d}; // error: narrowing conversion

float f3(i1); // no problem
float f4{i1}; // error: narrowing conversion

unsigned int ui1(-1); // no problem
unsigned int ui2{-1}; // error: narrowing conversion
```

</script></section><section data-markdown><script type="text/template">
## Now, with list initialization

```cpp [8,17-20]
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : p{2, 22.34}, iarr{0, 1, 2}, d{3.14} {}
};

class D {
public:
  D(C const&, POD const&) {}
};

int main() {
  C c{}; 
  D d{C(), POD()};
  POD* pp = new POD{4, 22.1};
  float* pf = new float[2]{1.2f, 2.3f};
}
```

<!-- .element: style="font-size: 0.3em" -->

</script></section><section data-markdown><script type="text/template">
## Creating an array

```cpp
///options=-std=c++03
///hide
#include <string>

int main(){
///unhide
std::string days[] = { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Creating a vector

```cpp
///options=-std=c++03
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days;
days.reserve(7);

days.push_back("Sunday"); 
days.push_back("Monday"); 
days.push_back("Tuesday"); 
days.push_back("Wednesday"); 
days.push_back("Thursday"); 
days.push_back("Friday"); 
days.push_back("Saturday");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
### `std::initializer_list<T>`

- A lightweight proxy object that provides access to an array of objects of type const T.
- Custructed automatically by the compiler when 
  - calling a constructor/function accepting `std::initializer_list`
  - binding a `braced-init-list` to auto

</script></section><section data-markdown><script type="text/template">
## Example

<div class="container">

```cpp [|4|10]
///hide
#include <vector>
#include <iostream>
///unhide
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};
///hide
int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}
```

```cpp 14[|15|16]
///hide
#include <vector>
#include <iostream>
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};
///unhide
int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}
```

</div>

</script></section><section data-markdown><script type="text/template">
## and

```cpp
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## or even

```cpp
///hide
#include <map>
#include <string>

int main() {
std::string s1;
///unhide
std::map<int, std::string> m = {
        {1, "a"},
        {2, {'a', 'b', 'c'} },
        {3, s1}
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## `initializer_list` constructor is prefered

```cpp
///hide
#include <vector>
#include <cassert>

int main() {
///unhide
std::vector<int> aDozenOfFives(12, 5);
std::vector<int> twelveAndFive{12, 5};
assert(aDozenOfFives != twelveAndFive);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Range-based for loop

Instead of

```cpp [2-4]
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (auto it = begin(v); it != end(v); ++it) {
    std::cout << *it << ' ';
  }
  std::cout << '\n';
}
```

write

```cpp [2-4]
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (const auto& i: v) {
    std::cout << i << ' ';
  }
  std::cout << '\n';
}
```

</script></section><section data-markdown><script type="text/template">
## with `std::initializer_list`

```cpp
///hide
#include <iostream>
int main(){
///unhide
for (auto x : {-1, -2, -3})
  std::cout << x << ' ';
std::cout << '\n';
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Note

```cpp [7-13]
///hide
#include <initializer_list>
#include <type_traits>

///unhide
template<typename Expected, typename Actual>
void hasType(const Actual &) {
  static_assert(std::is_same<Actual, Expected>::value,
                "should be the same");
}

///hide
int main() {
///unhide
int i1{42};
auto i2{42};
hasType<int>(i2);

int i3 = {42};
auto i4 = {42};
hasType<std::initializer_list<int>>(i4);
///hide
}
```

<aside class="notes"><p>This initialization syntax is frequently referred to as &quot;Uniform initialization&quot;. For these reasons, it is not always advised to use this syntax.</p>
</aside></script></section><section data-markdown><script type="text/template">
## note

a *braced-init-list* does not have a type in itself:

```cpp
///fails=no matching function for call to 'do_sth(<brace-enclosed initializer list>)'
template <typename T>
void do_sth(T t);

///hide
void foo() {
///unhide
do_sth({1, 2, 3, 4, 5}); // error: couldn't infer template argument
///hide
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## note

Does not support moves

<div class="container">

```cpp
///hide
#include <vector>
#include <iostream>

///unhide
struct S {
  S() { std::cout << "default\n"; }
  S(const S&) { std::cout << "copy\n"; }
  S(S&&) { std::cout << "move\n"; }
};

///hide
int main() {
///unhide
std::vector<S> v{S(), S(), S()};
///hide
}
```

```cpp
///fails=use of deleted function 'S::S(const S&)'
///hide
#include <vector>
#include <iostream>

///unhide
struct S {
  S() { std::cout << "default\n"; }
  S(const S&) = delete;
  S(S&&) { std::cout << "move\n"; }
};

///hide
void foo() {
///unhide
std::vector<S> v{S(), S(), S()}; // error
///hide
}
```

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="03_initialization/aladin_thanks.gif" data-background-size="contain" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/bruce.png" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## from Boost::Thread library

```cpp
///libs=boost:173
///hide
#include <boost/thread/pthread/thread_data.hpp>
#include <boost/thread/detail/is_convertible.hpp>
#include <boost/bind.hpp>
///unhide
namespace boost {

class thread {
///hide
  boost::detail::thread_data_ptr thread_info;
  struct dummy;
  void start_thread();

///unhide
  template <class F,class A1>
  thread(F f,A1 a1,
         typename disable_if<boost::thread_detail::is_convertible<F&,thread_attributes >, dummy* >::type=0):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1)))
  {
      start_thread();
  }
  template <class F,class A1,class A2>
  thread(F f,A1 a1,A2 a2):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3>
  thread(F f,A1 a1,A2 a2,A3 a3):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7,class A8>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7,a8)))
  {
      start_thread();
  }

  template <class F,class A1,class A2,class A3,class A4,class A5,class A6,class A7,class A8,class A9>
  thread(F f,A1 a1,A2 a2,A3 a3,A4 a4,A5 a5,A6 a6,A7 a7,A8 a8,A9 a9):
      thread_info(make_thread_info(boost::bind(boost::type<void>(),f,a1,a2,a3,a4,a5,a6,a7,a8,a9)))
  {
      start_thread();
  }
};

} // namespace boost
```

<!-- .element: style="font-size:0.3em" -->

</script></section><section data-markdown><script type="text/template">
## common `printf` bug

```cpp
///compiler=g75
#include <cstdio>
#include <string>

std::string getName() {
  return "Dvir";
}

///hide
int main() {

///unhide
printf("Hello %s", getName());
///hide

}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/smith.gif" -->

## Variadic templates

<!-- .element: class="chapter bottom"  -->

<div class="footnote">

Sources:
- [N2080](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2080.pdf)
- [cppreference](https://en.cppreference.com/w/cpp/language/parameter_pack)
- [Fluent{C++}](https://www.fluentcpp.com/2019/02/05/how-to-define-a-variadic-number-of-arguments-of-the-same-type-part-3/)

<div>

<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; bottom: 0" -->

</script></section><section data-markdown><script type="text/template">
## variadic type

<div class="r-stack">

```cpp
template<typename... Args> struct count;
```

<div class="fragment highlight bottom" style="background-color:#d7d7d747; height:5em; width:9.5em; top: 1em; left: -8.2em">
parameter pack
</div>

</div>

</script></section><section data-markdown><script type="text/template">
## base specialization

```cpp
///hide
#include <cstddef>
template<typename... Args> struct count;
///unhide
template<>
struct count<> {
  static const size_t value = 0;
};
```

</script></section><section data-markdown><script type="text/template">
## recursive case

<div class="r-stack">

```cpp
///hide
#include <cstddef>
template<typename... Args> struct count;
///unhide
template<typename T, typename... Args>
struct count<T, Args...>
{
  static const size_t value = 1 + count<Args...>::value;
};
```

<div class="fragment highlight bottom" style="background-color:#d7d7d747; height: 5em; width: 4.3em; top: 2.5em; left: 7.2em">
pack expansion
</div>

</div>

</script></section><section data-markdown><script type="text/template">
## check

```cpp [14-15]
///hide
#include <cstddef>
///unhide
template<typename... Args> struct count;

template<>
struct count<> {
  static const size_t value = 0;
};

template<typename T, typename... Args>
struct count<T, Args...>
{
  static const size_t value = 1 + count<Args...>::value;
};

static_assert(count<int, int, double>::value == 3, 
              "3 elements");
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## `sizeof...`

```cpp
///hide
#include <cstddef>

///unhide
template<typename... Args> struct count 
{
  static const size_t value = sizeof...(Args);
};

static_assert(count<int, int, double>::value == 3, 
              "3 elements");
```

<aside class="notes"><p>Args is not expanded</p>
</aside></script></section><section data-markdown><script type="text/template">
## type safe `printf`

<!-- .element data-id="title" -->

```cpp []
///hide
#include <iostream>

///unhide
template<typename T, typename... Args>
void tprintf(const char* format, T value, Args... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

<!-- .element: style="font-size:0.45em" data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## with recursion base

<!-- .element data-id="title" -->

```cpp []
///hide
#include <iostream>

///unhide
void tprintf(const char* format) { std::cout << format; }

template<typename T, typename... Args>
void tprintf(const char* format, T value, Args... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

<!-- .element: style="font-size:0.45em" data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## without copy

<!-- .element data-id="title" -->

```cpp []
///hide
#include <iostream>

///unhide
void tprintf(const char* format) { std::cout << format; }

template<typename T, typename... Args>
void tprintf(const char* format, T value, const Args&... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}
```

<!-- .element: style="font-size:0.45em" data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## compiler generated "recursion"

```cpp
///hide
#include <iostream>

void tprintf(const char* format)
{
    std::cout << format;
}

template<typename T, typename... Args>
void tprintf(const char* format, T value, const Args&... args)
{
    for ( ; *format != '\0'; format++ ) {
        if ( *format == '%' ) {
           std::cout << value;
           tprintf(format+1, args...); // recursive call
           return;
        }
        std::cout << *format;
    }
}

///unhide
int main() {
  tprintf("% world% %\n", "Hello", '!', 123);

  // compiler generates
  // tprintf("% world% %\n", "Hello", '!', 123);
  // tprintf(" world% %\n", '!', 123);
  // tprintf(" %\n", 123);
  // tprintf("\n");
}
```

</script></section><section data-markdown><script type="text/template">
## new `boost::thread`

```cpp
///libs=boost:173
///hide
#include <boost/thread/pthread/thread_data.hpp>
#include <boost/thread/detail/is_convertible.hpp>
#include <boost/bind.hpp>
///unhide
namespace boost {

class thread {
///hide
  boost::detail::thread_data_ptr thread_info;
  struct dummy;
  void start_thread();

///unhide
  template <class F, class Arg, class ...Args>
  thread(F&& f, Arg&& arg, Args&&... args) :
    thread_info(make_thread_info(
      thread_detail::decay_copy(boost::forward<F>(f)),
      thread_detail::decay_copy(boost::forward<Arg>(arg)),
      thread_detail::decay_copy(boost::forward<Args>(args))...)
    )
  {
    start_thread();
  }
};

} // namespace boost
```

<!-- .element: style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
## more pack expansions

```cpp [1|2|3|4-7|8-9]
///hide
template<typename... Args> void f(Args...);
template<typename... Args> void h(Args...);
template<typename... Args>
void foo(Args... args) {
auto n = 0;
///unhide
f(&args...); // f(&E1, &E2, &E3)
f(n, ++args...); // f(n, ++E1, ++E2, ++E3);
f(++args..., n); // f(++E1, ++E2, ++E3, n);
f(const_cast<const Args*>(&args)...);
// f(const_cast<const E1*>(&X1), 
//   const_cast<const E2*>(&X2), 
//   const_cast<const E3*>(&X3))
f(h(args...) + args...);
// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)
///hide
}
```

<aside class="notes"><p>last is nested</p>
</aside></script></section><section data-markdown><script type="text/template">
## non-type template parameter pack

```cpp
template<typename... Ts, int... N>
void g(Ts (&...arr)[N]) {}

///hide
int main() {
///unhide
int n[1];
g("a", n); // Ts (&...arr)[N] expands to 
           // const char (&)[2], int(&)[1]
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Base specifiers and member initializer lists

```cpp
template<class... Mixins>
class X : public Mixins... {
 public:
    X(const Mixins&... mixins) : Mixins(mixins)... { }
};
```

</script></section><section data-markdown><script type="text/template">
## `std::tuple`

a variadic pair

```cpp
template< class... Types >
class tuple;
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## return multiple values

```cpp [|1|3|9-13]
///hide
#include <tuple>
#include <string>
#include <iostream>

///unhide
std::tuple<double, char, std::string> get_student(int id)
{
    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");
    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");
    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");
    throw std::invalid_argument("id");
}

///hide
int main() {
///unhide
auto student0 = get_student(0);
std::cout << "ID: 0, "
          << "GPA: " << std::get<0>(student0) << ", "
          << "grade: " << std::get<1>(student0) << ", "
          << "name: " << std::get<2>(student0) << '\n';
///hide
}
```

<!-- .element: data-id="code" style="font-size:0.44em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::tie`

```cpp [9-16]
///hide
#include <tuple>
#include <string>
#include <iostream>

///unhide
std::tuple<double, char, std::string> get_student(int id)
{
    if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");
    if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");
    if (id == 2) return std::make_tuple(1.7, 'D', "Ralph Wiggum");
    throw std::invalid_argument("id");
}

///hide
int main() {
///unhide
double gpa1;
char grade1;
std::string name1;
std::tie(gpa1, grade1, name1) = get_student(1);
std::cout << "ID: 1, "
          << "GPA: " << gpa1 << ", "
          << "grade: " << grade1 << ", "
          << "name: " << name1 << '\n';
///hide
}
```

<!-- .element: data-id="code" style="font-size:0.44em" -->

<aside class="notes"><p>creates a tuple of references</p>
</aside></script></section><section data-markdown><script type="text/template">
## `std::ignore`

```cpp [|3]
///hide
#include <iostream>
#include <string>
#include <set>
#include <tuple>
 
int main()
{
///unhide
std::set<std::string> set_of_str;
bool inserted = false;
std::tie(std::ignore, inserted) = set_of_str.insert("Test");
if (inserted) {
    std::cout << "Value was inserted successfully\n";
}
///hide
}
```

<!-- .element: style="font-size:0.5em" -->

</script></section><section data-markdown><script type="text/template">
## avoiding cecursion

```cpp
///hide
#include <cassert>
///unhide
int sum() {
  return 0;
}

template<typename T, typename... Args>
int sum(const T& t, const Args&... args)
{
  return t + sum(args...);
}

///hide
int main() {
///unhide
assert(sum(1, 2, 3) == 6);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## `std::initializer_list` for the rescue

```cpp
///hide
#include <cassert>
#include <initializer_list>

///unhide
template<typename... Args>
int sum(const Args&... args)
{
  auto res = 0;
  (void)std::initializer_list<int>{(res += args, 0)...};
  return res;
}

///hide
int main() {
///unhide
assert(sum(1, 2, 3) == 6);
///hide
}
```

<aside class="notes"><p>C++17 has fold expressions</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/same.gif" -->

# variadic arguments of the same type

<!-- .element: class="r-stretch" style="display: flex; align-items: flex-end; text-shadow: 3px 3px black; color: lightblue" -->

</script></section><section data-markdown><script type="text/template">
## Solution #1 

`std::initializer_list`

```cpp
///hide
#include <cassert>
#include <initializer_list>

///unhide
int sum(std::initializer_list<int> ints);

///hide
void foo() {
///unhide
assert(sum({1, 2, 3}) == 6);
// sum({1, 2, "3"}); // fails to compile
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
#include <type_traits>

template<class...> struct conjunction : std::true_type { };

template<class B1> struct conjunction<B1> : B1 { };

template<class B1, class... Bn>
struct conjunction<B1, Bn...> 
    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};
```

<!-- .element: style="font-size: 0.45em" -->

<aside class="notes"><p>in the standard from C++17</p>
</aside></script></section><section data-markdown><script type="text/template">
## Solution #2

`static_assert`

```cpp
///hide
#include <type_traits>
#include <cassert>

template<class...> struct conjunction : std::true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...> 
    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};
///unhide

template<typename... Args>
int sum(const Args&... args) {
  static_assert(conjunction<std::is_same<Args, int>...>::value, 
                "all arguments should be int");
}

///hide
void foo() {
///unhide
assert(sum(1, 2, 3) == 6);
// sum(1, 2, "3"); // fails to compile
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## SFINAE

"Substitution Failure Is Not An Error"

```cpp [|2,9|5,9]
template<typename T>
void f(T x, typename T::type y);
 
template<typename T>
void f(T x, typename T::other_type y);

struct A
{
    using type = int;
};

///hide
void foo() {
///unhide
f(A(), 42);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
`std::enable_if`

```cpp
template<bool B, class T = void>
struct enable_if {};
 
template<class T>
struct enable_if<true, T> { 
  typedef T type; 
};
```

</script></section><section data-markdown><script type="text/template">
## Solution #3

SFINAE

```cpp
///hide
#include <type_traits>
#include <cassert>

template<class...> struct conjunction : std::true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...> 
    : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type {};

///unhide
template<typename... Ts>
using AllInts = typename std::enable_if<
  conjunction<std::is_same<Ts, int>...>::value
  >::type;


template<typename... Args, typename = AllInts<Args...>>
int sum(const Args&... args);

///hide
void foo() {
///unhide
assert(sum(1, 2, 3) == 6);
// sum(1, 2, "3"); // fails to compile
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="04_variadic/matrix_thanks.gif" -->

</script></section></section><section ><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/ferdinand.jpg" -->

</script></section><section data-markdown><script type="text/template">
## count odds

> Given a vector of integers, count the number of odd items.

```cpp
///hide
#include <vector>

///unhide
int count_odds(const std::vector<int>& v);
```

<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
## First try

```cpp
///hide
#include <vector>

///unhide
int count_odds(const std::vector<int>& v)
{
    int ret = 0;
    for (auto it = v.begin(); 
         it != v.end(); 
         ++it)
    {
        if ((*it & 1) == 1)
            ++ret;
    }
    
    return ret;
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="05_lambda/wheel.gif" data-background-size="contain" -->

Don't reinvent the wheel

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `#include <algorithm>`

```cpp
///hide
#include <iterator>

///unhide
template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred);
```

<!-- .element: style="font-size: 0.5em" -->

> Returns the number of iterators it in the range `[first, last)` for which the following condition hold: 
> `pred(*it) != false`

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `#include <algorithm>`

```cpp
///hide
#include <iterator>

///unhide
template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
count_if(InputIterator first, InputIterator last, Predicate pred);
```

<!-- .element: style="font-size: 0.5em" -->

In our case `pred` should have the following signature:

```cpp
bool pred(int i);
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Write a function

```cpp []
///hide
#include <vector>
#include <algorithm>

///unhide
bool isOdd(int i)
{
    return (i & 1) == 1;
}

int count_odds(const std::vector<int>& v)
{
    return std::count_if(v.begin(), v.end(), isOdd);
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Write a function object

```cpp []
///hide
#include <vector>
#include <algorithm>

///unhide
struct IsOdd
{
    bool operator()(int i)
    {
        return (i & 1) == 1;
    }
};

int count_odds(const std::vector<int>& v)
{
    return std::count_if(v.begin(), v.end(), IsOdd());
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## So, what’s the problem?

Creating functions or functors can be a lot of effort, especially if the function/functor is only used in one specific place. 

These functions and functors also unnecessarily ‘clutter up’ the code.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/sirtaki.gif" -->

# Lambda expressions

<!-- .element: class="chapter bottom" -->

</script></section><section data-markdown><script type="text/template">
## Do it `λ`-style!

```cpp
///hide
#include <vector>
#include <algorithm>

///unhide
int count_odds(const std::vector<int>& v)
{
    return std::count_if(v.begin(), v.end(), [](int i)->bool
    {
        return (i & 1) == 1;
    });
}
```

</script></section><section data-markdown><script type="text/template">
## Syntax

<div class="r-stack r-stretch">

<div class="fragment highlight top" style="background-color:#1b91ff3d; height:5em; width:5em; top: -3em; left: -16em">
introducer
</div>

<div class="fragment highlight top" style="background-color:#42affa40; height:5em; width:7em; top: -3em; left: -8em">
(optional) parameter list
</div>

<div class="fragment highlight top" style="background-color:#8dcffc57; height:5em; width:7em; top: -3em; left: 2em">
(optional) return type
</div>

<div class="fragment highlight bottom" style="background-color:#bee4fd52; height:5em; width:24em; top: 3em; left: -6.6em">
body
</div>

```cpp
///hide
void foo() {
///unhide
[]          (int i)          ->bool

{ return (i & 1) == 1; }
///hide
;
}
```

<!-- .element: style="height: auto" -->

</div>

</script></section><section data-markdown><script type="text/template">
## behind the scenes

```cpp
///hide
void foo() {
///unhide
[](int i)->bool
{
    return (i & 1) == 1;
}
///hide
;
}
```

is translated to

```cpp [|4]
class __compiler_generated_name__
{
public: 
    inline bool operator()(int i) const
    {
      return (i & 1) == 1;
    }
};
```

</script></section><section data-markdown><script type="text/template">
## Named lambda

```cpp [2-5|7,9]
///hide
#include <vector>
#include <algorithm>
#include <cassert>

///unhide
void remove_odds(std::vector<int> &v) {
    auto isOdd = [](int i)
    {
        return (i & 1) == 1;
    };

    v.erase(std::remove_if(v.begin(), v.end(), isOdd), v.end());

    assert(std::count_if(v.begin(), v.end(), isOdd) == 0);
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## increment vector

> Given an integer and a vector, add the integer to every element of the vector.

```cpp
///hide
#include <vector>

///unhide
void add_to_vector(std::vector<int>& v, int added);
```

<!-- .element: class="fragment" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::for_each`

```cpp
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function fn);
```

<!-- .element: style="font-size: 0.45em" -->

> Applies function `fn` to each of the elements in the range `[first,last)`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `std::for_each`

```cpp
template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function fn);
```

<!-- .element: style="font-size: 0.45em" -->

In our case `fn` should have the following signature:

```cpp
void fn(int& i);
```

</script></section><section data-markdown><script type="text/template">
## First try

```cpp
///fails='added' is not captured
///hide
#include <vector>
#include <algorithm>

///unhide
void add_to_vector_wrong(std::vector<int>& v, int added)
{
    std::for_each(v.begin(), v.end(), [](int& i)
    {
        i += added;
    });
}
```

</script></section><section data-markdown><script type="text/template">
## Using a function object

```cpp
///hide
#include <vector>
#include <algorithm>

///unhide
struct Add
{
    int m_added;
    Add(int added) : m_added(added) {}
    void operator()(int& i)
    {
        i += m_added;
    }
};

void add_to_vector_struct(std::vector<int>& v, int added)
{
    std::for_each(v.begin(), v.end(), Add(added));
}
```

</script></section><section data-markdown><script type="text/template">
## Capture that

```cpp
///hide
#include <vector>
#include <algorithm>

///unhide
void addToVector(std::vector<int>& v, int added)
{
    std::for_each(v.begin(), v.end(), [added](int& i)
    {
        i += added;
    });
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

### new number -> string conversions

```cpp [2-7,10-11|8-9]
#include <string>

struct Employee {
    int id;
    double salary;

    std::string to_string() const {
        return std::string{"Employee ID: "} + std::to_string(id) 
            + ", Salary: " + std::to_string(salary);
    }
};
```

<!-- .element: style="font-size: 0.45em" -->

- <!-- .element: class="fragment" style="font-size: 0.7em" --> no base support
- <!-- .element: class="fragment" style="font-size: 0.7em" --> return value may differ from what std::cout prints by default
- <!-- .element: class="fragment" style="font-size: 0.7em" --> relies on the current locale for formatting purposes

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

### new string -> number conversions

```cpp [11-15]
#include <string>

struct Employee {
    int id;
    double salary;

    Employee(const std::string& str) {
        const auto next_numeric = [](const std::string& s) {
            return s.substr(s.find_first_of("0123456789"));
        };
        const auto id_start = next_numeric(str);
        auto id_end = size_t{};
        id = std::stoi(id_start, &id_end, 10);
        const auto salary_start = next_numeric(id_start.substr(id_end));
        salary = std::stod(salary_start);
    }
};
```

<!-- .element: style="font-size: 0.45em" -->

-  <!-- .element: class="fragment" style="font-size: 0.7em" --> throws if conversion failed
-  <!-- .element: class="fragment" style="font-size: 0.7em" --> relies on the current locale for formatting purposes


</script></section><section data-markdown><script type="text/template">
## By reference

```cpp
///hide
#include <vector>
#include <algorithm>
#include <string>

///unhide
std::string to_string(const std::vector<int>& v)
{
    std::string s;
    std::for_each(v.begin(), v.end(), [&s](int i)
    {
        s += std::to_string(i) + " ";
    });
    return s;
}
```

</script></section><section data-markdown><script type="text/template">
## Capturing members

```cpp [|3,10-12]
///hide
#include <algorithm>

///unhide
struct ContainerIncrementer
{
    int m_x;
    ContainerIncrementer(int x) : m_x(x) {}
    template<typename Container>
    void increment(Container& cont)
    {
        std::for_each(std::begin(cont), 
                      std::end(cont), 
                      [this](int& val) {
                        val += m_x;
                      }
        );
    }
};
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## Default captures

|||
|-|-|
| `[&]` | Capture any referenced variable by reference |
| `[=]` | Capture any referenced variable by making a copy |
| `[=, &foo]` | Capture any referenced variable by making a copy, but capture variable foo by reference |

</script></section><section data-markdown><script type="text/template">
## fill vector

> fill a given vector with the numbers 0,1,2,...

</script></section><section data-markdown><script type="text/template">
## `#include <numeric>`

```
template< class ForwardIt, class T >
void iota( ForwardIt first, ForwardIt last, T value );
```

> Fills the range `[first, last)` with sequentially increasing values, starting with `value`.

</script></section><section data-markdown><script type="text/template">
## fill vector

```cpp [5]
#include <numeric>
#include <vector>

void fill_vector(std::vector<int>& v) {
    std::iota(v.begin(), v.end(), 0);
}
```

</script></section><section data-markdown><script type="text/template">
## fill vector

> fill a given vector with the numbers 0,2,4,...

</script></section><section data-markdown><script type="text/template">

## `#include <algorithm>`

```
template< class ForwardIt, class Generator >
void generate( ForwardIt first, ForwardIt last, Generator g );
```

<!-- .element: style="font-size: 0.5em" -->

> Assigns each element in range `[first, last)` a value generated by the given function object `g`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## fill vector

```cpp [5-10]
///fails=assignment of read-only variable 'i'
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    int i = 0;
    std::generate(v.begin(), v.end(), [i]{
        const auto next = i;
        i += 2;
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## fill vector

```cpp [8]
///fails=assignment of read-only variable 'i'
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    int i = 0;
    std::generate(v.begin(), v.end(), [i]{
        const auto next = i;
        i += 2; // error: assignment of read-only variable 'i'
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## mutable lambda

```cpp [6]
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    int i = 0;
    std::generate(v.begin(), v.end(), [i]() mutable {
        const auto next = i;
        i += 2;
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## capture init (C++14)

```cpp [5]
#include <algorithm>
#include <vector>

void fill_vector(std::vector<int>& v) {
    std::generate(v.begin(), v.end(), [i = 0]() mutable {
        const auto next = i;
        i += 2;
        return next;
    });
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Higher order lambda

```cpp
///hide
#include <iostream>
#include <string>

///unhide
auto add_prefix(const std::string &prefix) {
    return [&prefix](const std::string s) {
        return prefix + s;
    };
}

///hide
int main() {
///unhide
std::cout << add_prefix("Hello ")("World") << '\n';
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## careful

```cpp
///compiler=clang600
///hide
#include <iostream>
#include <string>

///unhide
auto add_prefix(const std::string &prefix) {
    return [&prefix](const std::string s) {
        return prefix + s;
    };
}

///hide
int main() {
///unhide
const auto prefixer = add_prefix("Hello ");
std::cout << prefixer("World") << '\n';
///hide
}
```

<!-- .element: data-id="code" -->

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [F.53](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-value-capture)

> Avoid capturing by reference in lambdas that will be used non-locally, including returned, stored on the heap, or passed to another thread

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [Con.1](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rconst-immutable)

> By default, make objects immutable

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## it's complicated

```cpp []
///hide
#include <iostream>
#include <string>

///unhide
void draw_upper_case() {
    std::string s;
    for (char c; std::cin >> c; ) {
        s += toupper(c);
    }

    // draw text
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## it's complicated

```cpp [2-8]
///hide
#include <iostream>
#include <string>

///unhide
void draw_upper_case() {
    const auto s = [&] {
        std::string s;
        for (char c; std::cin >> c; ) {
            s += toupper(c);
        }
        return s;
    }();

    // draw text
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## `#include <algorithm>`

```cpp [4-7]
///hide
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>

///unhide
void draw_upper_case() {
    const auto s = [&] {
        std::string s;
        std::transform(std::istream_iterator<char>{std::cin}, 
                       std::istream_iterator<char>{},
                       std::back_inserter(s),
                       toupper);
        return s;
    }();

    // draw text
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## C++ Core Guidelines [ES.28](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es28-use-lambdas-for-complex-initialization-especially-of-const-variables)

> Use lambdas for complex initialization, especially of `const` variables

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/sculptures.webp" data-background-position="top" -->

# legacy code
<!-- .element: class="r-stretch" style="display: flex; align-items: flex-end; justify-content: center; text-shadow: 3px 3px black; color: lightblue" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

Many libraries have such an interface

```cpp []
typedef int(*callback)(char*, int);
void register_callback(callback cb);
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

How can we call this with a lambda?

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

A captureless lambda can be converted to a function pointer

```cpp []
///hide
int read_count = 42;

///unhide
typedef int(*callback)(char*, int);
void register_callback(callback cb);

///hide
void register_callback(callback cb) { cb(nullptr, 0); }

int main(){
///unhide
register_callback([](char* buffer, int size) {
    /// read into buffer
    return read_count;
});
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

For capturing lambda we can add a level of indirection if the library supports user data

```cpp [1-2|4-8|9-11]
///hide
#include <fstream>
int read_count = 42;

///unhide
typedef int(*callback)(const char*, int, void*);
void register_callback(callback cb, void* userdata);

///hide
void register_callback(callback cb, void* userdata) { cb(nullptr, 0, userdata); }

int main(){
///unhide
std::fstream f;
auto cb = [&f](const char* buffer, int size) {
    /// read from f into buffer
    return read_count;
};
register_callback([](const char* buffer, int size, void* userdata){
    return (*static_cast<decltype(cb)*>(userdata))(buffer, size);
}, &cb);
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.45em" -->

<aside class="notes"><p>need to keep <code>cb</code> alive while the callback is active</p>
</aside></script></section><section data-markdown><script type="text/template">
## Let's benchmark

[Benchmark 1](https://quick-bench.com/q/lGVLy95a_GURGh2BJAuC9qKwFS4)

[Benchmark 2](https://quick-bench.com/q/19wvZEycM8eMDSXe5PVn4TUwstw)

</script></section><section data-markdown><script type="text/template">
## Generic Lambda (C++14)

```cpp
///hide
void foo() {
///unhide
[](const auto& a, auto& b){
    b += a;
}
///hide
;
}
```

is translated to

```cpp [4-5]
class __compiler_generated_name__
{
public: 
    template<typename A, typename B>
    inline void operator()(const A& a, B& b) const
    {
      return b += a;
    }
};
```

</script></section><section data-markdown><script type="text/template">
## Templated Lambda (C++20)

e.g. to force the same type

```cpp
///hide
void foo() {
///unhide
[]<typename T>(const T& a, T& b){
    b += a;
}
///hide
;
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Storing lambda

```cpp []
///hide
template<typename Lambda>
///unhide
class CallbackHolder {
public:
    CallbackHolder(Lambda callback) 
        : m_callback{callback} 
    {}

    void call() {
        m_callback();
    }

    Lambda m_callback;
};
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Storing lambda

templatize

```cpp []
///hide
#include <utility>

///unhide
template<typename Lambda>
class CallbackHolder {
public:
    CallbackHolder(Lambda callback) 
        : m_callback{callback} 
    {}

    void call() {
        m_callback();
    }

    Lambda m_callback;
};

template<typename Lambda>
CallbackHolder<Lambda> make_holder(Lambda&& lambda) {
    return { std::forward<Lambda>(lambda) };
}

///hide
int main() {
///unhide
auto holder = make_holder([](){ return 42; });
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Storing lambda

`std::function`

```cpp []
#include <functional>

class CallbackHolder {
public:
    CallbackHolder(std::function<void()> callback) 
        : m_callback{callback} 
    {}

    void call() {
        m_callback();
    }

    std::function<void()> m_callback;
};

///hide
int main() {
///unhide
CallbackHolder holder{[](){ return 42; }};
///hide
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## `std::function`

A general-purpose polymorphic function wrapper. 

```cpp
///hide
template<typename... Ts> class function;

///unhide
template< class R, typename... Args >
class function<R(Args...)>;
```

Can store any `Callable` which recieves `Args` and returns `R`.

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Free function

```cpp []
///hide
#include <functional>

///unhide
long floor(double d) { return d; }

int main(){
    std::function<long(double)> f = floor;
    return f(4.2);
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Lambda

```cpp []
///hide
#include <functional>

///unhide
auto floor = [](double d)->int { return d; };

int main(){
    std::function<long(double)> f = floor;
    return f(4.2);
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Function abject

```cpp []
///hide
#include <functional>

///unhide
struct floor{
    long operator()(double d) { return d; }
};

int main(){
    std::function<long(double)> f = floor{};
    return f(4.2);
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Member function

```cpp []
///hide
#include <functional>

///unhide
struct floor{
    floor(double d) : m_d{d} {}
    long calc() const { return m_d; }
    double m_d;
};

int main(){
    std::function<long(const floor&)> f = &floor::calc;
    return f(floor{4.2});
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-auto-animate -->

## Examples

Member variable

```cpp []
///hide
#include <functional>

///unhide
struct floor{
    floor(double d) : m_d{d} {}
    long calc() const { return m_d; }
    double m_d;
};

int main(){
    std::function<double(const floor&)> f = &floor::m_d;
    return f(floor{4.2});
}
```

<!-- .element: data-id="code" style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" data-auto-animate -->

## virtual function

```cpp []
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get() const { return 1; }
};

struct Derived : Base {
    virtual int get() const { return 2; }
};

///hide
int main() {
///unhide
Base* p = new Derived();
assert(p->get() == 2);
///hide
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
## changing signature

<!-- .slide: class="aside" data-auto-animate -->

```cpp [3,7,11]
///fails=Assertion `p->get(0) == 2' failed
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived : Base {
    virtual int get() const { return 2; }
};

///hide
int main() {
///unhide
Base* p = new Derived();
assert(p->get(0) == 2);
///hide
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
## proper compiler error

<!-- .slide: class="aside" data-auto-animate -->

```cpp [7]
///fails='int Derived::get() const' marked 'override', but does not override
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived : Base {
    int get() const override { return 2; } // error
};

///hide
int main() {
///unhide
Base* p = new Derived();
assert(p->get(0) == 2);
///hide
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
## disable override

<!-- .slide: class="aside" data-auto-animate -->

```cpp [7,11]
///fails=virtual function 'virtual int Grandson::get(int) const' overriding final function
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived : Base {
    int get(int) const final { return 2; }
};

struct Grandson : Derived {
    int get(int) const override { return 3; } // error
}
```

<!-- .element: data-id="override" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## C++ Core Guidelines [C.128](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final)

> Virtual functions should specify exactly one of `virtual`, `override`, or `final`

</script></section><section data-markdown><script type="text/template">
## final class

<!-- .slide: class="aside" -->

```cpp [6,10]
///fails=cannot derive from 'final' base 'Derived' in derived type 'Grandson'
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived final : Base {
    int get(int) const { return 2; }
};

struct Grandson : Derived { // error
}
```

</script></section><section data-markdown><script type="text/template">
## devirtualization

<!-- .slide: class="aside" -->

```cpp [10-12]
///hide
#include <cassert>

///unhide
struct Base {
    virtual ~Base() = default;
    virtual int get(int i) const { return i + 1; }
};

struct Derived final : Base {
    int get(int) const { return 2; }
};

int callGet(const Derived& d, int i) { 
  return d.get(i); 
}
```

</script></section><section data-markdown><script type="text/template">
## `std::function` Ceveats

* might allocate
* may require two calls through function pointers per invocation

[Benchmark 1](https://quick-bench.com/q/DfBQBz4PrwOceIQZIGbodXAXLz8)

[Benchmark 2](https://quick-bench.com/q/1P8T7rMTwrNIR-021rDiHwaJsnY)

</script></section><section data-markdown><script type="text/template">
<div class="r-stretch" style="display: flex; flex-direction: column; align-items: center; justify-content: center">

## Lambdas

1. make code more readable
2. improve locality of the code
3. allow to store state easily
4. make using algorithms easy
5. get better with each revision

</div>

<div class="footnote">

Source: [Bartek's coding blog](https://www.bfilipek.com/2020/05/lambdasadvantages.html?m=1#5-lambdas-get-better-with-each-revision-of-c)

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="05_lambda/ευχαριστώ.jpg" data-background-size="contain" -->
</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"highlight":{"highlightOnLoad":true}}, queryOptions);
    </script>

    <script src="./_assets/scripts/startfrom.js"></script>
    <script src="./_assets/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="./_assets/scripts/customize.js"></script>
    <script src="./_assets/scripts/compiler-explorer.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
