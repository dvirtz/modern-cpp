<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />
    <link rel="stylesheet" href="./_assets/css/custom.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># C++11 and Beyond! <!-- .element: id="title" -->

<img id="logo" src="images/cpp_logo.png" alt="logo">

<table id="versions">
  <tr>
    <td><h1 id="v11">11</h1></td>
    <td><h1 id="v14">14</h1></td>
    <td><h1 id="v17">17</h1></td>
    <td><h1 id="v20">20</h1></td>
  </tr>
</table>

[Dvir Yitzchaki](https://github.com/dvirtz)

<aside class="notes"><ul>
<li>The first C++ standard was published on 1998 with a small bug fix update on 2003.</li>
<li>After being stale for over a decade, starting from 2011, the standard switched to a train model where a new standard is being released every 3 years.</li>
<li>In this series we&#39;re going to discuss the new language and library features added to the C++ standard in the new revisons released since.</li>
<li>On each session we will have one main topic and smaller features will be introduced as needed.</li>
<li>Let&#39;s start.</li>
</ul>
</aside></script></section><section ><section data-markdown><script type="text/template">
## What problems can you find in this code?

```cpp
///fails
///hide
#include <string>
#include <vector>

int main() {
///unhide
// (a)
int i;

// (b)
std::vector<std::string> v;
int size = v.size();

// (c)
std::vector<int> v1(5);
std::vector<int> v2 = 5;
///hide
}
```

<aside class="notes"><ul>
<li>uninitialized variable</li>
<li>possible data lose converting from <code>size_t</code> to <code>int</code></li>
<li>although looking similar, the second line does not compile, because the constructor is <em>explicit</em></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///fails
///hide
#include <vector>
///unhide
void traverser( const std::vector<int>& v ) {
  for( std::vector<int>::iterator i = v.begin(); 
       i != v.end(); 
       ++i )
  {
        // ...
  }
}
```

<aside class="notes"><ul>
<li>this code does not compile because we need a <code>const_iterator</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};
///unhide
gadget get_gadget();
///hide
gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

<small> assuming `gadget` is implicitly convertible to `widget` </small>

<aside class="notes"><ul>
<li>a temporary <code>getget</code> is created which might be a performance pitfall, as the creation of the temporary object is not at all obvious from reading the call site alone.</li>
<li>it&#39;s possible that using <code>gadget</code> is just as well as viable in this code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-color="#bee4fd" -->

## Non member `begin` and `end`

Accept anything with a member `begin` and `end` as well as C-style arrays

```cpp
///execute
///hide
#include <vector>
#include <cassert>
 
int main() 
{
///unhide
std::vector<int> v = { 3, 1, 4 };
auto vi = std::begin(v);
assert(*vi == 3);

int a[] = { -5, 10, 15 };
auto ai = std::begin(a);
assert(*ai == -5);
///hide
}
```

<aside class="notes"><ul>
<li>prefer to use this in generic code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
What does this function do?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void some_function( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><ul>
<li><code>append_unique</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/3oKIPmnZ2IxoAQBta8/giphy.gif" data-transition="none slide" -->

# auto
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 40%" -->

 Slides are based on <!-- .element: class="footnote" style="text-shadow:-1px 0 black, 0 1px black, 1px 0 black, 0 -1px black" -->  [Herb Sutter's](herbsutter.com) GOTW series

<aside class="notes"><ul>
<li>our main topic today</li>
<li>oldest feature in C++11 (first implementation at 1983)</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## declaring a local variable

syntax

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto my_new_variable = its_initial_value;
///hide
}
```

deduce type from initializing expression

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto x = 0x12345678ULL; // type of x is unsigned long long
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## similar to template type deduction
```cpp
template<class T> void f( T ) { }

///hide
int main() {
///unhide
int val = 0;

f( val );     // deduces T == int, calls f<int>( val )

auto x = val; // deduces T == int, x is of type int
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Strips off qualifiers and references
```cpp
///hide
int main() {
///unhide
int           val = 0;

int&          ir  = val;
auto          e   = ir;   // The type of e is int

const int     ci  = val;
auto          h   = ci;   // The type of h is int

const int*    cip = &val;
auto          i   = cip;  // The type of i is const int*

int* const    ipc = &val;
auto          j   = ipc;  // The type of j is int*
///hide
}
```

<aside class="notes"><p>You want your new variable to be just like some existing variable or expression over there, and be initialized from it, but that only means that you want the same basic type, not necessarily that other variable’s own personal secondary attributes such as top-level const– or volatile-ness and &amp;/&amp;&amp; reference-ness which are per-variable. For example, just because he’s const doesn’t mean you’re const, and vice versa.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Can be qualified

```cpp
///hide
int main() {
///unhide
int         val = 0;
auto        a   = val; // The type of a is int
auto&       b   = val; // The type of b is int&
const auto  c   = val; // The type of c is const int
const auto& d   = val; // The type of d is const int&
///hide
}
```

<aside class="notes"><p>If needed, <code>const</code> and <code>&amp;</code> can be explicity added</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/Wtalnj96EH5t2iPxGZ/giphy.gif" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## Forces initialization

instead of

```cpp
///hide
int main() {
///unhide
int i;
///hide
}
```

write

```cpp
///hide
int main() {
///unhide
auto i = 42;    // guaranteed to be initialized
///hide
}
```

<aside class="notes"><p>solving the first problem</p>
</aside></script></section><section data-markdown><script type="text/template">
## Avoid narrowing conversions

instead of

```cpp
///hide
#include <string>
#include <vector>

int main() {
///unhide
std::vector<std::string> v;
int size = v.size();
///hide
}
```

write

```cpp
///hide
#include <string>
#include <vector>

int main() {
std::vector<std::string> v;
///unhide
auto size = v.size(); // exact type, no narrowing
///hide
}
```

<aside class="notes"><p>solving narrowing conversions</p>
</aside></script></section><section data-markdown><script type="text/template">
## DRY initialization syntax

instead of

```cpp
///hide
#include <vector>

int main() {
///unhide
std::vector<int> v2 = std::vector<int>(5);
///hide
}
```

write

```cpp
///hide
#include <vector>

int main() {
///unhide
auto v2 = std::vector<int>(5); // keep it DRY
///hide
}
```

<aside class="notes"><p>if one wants to use explicit constructor with the assignment syntax they would have to repeat the type but not with auto</p>
</aside></script></section><section data-markdown><script type="text/template">
## Correct type by default

instead of

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
std::vector<int>::const_iterator i = v.begin();
///hide
}
```

write

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
auto i = begin(v);
///hide
}
```

<aside class="notes"><ul>
<li>correct and clear and simpler</li>
<li>stays correct if we change the type of the parameter to be non-const</li>
<li>or even replace vector with some other type of container</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Avoids hidden temporaries

instead of

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

write

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = get_gadget(); // gadget can be used
///hide
}
```

or

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = widget(get_gadget()); // widget is needed
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-color="#bee4fd" -->

## `static_assert`

Check assertions at compile time:
```cpp
///hide
constexpr auto bool_constexpr = true;
#define message "should never appear"
///unhide
static_assert ( bool_constexpr , message );
```

For example:
```cpp
static_assert(sizeof(void *) == 8, 
  "Only 64-bit code generation is supported.");
```

<aside class="notes"><ul>
<li>If you only support 64 bit you can give a compile time error if anyone tries to use you code to compile for other architectures</li>
<li>Open CE</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-color="#bee4fd" -->

## `decltype`

Similar to `sizeof(expr)` but returns type instead of size.

```cpp
#include <type_traits>

int f();

static_assert(sizeof(f()) == sizeof(int), 
  "f should return int");
static_assert(std::is_same<int, decltype(f())>::value, 
  "f should return int");
```

</script></section><section data-markdown><script type="text/template">
## what should be the return type

```cpp
///hide
#include <iostream>
#define RETURN_TYPE auto

///unhide
template <typename Func, typename T>
RETURN_TYPE trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we implement a generic tracing function which gets a function <code>f</code> and a value <code>t</code> and returns the result of <code>f(t)</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## what should be the return type

first try

```cpp
///fails
///hide
#include <iostream>

///unhide
template <typename Func, typename T>
decltype(f(t)) trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><ul>
<li>open CE</li>
<li>to express the return type we need to refer to <code>f</code> and <code>t</code> which are unknown to the compiler at the point of defining the return type.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## trailing return type

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) -> decltype(f(t)) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we replace the return type with <code>auto</code> and add the actual return type after the arrow.
At this point we can refer to <code>f</code> and <code>t</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## `auto` return type (C++14)

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>in c++14, this idiom was shortened to mean deduce the return type from the return statement</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/GPn300EibJ2F2/giphy.gif" -->

# CONCERNED?
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue" -->

<aside class="notes"><ul>
<li>There are number of popular concerns about using auto.</li>
<li>Let&#39;s tackle some of them.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
> writing auto to declare a variable is primarily about saving typing.

</script></section><section data-markdown><script type="text/template">
Writing auto is about

- [x] correctness <!-- .element: class="fragment" -->
- [x] performance <!-- .element: class="fragment" -->
- [x] maintainability <!-- .element: class="fragment" -->
- [x] robustness <!-- .element: class="fragment" -->
- [x] convenience <!-- .element: class="fragment" -->

<aside class="notes"><p>No, writing auto is about</p>
<ul>
<li>correctness</li>
<li>performance</li>
<li>maintainability</li>
<li>robustness</li>
<li>AND FINALLY, ALSO</li>
<li>convenience</li>
</ul>
<p>Next...</p>
</aside></script></section><section data-markdown><script type="text/template">
> But in some cases I do want to commit to a specific type, not automatically deduce it, so I can’t use auto.

</script></section><section data-markdown><script type="text/template">
Use

```cpp
///hide
template<typename type>
void foo(type init) {
///unhide
auto x = type(init);
///hide
}
```

<aside class="notes"><p>WRONG!</p>
</aside></script></section><section data-markdown><script type="text/template">
> My code gets unreadable quickly when I don’t know what exact type my variable is without hunting around to see what that function or expression returns, so I can’t just use auto all the time.

</script></section><section data-markdown><script type="text/template">
How many concrete types are in this function?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void append_unique( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><p>the lack of exact types makes it much more powerful and doesn’t significantly harm its readability</p>
</aside></script></section><section data-markdown><script type="text/template">
## write code against interfaces, not implementations

- <!-- .element: class="fragment" -->  Functions - hiding code
- <!-- .element: class="fragment" -->  OO - hiding code and data
- <!-- .element: class="fragment" --> Polymorphism - hiding type

<aside class="notes"><ul>
<li>we write functions to hide implmenetation code</li>
<li>we write class to hide private members and methods</li>
<li>we use static (templates) and dynamic (virtual methods) polymorphism to write generic code</li>
<li>using <code>auto</code> is another link in this software development chain</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Using `auto`

- <!-- .element: class="fragment" --> guarantees the variable will be initialized
- <!-- .element: class="fragment" --> efficient by default
- <!-- .element: class="fragment" --> guarantees that you will use the correct exact type
- <!-- .element: class="fragment" --> guarantees that you will continue to use the correct exact type
- <!-- .element: class="fragment" --> is the only good option for hard-to-spell and impossible-to-spell types
- <!-- .element: class="fragment" --> is just generally simpler and less typing

</script></section><section data-markdown><script type="text/template">
# Thank you

</script></section></section><section ><section data-markdown><script type="text/template">
Take a look at the following code:

<div class="container" style="font-size: 0.6em">

```cpp [|4-6,8-10|1|8,16]
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};
///hide
int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}
```

<!-- .element: data-fragment-index="0" -->

```cpp 18[|0|21-26|19-20]
///hide
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};
///unhide
int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}
```

<!-- .element: data-fragment-index="0" -->

</div>

</script></section><section data-markdown><script type="text/template">
## Most vexing parse

```cpp
///fails
C c();            // c: () => C
D d(C(), POD());  // d: (() => C, () => POD) => D
```

</script></section><section data-markdown><script type="text/template">
Different initialization syntax

```cpp
///fails
X t1 = v;     // copy initialization
X t2(v);      // direct initialization
X t3 = { v }; // initialize using initializer list
X t4 = X(v);  // make an X from v and copy it to t4
```

</script></section><section data-markdown><script type="text/template">
```cpp
///hide
int main() {
///unhide
int v = 7;
typedef int X;
X t1 = v;     // ok
X t2(v);      // ok
X t3 = { v }; // ok
X t4 = X(v);  // ok
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
///fails
///hide
int main() {
///unhide
int v = 7;
typedef struct { int x; int y; } X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // ok: X is an aggregate 
              // (“extra members” are default initialized)
X t4 = X(v);  // error: we can’t cast an int to a struct
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
///fails
///hide
#include <vector>
int main() {
///unhide
int v = 7;
typedef std::vector<int> X;
X t1 = v;     // error: constructor is explicit
X t2(v);      // ok
X t3 = { v }; // error: not an aggregate
X t4 = X(v);  // ok (make an X from v and copy it to t4)
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
///fails
///hide
int main() {
///unhide
int v = 7;
typedef int* X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // error
X t4 = X(v);  // ok: unfortunately converts int to an int*
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## More initialization

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X(42);                      // create a temporary
///hide
}
///unhide
X f(int v) { return v; }    // return a value
///hide
void f2() {
///unhide
void g(X); g(v);            // pass an argument
new X(v);                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X(v), m(v) {}  // base and member initializers
///hide
void f3() {
///unhide
throw v;                    // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="https://media.giphy.com/media/YLHwkqayc1j7a/giphy.gif" data-transition="none slide"- -->

# List Initialization

<!-- .element: style="text-shadow: 3px 3px black; color: lightblue" -->

<div style="position: fixed; left: 0; bottom: 0;">
<small>

Sources:
- [simplify C++](https://arne-mertz.de/2015/07/new-c-features-uniform-initialization-and-initializer_list/)
- [N2215](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf)

<small>
<div>

</script></section><section data-markdown><script type="text/template">
## Initialize (almost) anything with `{}`

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X{42};                      // create a temporary
///hide
}
///unhide
X f(int v) { return {v}; }  // return a value
///hide
void f2() {
///unhide
void g(X); g({v});          // pass an argument
new X{v};                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X{v}, m{v} {}  // base and member initializers
```

This is still forbidden:

```cpp
///fails
///hide
void f3() {
int v = 42;
///unhide
throw {v};                  // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
# It's also safer

```cpp
///fails
int i1(4.2); // no problem
int i2{4.2}; // error: narrowing conversion

double d;
float f1(d); // no problem
float f2{d}; // error: narrowing conversion

float f3(i1); // no problem
float f4{i1}; // error: narrowing conversion

unsigned int ui1(-1); // no problem
unsigned int ui2{-1}; // error: narrowing conversion
```

</script></section><section data-markdown><script type="text/template">
## Now, with list initialization

```cpp [8,17-20]
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : p{2, 22.34}, iarr{0, 1, 2}, d{3.14} {}
};

class D {
public:
  D(C const&, POD const&) {}
};

int main() {
  C c{}; 
  D d{C(), POD()};
  POD* pp = new POD{4, 22.1};
  float* pf = new float[2]{1.2f, 2.3f};
}
```

<!-- .element: style="font-size: 0.3em" -->

</script></section><section data-markdown><script type="text/template">
## Creating an array

```cpp
///options=-std=c++03
///hide
#include <string>

int main(){
///unhide
std::string days[] = { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Creating a vector

```cpp
///options=-std=c++03
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days;
days.reserve(7);

days.push_back("Sunday"); 
days.push_back("Monday"); 
days.push_back("Tuesday"); 
days.push_back("Wednesday"); 
days.push_back("Thursday"); 
days.push_back("Friday"); 
days.push_back("Saturday");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
### `std::initializer_list<T>`

- A lightweight proxy object that provides access to an array of objects of type const T.
- Custructed automatically by the compiler when 
  - calling a constructor/function accepting `std::initializer_list`
  - binding a `braced-init-list` to auto

</script></section><section data-markdown><script type="text/template">
## Example

<div class="container" style="font-size: 0.6em">

```cpp [|4|10]
///hide
#include <vector>
#include <iostream>
///unhide
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};
///hide
int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}
```

<!-- .element: data-fragment-index="0" -->

```cpp 14[|15|16]
///hide
#include <vector>
#include <iostream>
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};
///unhide
int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}
```

<!-- .element: data-fragment-index="0" -->

</div>

</script></section><section data-markdown><script type="text/template">
## and

```cpp
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## or even

```cpp
///hide
#include <map>
#include <string>

int main() {
std::string s1;
///unhide
std::map<int, std::string> m = {
        {1, "a"},
        {2, {'a', 'b', 'c'} },
        {3, s1}
};
///hide
}

</script></section><section data-markdown><script type="text/template">
## `initializer_list` constructor is prefered

```cpp
///execute
///hide
#include <vector>
#include <cassert>

int main() {
///unhide
std::vector<int> aDozenOfFives(12, 5);
std::vector<int> twelveAndFive{12, 5};
assert(aDozenOfFives != twelveAndFive);
///hide
}
///
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-color="#bee4fd" -->

## Range-based for loop

Instead of

```cpp
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (auto it = begin(v); it != end(v); ++it) {
    std::cout << *it << ' ';
  }
  std::cout << '\n';
}
```

write

```cpp
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (const auto& i: v) {
    std::cout << i << ' ';
  }
  std::cout << '\n';
}
```

</script></section><section data-markdown><script type="text/template">
## with `std::initializer_list`

```cpp
///hide
#include <iostream>
int main(){
///unhide
for (auto x : {-1, -2, -3})
  std::cout << x << ' ';
std::cout << '\n';
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Note

```cpp [1-5|7-9|11-13]
///hide
#include <initializer_list>
#include <type_traits>

///unhide
template<typename Expected, typename Actual>
void hasType(const Actual &) {
  static_assert(std::is_same<Actual, Expected>::value,
                "should be the same");
}

///hide
int main() {
///unhide
int i1{42};
auto i2{42};
hasType<int>(i2);

int i3 = {42};
auto i4 = {42};
hasType<std::initializer_list<int>>(i4);
///hide
}
```

<aside class="notes"><p>This initialization syntax is frequently referred to as &quot;Uniform initialization&quot;. For these reasons, it is not always advised to use this syntax.</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="https://media.giphy.com/media/26gsjCZpPolPr3sBy/giphy.gif" data-background-size="contain" -->
</script></section></section></div>
    </div>

    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugins/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugins/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>

    <script src="./_assets/scripts/compiler-explorer.js"></script>
    <script src="./_assets/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="./_assets/scripts/customize.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
