<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./css/reveal.css" />
    <link rel="stylesheet" href="./css/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print" />
    <link rel="stylesheet" href="./_assets/css/custom.css" />
    <link rel="stylesheet" href="./_assets/css/animations.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># C++11 and Beyond! <!-- .element: id="title" -->

<img id="logo" src="images/cpp_logo.png" alt="logo">

<table id="versions">
  <tr>
    <td><h1 id="v11">11</h1></td>
    <td><h1 id="v14">14</h1></td>
    <td><h1 id="v17">17</h1></td>
    <td><h1 id="v20">20</h1></td>
  </tr>
</table>

[Dvir Yitzchaki](https://github.com/dvirtz)

<aside class="notes"><ul>
<li>The first C++ standard was published on 1998 with a small bug fix update on 2003.</li>
<li>After being stale for over a decade, starting from 2011, the standard switched to a train model where a new standard is being released every 3 years.</li>
<li>In this series we&#39;re going to discuss the new language and library features added to the C++ standard in the new revisons released since.</li>
<li>On each session we will have one main topic and smaller features will be introduced as needed.</li>
<li>Let&#39;s start.</li>
</ul>
</aside></script></section><section ><section data-markdown><script type="text/template">
## What problems can you find in this code?

```cpp
///fails
///hide
#include <string>
#include <vector>

int main() {
///unhide
// (a)
int i;

// (b)
std::vector<std::string> v;
int size = v.size();

// (c)
std::vector<int> v1(5);
std::vector<int> v2 = 5;
///hide
}
```

<aside class="notes"><ul>
<li>uninitialized variable</li>
<li>possible data lose converting from <code>size_t</code> to <code>int</code></li>
<li>although looking similar, the second line does not compile, because the constructor is <em>explicit</em></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///fails
///hide
#include <vector>
///unhide
void traverser( const std::vector<int>& v ) {
  for( std::vector<int>::iterator i = v.begin(); 
       i != v.end(); 
       ++i )
  {
        // ...
  }
}
```

<aside class="notes"><ul>
<li>this code does not compile because we need a <code>const_iterator</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## And this?

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};
///unhide
gadget get_gadget();
///hide
gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

<small> assuming `gadget` is implicitly convertible to `widget` </small>

<aside class="notes"><ul>
<li>a temporary <code>getget</code> is created which might be a performance pitfall, as the creation of the temporary object is not at all obvious from reading the call site alone.</li>
<li>it&#39;s possible that using <code>gadget</code> is just as well as viable in this code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Non member `begin` and `end`

Accept anything with a member `begin` and `end` as well as C-style arrays

```cpp
///execute
///hide
#include <vector>
#include <cassert>
 
int main() 
{
///unhide
std::vector<int> v = { 3, 1, 4 };
auto vi = std::begin(v);
assert(*vi == 3);

int a[] = { -5, 10, 15 };
auto ai = std::begin(a);
assert(*ai == -5);
///hide
}
```

<aside class="notes"><ul>
<li>prefer to use this in generic code</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
What does this function do?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void some_function( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><ul>
<li><code>append_unique</code></li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/3oKIPmnZ2IxoAQBta8/giphy.gif" data-transition="none slide" -->

# auto
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 40%" -->

 Slides are based on <!-- .element: class="footnote" style="text-shadow:-1px 0 black, 0 1px black, 1px 0 black, 0 -1px black" -->  [Herb Sutter's](herbsutter.com) GOTW series

<aside class="notes"><ul>
<li>our main topic today</li>
<li>oldest feature in C++11 (first implementation at 1983)</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## declaring a local variable

syntax

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto my_new_variable = its_initial_value;
///hide
}
```

deduce type from initializing expression

```cpp
///hide
void foo(int its_initial_value){
///unhide
auto x = 0x12345678ULL; // type of x is unsigned long long
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## similar to template type deduction
```cpp
template<class T> void f( T ) { }

///hide
int main() {
///unhide
int val = 0;

f( val );     // deduces T == int, calls f<int>( val )

auto x = val; // deduces T == int, x is of type int
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Strips off qualifiers and references
```cpp
///hide
int main() {
///unhide
int           val = 0;

int&          ir  = val;
auto          e   = ir;   // The type of e is int

const int     ci  = val;
auto          h   = ci;   // The type of h is int

const int*    cip = &val;
auto          i   = cip;  // The type of i is const int*

int* const    ipc = &val;
auto          j   = ipc;  // The type of j is int*
///hide
}
```

<aside class="notes"><p>You want your new variable to be just like some existing variable or expression over there, and be initialized from it, but that only means that you want the same basic type, not necessarily that other variable’s own personal secondary attributes such as top-level const– or volatile-ness and &amp;/&amp;&amp; reference-ness which are per-variable. For example, just because he’s const doesn’t mean you’re const, and vice versa.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Can be qualified

```cpp
///hide
int main() {
///unhide
int         val = 0;
auto        a   = val; // The type of a is int
auto&       b   = val; // The type of b is int&
const auto  c   = val; // The type of c is const int
const auto& d   = val; // The type of d is const int&
///hide
}
```

<aside class="notes"><p>If needed, <code>const</code> and <code>&amp;</code> can be explicity added</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/Wtalnj96EH5t2iPxGZ/giphy.gif" data-background-size="contain" -->

</script></section><section data-markdown><script type="text/template">
## Forces initialization

instead of

```cpp
///hide
int main() {
///unhide
int i;
///hide
}
```

write

```cpp
///hide
int main() {
///unhide
auto i = 42;    // guaranteed to be initialized
///hide
}
```

<aside class="notes"><p>solving the first problem</p>
</aside></script></section><section data-markdown><script type="text/template">
## Avoid narrowing conversions

instead of

```cpp
///hide
#include <string>
#include <vector>

int main() {
///unhide
std::vector<std::string> v;
int size = v.size();
///hide
}
```

write

```cpp
///hide
#include <string>
#include <vector>

int main() {
std::vector<std::string> v;
///unhide
auto size = v.size(); // exact type, no narrowing
///hide
}
```

<aside class="notes"><p>solving narrowing conversions</p>
</aside></script></section><section data-markdown><script type="text/template">
## DRY initialization syntax

instead of

```cpp
///hide
#include <vector>

int main() {
///unhide
std::vector<int> v2 = std::vector<int>(5);
///hide
}
```

write

```cpp
///hide
#include <vector>

int main() {
///unhide
auto v2 = std::vector<int>(5); // keep it DRY
///hide
}
```

<aside class="notes"><p>if one wants to use explicit constructor with the assignment syntax they would have to repeat the type but not with auto</p>
</aside></script></section><section data-markdown><script type="text/template">
## Correct type by default

instead of

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
std::vector<int>::const_iterator i = v.begin();
///hide
}
```

write

```cpp
///hide
#include <vector>

void foo(std::vector<int> &v) {
///unhide
auto i = begin(v);
///hide
}
```

<aside class="notes"><ul>
<li>correct and clear and simpler</li>
<li>stays correct if we change the type of the parameter to be non-const</li>
<li>or even replace vector with some other type of container</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Avoids hidden temporaries

instead of

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
widget w = get_gadget();
///hide
}
```

write

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = get_gadget(); // gadget can be used
///hide
}
```

or

```cpp
///execute
///hide
#include <iostream>

struct gadget{
    gadget() { std::cout << "gadget()\n"; }
    gadget(const gadget&) { std::cout << "gadget(gadget&)\n"; }
};

struct widget{
    widget() { std::cout << "widget()\n"; }
    widget(const gadget&) { std::cout << "widget(gadget&)\n"; }
};

gadget get_gadget() {
    return gadget();
}

int main() {
///unhide
auto w = widget(get_gadget()); // widget is needed
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `static_assert`

Check assertions at compile time:
```cpp
///hide
constexpr auto bool_constexpr = true;
#define message "should never appear"
///unhide
static_assert ( bool_constexpr , message );
```

For example:
```cpp
static_assert(sizeof(void *) == 8, 
  "Only 64-bit code generation is supported.");
```

<aside class="notes"><ul>
<li>If you only support 64 bit you can give a compile time error if anyone tries to use you code to compile for other architectures</li>
<li>Open CE</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `decltype`

Similar to `sizeof(expr)` but returns type instead of size.

```cpp
#include <type_traits>

int f();

static_assert(sizeof(f()) == sizeof(int), 
  "f should return int");
static_assert(std::is_same<int, decltype(f())>::value, 
  "f should return int");
```

</script></section><section data-markdown><script type="text/template">
## what should be the return type

```cpp
///hide
#include <iostream>
#define RETURN_TYPE auto

///unhide
template <typename Func, typename T>
RETURN_TYPE trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we implement a generic tracing function which gets a function <code>f</code> and a value <code>t</code> and returns the result of <code>f(t)</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## what should be the return type

first try

```cpp
///fails
///hide
#include <iostream>

///unhide
template <typename Func, typename T>
decltype(f(t)) trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><ul>
<li>open CE</li>
<li>to express the return type we need to refer to <code>f</code> and <code>t</code> which are unknown to the compiler at the point of defining the return type.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## trailing return type

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) -> decltype(f(t)) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>we replace the return type with <code>auto</code> and add the actual return type after the arrow.
At this point we can refer to <code>f</code> and <code>t</code>.</p>
</aside></script></section><section data-markdown><script type="text/template">
## `auto` return type (C++14)

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func f, T t) { 
  std::cout << "Calling f on " << t;
  return f(t); 
}
```

<aside class="notes"><p>in c++14, this idiom was shortened to mean deduce the return type from the return statement</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background="https://media.giphy.com/media/GPn300EibJ2F2/giphy.gif" -->

# CONCERNED?
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue" -->

<aside class="notes"><ul>
<li>There are number of popular concerns about using auto.</li>
<li>Let&#39;s tackle some of them.</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
> writing auto to declare a variable is primarily about saving typing.

</script></section><section data-markdown><script type="text/template">
Writing auto is about

- [x] correctness <!-- .element: class="fragment" -->
- [x] performance <!-- .element: class="fragment" -->
- [x] maintainability <!-- .element: class="fragment" -->
- [x] robustness <!-- .element: class="fragment" -->
- [x] convenience <!-- .element: class="fragment" -->

<aside class="notes"><p>No, writing auto is about</p>
<ul>
<li>correctness</li>
<li>performance</li>
<li>maintainability</li>
<li>robustness</li>
<li>AND FINALLY, ALSO</li>
<li>convenience</li>
</ul>
<p>Next...</p>
</aside></script></section><section data-markdown><script type="text/template">
> But in some cases I do want to commit to a specific type, not automatically deduce it, so I can’t use auto.

</script></section><section data-markdown><script type="text/template">
Use

```cpp
///hide
template<typename type>
void foo(type init) {
///unhide
auto x = type(init);
///hide
}
```

<aside class="notes"><p>WRONG!</p>
</aside></script></section><section data-markdown><script type="text/template">
> My code gets unreadable quickly when I don’t know what exact type my variable is without hunting around to see what that function or expression returns, so I can’t just use auto all the time.

</script></section><section data-markdown><script type="text/template">
How many concrete types are in this function?

```cpp
///hide
#include <algorithm>
#include <cassert>

using namespace std;
///unhide
template<class Container, class Value>
void append_unique( Container& c, const Value& v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.push_back(v); 
    assert( !c.empty() );
}
```

<aside class="notes"><p>the lack of exact types makes it much more powerful and doesn’t significantly harm its readability</p>
</aside></script></section><section data-markdown><script type="text/template">
## write code against interfaces, not implementations

- <!-- .element: class="fragment" -->  Functions - hiding code
- <!-- .element: class="fragment" -->  OO - hiding code and data
- <!-- .element: class="fragment" --> Polymorphism - hiding type

<aside class="notes"><ul>
<li>we write functions to hide implmenetation code</li>
<li>we write class to hide private members and methods</li>
<li>we use static (templates) and dynamic (virtual methods) polymorphism to write generic code</li>
<li>using <code>auto</code> is another link in this software development chain</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Using `auto`

- <!-- .element: class="fragment" --> guarantees the variable will be initialized
- <!-- .element: class="fragment" --> efficient by default
- <!-- .element: class="fragment" --> guarantees that you will use the correct exact type
- <!-- .element: class="fragment" --> guarantees that you will continue to use the correct exact type
- <!-- .element: class="fragment" --> is the only good option for hard-to-spell and impossible-to-spell types
- <!-- .element: class="fragment" --> is just generally simpler and less typing

</script></section><section data-markdown><script type="text/template">
# Thank you

</script></section></section><section ><section data-markdown><script type="text/template">
## How many copies?

```cpp
///hide
#include <vector>
#include <cstdint>

///unhide

template<typename Buffer>
std::vector<Buffer> generateBuffers(const size_t INSTANCES, 
                                    const size_t BUFFER_SIZE)
{
    std::vector<Buffer> v;
    for (size_t i = 0; i < INSTANCES; ++i)
    {
        v.push_back(Buffer(BUFFER_SIZE));
    }
    return v;
}
```

<aside class="notes"><ul>
<li>copying from temporary buffer</li>
<li>copying when capacity is full</li>
<li>possible copying when returning <code>v</code></li>
<li>in all theses cases the source is destroyed immediately after copying</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Member initialization

```cpp [|4-6|6]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D;
int f(D);
///unhide
class A
{
public:
    A() : a(7), b(5), hash_algorithm("MD5"), s("Constructor run") {}
    A(int a_val) : a(a_val), b(5), hash_algorithm("MD5"), s("Constructor run") {}
    A(D d) : a(f(d)), b(a), hash_algorithm("MD5"), s("Constroctor run") {}
private:
    int a, b;
    HashingFunction hash_algorithm;
    std::string s;
};
```

<!-- .element: style="font-size:0.4em;" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Non-static data member initializers

```cpp [|8-10|4-6]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D;
int f(D);
///unhide
class A
{
public:
    A() {}
    A(int a_val) : a(a_val) {}
    A(D d) : a(f(d)), b(a) {}
private:
    int a(7), b(5);
    HashingFunction hash_algorithm("MD5");
    std::string s("Constructor run");
};
```

<aside class="notes"><p><code>auto</code> is not allowed even with initializer;</p>
</aside></script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Delegating constructors

```cpp [|4-9|10]
///hide
#include <string>
struct HashingFunction{
    HashingFunction(const std::string&);
};
struct D;
int f(D);
///unhide
class A
{
public:
    A(int _a = 7, 
      int _b = 5, 
      const HashingFunction& _hash_algorithm ="MD5", 
      const std::string& _s = "Constructor run") 
    : a(_a), b(_b), hash_algorithm(_hash_algorithm), s(_s) 
    {}
    A(D d) : A(f(d), b(a)) {}
private:
    int a, b;
    HashingFunction hash_algorithm;
    std::string s;
};
```

<!-- .element: style="font-size: 0.4em" -->

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## `nullptr`

A type safe replacement for `NULL` macro

```cpp
///external
///compiler=vcpp_v19_24_x64
///options=/O2
///hide
#include <cstddef>
///unhide
void foo(int);
void foo(char*);

///hide
int main(){
///unhide
foo(42); // calls foo(int);
foo(NULL); // calls foo(int);
foo(nullptr); // calls foo(char*);
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Buffer copy

<div class="container">

```cpp [|2-3|5-10|12-18|0|0]
///hide
#include <algorithm>
///unhide
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///hide
    Buffer& operator=(const Buffer& other) 
    {
        delete[] m_pArray;
        m_size = other.m_size;
        m_pArray = new int[m_size];
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

```cpp 19[|0|0|0|19-28|30]
///hide
#include <algorithm>
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///unhide
    Buffer& operator=(const Buffer& other) 
    {
        delete[] m_pArray;
        m_size = other.m_size;
        m_pArray = new int[m_size];
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

<div>

</script></section><section data-markdown><script type="text/template">
## implement assignment by copy constructor

<div class="container">

```cpp [0]
///hide
#include <algorithm>
///unhide
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///hide
    Buffer& operator=(const Buffer& other) 
    {
        Buffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

```cpp 19[19-25]
///hide
#include <algorithm>
struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}

    Buffer(const Buffer& other) 
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                  other.m_pArray + m_size, 
                  m_pArray);
    }
///unhide
    Buffer& operator=(const Buffer& other) 
    {
        Buffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }

    ~Buffer() { delete[] m_pArray; }
};
```

<div>

</script></section><section data-markdown><script type="text/template">
## Still from temporary

```cpp
///hide
#include <cstddef>
struct Buffer {
size_t m_size;
int* m_pArray;

Buffer(size_t size = 0) 
    : m_size(size)
    , m_pArray(size == 0 
                ? nullptr 
                : new int[size])
{}
///unhide
Buffer(const Buffer& temporary)
    : m_size(temporary.m_size)
    , m_pArray(temporary.m_pArray)
{}
///hide
~Buffer() { delete[] m_pArray; }
};
```

<aside class="notes"><ul>
<li>As we know the temporary won’t be used after the assignment operator, why not “move” its resources to the new object instead of copy them?</li>
<li>There&#39;s a problem with this code though - double delete</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## Without double delete

```cpp
///hide
#include <cstddef>
struct Buffer {
size_t m_size;
int* m_pArray;

Buffer(size_t size = 0) 
    : m_size(size)
    , m_pArray(size == 0 
                ? nullptr 
                : new int[size])
{}
///unhide
Buffer(Buffer& temporary)
    : m_size(temporary.m_size)
    , m_pArray(temporary.m_pArray)
{
    temporary.m_size = 0;
    temporary.m_pArray = nullptr;
}
///hide
~Buffer() { delete[] m_pArray; }
};
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="images/move_it.gif" data-background-size="contain" data-transition="none slide" -->

# Move semantics
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 8%" -->

</script></section><section data-markdown><script type="text/template">
## How can we tell?

```cpp
///hide
#include <algorithm>

struct Buffer {
    size_t m_size;
    int* m_pArray;

    Buffer(size_t size = 0) 
        : m_size(size)
        , m_pArray(size == 0 
                    ? nullptr 
                    : new int[size])
    {}
    Buffer(const Buffer& other)
        : Buffer(other.m_size)
    {
        std::copy(other.m_pArray, 
                    other.m_pArray + m_size, 
                    m_pArray);
    }
    ~Buffer() { delete[] m_pArray; }
};

int main() {
const auto BUFFER_SIZE = 4;
///unhide
Buffer c = Buffer(BUFFER_SIZE); // can move
Buffer d = c; // cannot move
// keep using c and d
///hide
}
```

<aside class="notes"><p>We need a way to distinguish between references to temporary objects and regular objects.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Value type

Originally:

> - l-value: can be on the left hand side of an assignment
- r-value: can be **only** on the right hand side of an assignment

</script></section><section data-markdown><script type="text/template">
## Left or right?

```cpp [|4|5|6|7|8|9]
///hide
#include <vector>
int main() {
///unhide
int a, b, *p;
std::vector<int> v(2);

a         = 42;
b         = a;
b         = a * b;
p         = new int;
*p        = min(a, b);
v.front() = 6;
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Value type

More accurately: 

> an expression is an *l*-value if it has a specific memory location and its address can be taken using the & operator, otherwise it is an *r*-value.

</script></section><section data-markdown><script type="text/template">
## Value type

```cpp
///fails
///hide
int main() {
///unhide
int a, b;
int* c;
c = &a;
c = &(a * b); // error
///hide
}
```

All expressions returning temporary values are r-values.

All named objects are l-values.

</script></section><section data-markdown><script type="text/template">
## L-value references

A (non-const) reference can be bound only to l-values:

```cpp
///fails
int a, b;
int& c = a;
int& d = (a * b); // error
```

</script></section><section data-markdown><script type="text/template">
## R-value references

Can be bound only to r-values and uses the && syntax.

```cpp
///fails
int a = 1, b = 2;
int&& c = a; // error
int&& d = (a * b);
cout << ++d << endl;
```

<aside class="notes"><p><code>d</code> is extending the lifetime of <code>(a * b)</code></p>
</aside></script></section><section data-markdown><script type="text/template">
## Move constructor and assignment operator

<div class="container">

```cpp [|3-11|13-20|0]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 

    // move constructor
    MovableBuffer(MovableBuffer&& other)
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(MovableBuffer&& other)
    {
        MovableBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 22[|22-24|0|26-34]
///hide
#include <cstddef>
#include <utility>

struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 
    
    // move constructor
    MovableBuffer(MovableBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other)
    {
        MovableBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/ryKzdF90wADpRQ6hHuvUvhat1Z0)

</script></section><section data-markdown><script type="text/template">
## Move only

<div class="container">

```cpp [|0]
///fails
///hide
#include <cstddef>
#include <utility>

///unhide
struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    MoveOnlyBuffer& operator=(MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 18[|21]
///fails
///hide
#include <cstddef>
#include <utility>

struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    MoveOnlyBuffer& operator=(
        MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(other);
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

<aside class="notes"><ul>
<li>show compiler error</li>
<li>performance bug in the movable class</li>
</ul>
</aside></script></section><section data-markdown><script type="text/template">
## `std::move`

casts the argument to an `rvalue`

```cpp
///hide
#include <type_traits>
///unhide
namespace std {

template< class T >
typename remove_reference<T>::type&& move( T&& t ) noexcept {
    return static_cast<typename remove_reference<T>::type&&>(t);
}

} // namespace std
```

<!-- .element: style="font-size: 0.5em;" -->

</script></section><section data-markdown><script type="text/template">
## (really) move only

<div class="container">

```cpp [0]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    MoveOnlyBuffer& operator=(MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 18[21]
///hide
#include <cstddef>
#include <utility>

struct MoveOnlyBuffer
{
    size_t m_size;
    int* m_pArray;

    MoveOnlyBuffer(size_t size = 0);

    ~MoveOnlyBuffer() { delete[] m_pArray; }
    
    MoveOnlyBuffer(MoveOnlyBuffer&& other) 
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    MoveOnlyBuffer& operator=(
        MoveOnlyBuffer&& other)
    {
        MoveOnlyBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/mevho4kNsJTPbnA7S8zrFToi5Is)

</script></section><section data-markdown><script type="text/template">
## Exception safety

<table style="font-size:0.55em">
    <tr>
        <td>Nothrow exception guarantee</td> <td>the function never throws exceptions</td>
    </tr>
    <tr>
        <td>Strong exception guarantee</td> <td>If the function throws an exception, the state of the program is rolled back to the state just before the function call</td>
    </tr>
    <tr>
        <td>Basic exception guarantee</td> <td>If the function throws an exception, the program is in a valid state. No resources are leaked, and all objects' invariants are intact</td>
    </tr>
    <tr>
        <td>No exception guarantee</td> <td><img src="images/dragons.jpg" alt="dragons" style="position: relative; height: 20%; left: 30%"></img></td>
    </tr>
</table>

</script></section><section data-markdown><script type="text/template">
`vector::push_back` pseudo code

```cpp
///fails
template<typename T>
void vector<T>::push_back(const T& value) {
    if (size == capacity) {
        allocate larger buffer
        if (is movable) {
            // move all Ts to the new buffer
        } else {
            // copy all Ts to the new buffer
        }
    }
    // copy value to the end if the buffer
}
```

</script></section><section data-markdown><script type="text/template">
## copy

<svg class="animated" width="80%" xmlns="http://www.w3.org/2000/svg">
    <defs>
          <pattern id="empty" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#ffffff" stroke= "#333333" stroke-width="2" />
          </pattern>
          <pattern id="full" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#876fc1" stroke= "#333333" stroke-width="2" />
          </pattern>
    </defs>
    <text x="2" y="35" fill="white">Old</text>
    <rect x="122" y="2" width="400" height="40" fill="url(#full)" />
    <text class="error" x="322" y="75" fill="red" style="opacity: 0">
        ERROR
    </text>
    <g class="new">
        <text x="2" y="115" fill="white">New</text>
        <rect x="122" y="82" width="600" height="40" fill="url(#empty)" />
        <rect class="filling" x="122" y="82" width="200" height="40" fill="url(#full)" />
    </g>
</svg>

</script></section><section data-markdown><script type="text/template">
## move

<svg class="animated" width="80%" xmlns="http://www.w3.org/2000/svg">
    <defs>
          <pattern id="empty" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#ffffff" stroke= "#333333" stroke-width="2" />
          </pattern>
          <pattern id="full" x="2" y="2" width="40" height="40" patternUnits="userSpaceOnUse">
              <rect x="1" y="1" width="38" height="38" fill= "#876fc1" stroke= "#333333" stroke-width="2" />
          </pattern>
    </defs>
    <text x="2" y="35" fill="white">Old</text>
    <rect x="122" y="2" width="400" height="40" fill="url(#full)" />
    <rect class="filling" x="122" y="2" width="200" height="40" fill="url(#empty)" />
    <text class="error" x="322" y="75" fill="red" style="opacity: 0">
        ERROR
    </text>
    <g class="new">
        <text x="2" y="115" fill="white">New</text>
        <rect x="122" y="82" width="600" height="40" fill="url(#empty)" />
        <rect class="filling" x="122" y="82" width="200" height="40" fill="url(#full)" />
    </g>
</svg>

</script></section><section data-markdown><script type="text/template">
## `noexcept` specifier

A function can be decorated with `noexcept(expr)` specifier to indicate whether it will throw:

```cpp
int* allocate_array_impl(int N){
    return new int[N];
}

template<int N>
int* allocate_array() noexcept(N >= 0) {
    return allocate_array_impl(N);
}

///hide
int main() {
///unhide
int* a = allocate_array<42>();
int* b = allocate_array<-1>();
///hide
}
```

`noexcept` is a shortcut for `noexcept(true)`.

</script></section><section data-markdown><script type="text/template">
## `noexcept` operator

`noexcept(expr)` returns `true` if `expr` is declared to not throw any exceptions.

```cpp
template<typename Func>
void wrapper(Func func) noexcept(noexcept(func())) {
    func();
}
```

</script></section><section data-markdown><script type="text/template">
- destructors are implicitly `noexcept`
- if a `noexcept` function throws, the function `std::terminate` is called 

```cpp
extern void f();  // potentially-throwing
void g() noexcept {
    f();      // valid, even if f throws
    throw 42; // valid, effectively a call to std::terminate
}
```

</script></section><section data-markdown><script type="text/template">
## `noexcept` move

<div class="container">

```cpp [14]
///hide
#include <cstddef>
#include <utility>

///unhide
struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 

    // move constructor
    MovableBuffer(MovableBuffer&& other) noexcept
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///hide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other) noexcept
    {
        MovableBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

```cpp 22[27-28]
///hide
#include <cstddef>
#include <utility>

struct MovableBuffer
{
    size_t m_size;
    int* m_pArray;

    MovableBuffer(size_t size = 0);

    ~MovableBuffer() { delete[] m_pArray; }

    // copy constructor
    MovableBuffer(const MovableBuffer& other); 
    
    // move constructor
    MovableBuffer(MovableBuffer&& other) noexcept
        : m_size(other.m_size)
        , m_pArray(other.m_pArray)
    {
        other.m_size = 0;
        other.m_pArray = nullptr;
    }

///unhide
    // copy assignment operator
    MovableBuffer& operator=(
        const MovableBuffer& other);

    // move assignment operator
    MovableBuffer& operator=(
        MovableBuffer&& other) noexcept
    {
        MovableBuffer tmp(std::move(other));
        std::swap(m_size, tmp.m_size);
        std::swap(m_pArray, tmp.m_pArray);
        return *this;
    }
};
```

</div>

</script></section><section data-markdown><script type="text/template">
# [Let's benchmark](http://quick-bench.com/Po3o1F2MuAsyRNciCaOoAcnQbyY)

</script></section><section data-markdown><script type="text/template">
## `std::move` again

```cpp
///hide
#include <type_traits>
///unhide
template< class T >
typename std::remove_reference<T>::type&& move( T&& t ) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

<!-- .element: style="font-size: 0.48em;" -->

We can also move `lvalue`s that are not needed anymore:

```cpp
///hide
#include <string>
#include <vector>
#include <iostream>

void foo() {
///unhide
std::vector<std::string> inputs;
for (std::string s; std::cin >> s;) {
    inputs.push_back(std::move(s));
}
///hide
}
```

<aside class="notes"><p>But <code>s</code> is an <code>lvalue</code>!!</p>
</aside></script></section><section data-markdown><script type="text/template">
## reference collapsing

```cpp
///hide
#include <type_traits>

///unhide
template<typename T>
using lref = T&;

template<typename T>
using rref = T&&;

static_assert(std::is_same<lref<lref<int>>, int&>::value, 
              "& * & = &");
static_assert(std::is_same<lref<rref<int>>, int&>::value, 
              "& * && = &");
static_assert(std::is_same<rref<lref<int>>, int&>::value, 
              "&& * & = &");
static_assert(std::is_same<rref<rref<int>>, int&&>::value, 
              "&& * && = &&");
```

</script></section><section data-markdown><script type="text/template">
## forwarding ref

calling `std::move(s)` instantiates 

```cpp
///fails
std::move<std::string&>(std::string & && t)
```

i.e. 

```cpp
///fails
std::move<std::string&>(std::string & t)
```

- `template<typename T>(T&&)` just retains the type of the call site argument
- such a reference is called a **forwarding reference**

</script></section><section data-markdown><script type="text/template">
## `std::forward`

forwards the argument to another function with the value category it had when passed to the calling function.

```cpp
///hide
#include<iostream>
///unhide
template <typename Func, typename T>
auto trace(Func&& f, T&& t) { 
  std::cout << "Calling f on " << t;
  return f(std::forward<T>(t)); 
}
```

</script></section><section data-markdown><script type="text/template">
## Special member functions

<table class="noborder" style="font-size: 35px">
    <tr>
        <td>1.</td> <td>default constructor</td> <td><code>T()</code></td>
    <tr>
    <tr>
        <td>2.</td> <td>copy constructor</td> <td><code>T(const T&)</code></td>
    <tr>
    <tr>
        <td>3.</td> <td>move constructor</td> <td><code>T(T&&)</code></td>
    <tr>
    <tr>
        <td>4.</td> <td>destructor</td> <td><code>~T()</code></td>
    <tr>
    <tr>
        <td>5.</td> <td>copy assignment</td> <td><code>T& operator=(const T&)</code></td>
    <tr>
    <tr>
        <td>6.</td> <td>move assignment</td> <td><code>T& operator=(T&&)</code></td>
    <tr>
</table>

**Special** - compiler generated, under certain circumstances

</script></section><section data-markdown><script type="text/template">
![special members](images/special_members.jpg) <!-- .element: width="75%" -->

Source: [Howard Hinnant](https://howardhinnant.github.io/classdecl.html)

</script></section><section data-markdown><script type="text/template">
## deleted function

e.g. to prevent narrowing conversions:

```cpp
///fails
void foo(short i);
void foo(int i) = delete;

///hide
int main() {
///unhide
foo(static_cast<short>(42));    // ok
foo(42);                        // error, deleted function
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## defaulted special member function

can force the compiler to generate

```cpp
///hide
#include <type_traits>

///unhide
struct T {
    T() = default;
    T(int i);

    T(T&&);
    T(const T&) = default;
};

static_assert(std::is_default_constructible<T>::value, 
              "default");
static_assert(std::is_copy_constructible<T>::value, 
              "copy");
```

</script></section><section data-markdown><script type="text/template">
## rule of 0

> If you can avoid defining default operations, do

</script></section><section data-markdown><script type="text/template">
## rule of 5(6)

> If you define or =delete any default operation, define or =delete them all

</script></section><section data-markdown><script type="text/template">
## class prototypes:

<div class="stack">

```cpp
class normal
{
public:
    // rule of zero
};
```

```cpp
class container
{
public:
    container() noexcept;
    ~container() noexcept;

    container(const container& other);
    container(container&& other) noexcept;

    container& operator=(const container& other);
    container& operator=(container&& other) noexcept;
};
```

<!-- .element: class="fragment fade-in-then-out" -->

```cpp
class resource_handle
{
public:
    resource_handle() noexcept;
    ~resource_handle() noexcept;

    resource_handle(resource_handle&& other) noexcept;
    resource_handle& operator=(resource_handle&& other) noexcept;

    resource_handle(const resource_handle&) = delete;
    resource_handle& operator=(const resource_handle&) = delete;
};
```

<!-- .element: class="fragment fade-in-then-out" style="font-size:0.5em" -->

```cpp
class immoveable
{
public:
    immoveable() noexcept;
    ~immoveable() noexcept;

    immoveable(const immoveable&) = delete; 
    immoveable& operator=(const immoveable&) = delete;

    immoveable(immoveable&&) = delete;
    immoveable& operator=(immoveable&&) = delete;
};
```

<!-- .element: class="fragment fade-in" -->

</div>

Source: [Jonathan Müller](https://foonathan.net/2019/02/special-member-functions/)

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="images/roar.gif" data-transition="none slide" -->

# Thank you
<!-- .element: style="text-shadow: 3px 3px black; color: lightblue; position: fixed; top: 0; left: 20%" -->

</script></section></section><section ><section data-markdown><script type="text/template">
Take a look at the following code:

<div class="container">

```cpp [|4-6,8-10|1|8,16]
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};
///hide
int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}
```

```cpp 18[|0|21-26|19-20]
///hide
///options=-std=c++03
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : d(3.14) {
    p.i=2; p.f=22.34;
    for (unsigned i = 0; i < 3; ++i) iarr[i] = i;
  }
};

class D {
public:
  D(C const&, POD const&) {}
};
///unhide
int main() {
  C c(); 
  D d(C(), POD());
  POD* pp = new POD();
  pp->i = 4;
  pp->f = 22.1;
  float* pf = new float[2];
  pf[0] = 1.2f;
  pf[1] = 2.3f;
}
```

</div>

</script></section><section data-markdown><script type="text/template">
## Most vexing parse

```cpp
///fails
C c();            // c: () => C
D d(C(), POD());  // d: (() => C, () => POD) => D
```

</script></section><section data-markdown><script type="text/template">
Different initialization syntax

```cpp
///fails
X t1 = v;     // copy initialization
X t2(v);      // direct initialization
X t3 = { v }; // initialize using initializer list
X t4 = X(v);  // make an X from v and copy it to t4
```

</script></section><section data-markdown><script type="text/template">
```cpp
///hide
int main() {
///unhide
int v = 7;
typedef int X;
X t1 = v;     // ok
X t2(v);      // ok
X t3 = { v }; // ok
X t4 = X(v);  // ok
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
///fails
///hide
int main() {
///unhide
int v = 7;
typedef struct { int x; int y; } X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // ok: X is an aggregate 
              // (“extra members” are default initialized)
X t4 = X(v);  // error: we can’t cast an int to a struct
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
///fails
///hide
#include <vector>
int main() {
///unhide
int v = 7;
typedef std::vector<int> X;
X t1 = v;     // error: constructor is explicit
X t2(v);      // ok
X t3 = { v }; // error: not an aggregate
X t4 = X(v);  // ok (make an X from v and copy it to t4)
///hide
}
```

</script></section><section data-markdown><script type="text/template">
```cpp
///fails
///hide
int main() {
///unhide
int v = 7;
typedef int* X;
X t1 = v;     // error
X t2(v);      // error
X t3 = { v }; // error
X t4 = X(v);  // ok: unfortunately converts int to an int*
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## More initialization

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X(42);                      // create a temporary
///hide
}
///unhide
X f(int v) { return v; }    // return a value
///hide
void f2() {
///unhide
void g(X); g(v);            // pass an argument
new X(v);                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X(v), m(v) {}  // base and member initializers
///hide
void f3() {
///unhide
throw v;                    // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="images/list.gif" data-transition="none slide"- -->

# List Initialization

<!-- .element: style="text-shadow: 3px 3px black; color: lightblue" -->

<div style="position: fixed; left: 0; bottom: 0;">
<small>

Sources:
- [simplify C++](https://arne-mertz.de/2015/07/new-c-features-uniform-initialization-and-initializer_list/)
- [N2215](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf)

<small>
<div>

</script></section><section data-markdown><script type="text/template">
## Initialize (almost) anything with `{}`

```cpp
///hide
struct X {
    X(int);
};
struct Y : X {
    Y(int);
    int m;
};

int v;

void f1() {
///unhide
X{42};                      // create a temporary
///hide
}
///unhide
X f(int v) { return {v}; }  // return a value
///hide
void f2() {
///unhide
void g(X); g({v});          // pass an argument
new X{v};                   // create object on free store
///hide
}
///unhide
Y::Y(int v) :X{v}, m{v} {}  // base and member initializers
```

This is still forbidden:

```cpp
///fails
///hide
void f3() {
int v = 42;
///unhide
throw {v};                  // throw an exception 
///hide
}
```

</script></section><section data-markdown><script type="text/template">
# It's also safer

```cpp
///fails
int i1(4.2); // no problem
int i2{4.2}; // error: narrowing conversion

double d;
float f1(d); // no problem
float f2{d}; // error: narrowing conversion

float f3(i1); // no problem
float f4{i1}; // error: narrowing conversion

unsigned int ui1(-1); // no problem
unsigned int ui2{-1}; // error: narrowing conversion
```

</script></section><section data-markdown><script type="text/template">
## Now, with list initialization

```cpp [8,17-20]
struct POD { int i; float f; };

class C {
  POD p;
  int iarr[3];
  double d;
public:
  C() : p{2, 22.34}, iarr{0, 1, 2}, d{3.14} {}
};

class D {
public:
  D(C const&, POD const&) {}
};

int main() {
  C c{}; 
  D d{C(), POD()};
  POD* pp = new POD{4, 22.1};
  float* pf = new float[2]{1.2f, 2.3f};
}
```

<!-- .element: style="font-size: 0.3em" -->

</script></section><section data-markdown><script type="text/template">
## Creating an array

```cpp
///options=-std=c++03
///hide
#include <string>

int main(){
///unhide
std::string days[] = { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Creating a vector

```cpp
///options=-std=c++03
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days;
days.reserve(7);

days.push_back("Sunday"); 
days.push_back("Monday"); 
days.push_back("Tuesday"); 
days.push_back("Wednesday"); 
days.push_back("Thursday"); 
days.push_back("Friday"); 
days.push_back("Saturday");
///hide
}
```

</script></section><section data-markdown><script type="text/template">
### `std::initializer_list<T>`

- A lightweight proxy object that provides access to an array of objects of type const T.
- Custructed automatically by the compiler when 
  - calling a constructor/function accepting `std::initializer_list`
  - binding a `braced-init-list` to auto

</script></section><section data-markdown><script type="text/template">
## Example

<div class="container">

```cpp [|4|10]
///hide
#include <vector>
#include <iostream>
///unhide
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};
///hide
int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}
```

```cpp 14[|15|16]
///hide
#include <vector>
#include <iostream>
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout 
          << "constructed with a " 
          << l.size() 
          << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(end(v), begin(l), end(l));
    }
};
///unhide
int main() {
  S<int> s = {1, 2, 3, 4, 5};
  s.append({6, 7, 8});
}
```

</div>

</script></section><section data-markdown><script type="text/template">
## and

```cpp
///hide
#include <string>
#include <vector>

int main(){
///unhide
std::vector<std::string> days { 
  "Sunday", 
  "Monday", 
  "Tuesday", 
  "Wednesday", 
  "Thursday", 
  "Friday", 
  "Saturday" 
};
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## or even

```cpp
///hide
#include <map>
#include <string>

int main() {
std::string s1;
///unhide
std::map<int, std::string> m = {
        {1, "a"},
        {2, {'a', 'b', 'c'} },
        {3, s1}
};
///hide
}

</script></section><section data-markdown><script type="text/template">
## `initializer_list` constructor is prefered

```cpp
///execute
///hide
#include <vector>
#include <cassert>

int main() {
///unhide
std::vector<int> aDozenOfFives(12, 5);
std::vector<int> twelveAndFive{12, 5};
assert(aDozenOfFives != twelveAndFive);
///hide
}
///
```

</script></section><section data-markdown><script type="text/template">
<!-- .slide: class="aside" -->

## Range-based for loop

Instead of

```cpp
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (auto it = begin(v); it != end(v); ++it) {
    std::cout << *it << ' ';
  }
  std::cout << '\n';
}
```

write

```cpp
///hide
#include <vector>
#include <iostream>
///unhide
void print(const std::vector<int>& v){
  for (const auto& i: v) {
    std::cout << i << ' ';
  }
  std::cout << '\n';
}
```

</script></section><section data-markdown><script type="text/template">
## with `std::initializer_list`

```cpp
///hide
#include <iostream>
int main(){
///unhide
for (auto x : {-1, -2, -3})
  std::cout << x << ' ';
std::cout << '\n';
///hide
}
```

</script></section><section data-markdown><script type="text/template">
## Note

```cpp [1-5|7-9|11-13]
///hide
#include <initializer_list>
#include <type_traits>

///unhide
template<typename Expected, typename Actual>
void hasType(const Actual &) {
  static_assert(std::is_same<Actual, Expected>::value,
                "should be the same");
}

///hide
int main() {
///unhide
int i1{42};
auto i2{42};
hasType<int>(i2);

int i3 = {42};
auto i4 = {42};
hasType<std::initializer_list<int>>(i4);
///hide
}
```

<aside class="notes"><p>This initialization syntax is frequently referred to as &quot;Uniform initialization&quot;. For these reasons, it is not always advised to use this syntax.</p>
</aside></script></section><section data-markdown><script type="text/template">
## note

a *braced-init-list* does not have a type in itself:

```cpp
///fails
template <typename T>
void do_sth(T t);

///hide
int main() {
///unhide
do_sth({1, 2, 3, 4, 5}); // error: couldn't infer template argument
///hide
}
```

<!-- .element: style="font-size: 0.5em" -->

</script></section><section data-markdown><script type="text/template">
## note

Does not support moves

<div class="container">

```cpp
///execute
///hide
#include <vector>
#include <iostream>

///unhide
struct S {
  S() { std::cout << "default\n"; }
  S(const S&) { std::cout << "copy\n"; }
  S(S&&) { std::cout << "move\n"; }
};

///hide
int main() {
///unhide
std::vector<S> v{S(), S(), S()};
///hide
}
```

```cpp
///fails
///hide
#include <vector>
#include <iostream>

///unhide
struct S {
  S() { std::cout << "default\n"; }
  S(const S&) = delete;
  S(S&&) { std::cout << "move\n"; }
};

///hide
int main() {
///unhide
std::vector<S> v{S(), S(), S()}; // error
///hide
}
```

</div>

</script></section><section data-markdown><script type="text/template">
<!-- .slide: data-background-image="images/aladin_thanks.gif" data-background-size="contain" -->
</script></section></section></div>
    </div>

    <script src="./js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugins/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './plugins/highlight.js', async: true },
        { src: './plugin/zoom-js/zoom.js', async: true },
        { src: './plugin/notes/notes.js', async: true },
        { src: './plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>

    <script src="./_assets/scripts/compiler-explorer.js"></script>
    <script src="./_assets/node_modules/jquery/dist/jquery.min.js"></script>
    <script src="./_assets/scripts/customize.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
